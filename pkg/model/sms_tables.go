// Code generated by views (github.com/mpkondrashin/views). DO NOT EDIT

package model

import (
    "database/sql"
	"iter"
)


// ActionSetRow struct represents rows of the ACTION_SET table.
type ActionSetRow struct {
    ActionsetID	string
    Displayname	sql.NullString
    FlowcontrolAction	sql.NullString
    ResetAction	sql.NullInt32
    QuarantineAction	sql.NullInt32
    RateLimitAmount	sql.NullInt32
    SmsQuarantinePolicyID	sql.NullInt32
    TracePriority	sql.NullString
    TraceVerbosity	sql.NullString
    TraceBytes	sql.NullString
    ObjectType	string
    UserDefined	string
    Deleted	string
    Hidden	string
    ReadOnly	string
    IterationID	string
    Version	sql.NullString
    PkgDir	string
    UpdateTime	int64
    NgfwVersion	sql.NullString
}

// IterateActionSet provide access to all rows of the ACTION_SET matching given criteria.
func IterateActionSet(db *sql.DB, where string, callback func(v *ActionSetRow) error) error {
    query := "SELECT ACTIONSET_ID,DISPLAYNAME,FLOWCONTROL_ACTION,RESET_ACTION,QUARANTINE_ACTION,RATE_LIMIT_AMOUNT,SMS_QUARANTINE_POLICY_ID,TRACE_PRIORITY,TRACE_VERBOSITY,TRACE_BYTES,OBJECT_TYPE,USER_DEFINED,DELETED,HIDDEN,READ_ONLY,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME,NGFW_VERSION FROM ACTION_SET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ActionSetRow
        err := rows.Scan(&r.ActionsetID, &r.Displayname, &r.FlowcontrolAction, &r.ResetAction, &r.QuarantineAction, &r.RateLimitAmount, &r.SmsQuarantinePolicyID, &r.TracePriority, &r.TraceVerbosity, &r.TraceBytes, &r.ObjectType, &r.UserDefined, &r.Deleted, &r.Hidden, &r.ReadOnly, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime, &r.NgfwVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeActionSet provide iterator to all rows of the ACTION_SET matching given criteria.
func RangeActionSet(db *sql.DB, where string) iter.Seq2[*ActionSetRow, error] {
	return func(yield func(v *ActionSetRow, err error) bool) {
	    query := "SELECT ACTIONSET_ID,DISPLAYNAME,FLOWCONTROL_ACTION,RESET_ACTION,QUARANTINE_ACTION,RATE_LIMIT_AMOUNT,SMS_QUARANTINE_POLICY_ID,TRACE_PRIORITY,TRACE_VERBOSITY,TRACE_BYTES,OBJECT_TYPE,USER_DEFINED,DELETED,HIDDEN,READ_ONLY,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME,NGFW_VERSION FROM ACTION_SET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ActionSetRow
	        err := rows.Scan(&r.ActionsetID, &r.Displayname, &r.FlowcontrolAction, &r.ResetAction, &r.QuarantineAction, &r.RateLimitAmount, &r.SmsQuarantinePolicyID, &r.TracePriority, &r.TraceVerbosity, &r.TraceBytes, &r.ObjectType, &r.UserDefined, &r.Deleted, &r.Hidden, &r.ReadOnly, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime, &r.NgfwVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ActionSetUserGroupsRow struct represents rows of the ACTION_SET_USER_GROUPS table.
type ActionSetUserGroupsRow struct {
    UserGroupsIDFk	uint
    ActionSetActionsetIDFk	string
}

// IterateActionSetUserGroups provide access to all rows of the ACTION_SET_USER_GROUPS matching given criteria.
func IterateActionSetUserGroups(db *sql.DB, where string, callback func(v *ActionSetUserGroupsRow) error) error {
    query := "SELECT USER_GROUPS_ID_FK,ACTION_SET_ACTIONSET_ID_FK FROM ACTION_SET_USER_GROUPS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ActionSetUserGroupsRow
        err := rows.Scan(&r.UserGroupsIDFk, &r.ActionSetActionsetIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeActionSetUserGroups provide iterator to all rows of the ACTION_SET_USER_GROUPS matching given criteria.
func RangeActionSetUserGroups(db *sql.DB, where string) iter.Seq2[*ActionSetUserGroupsRow, error] {
	return func(yield func(v *ActionSetUserGroupsRow, err error) bool) {
	    query := "SELECT USER_GROUPS_ID_FK,ACTION_SET_ACTIONSET_ID_FK FROM ACTION_SET_USER_GROUPS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ActionSetUserGroupsRow
	        err := rows.Scan(&r.UserGroupsIDFk, &r.ActionSetActionsetIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ActionTypeRefRow struct represents rows of the ACTION_TYPE_REF table.
type ActionTypeRefRow struct {
    ID	uint
    Name	string
    NetscriptID	uint
    Handler	string
    Singleton	int8
}

// IterateActionTypeRef provide access to all rows of the ACTION_TYPE_REF matching given criteria.
func IterateActionTypeRef(db *sql.DB, where string, callback func(v *ActionTypeRefRow) error) error {
    query := "SELECT ID,NAME,NETSCRIPT_ID,HANDLER,SINGLETON FROM ACTION_TYPE_REF"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ActionTypeRefRow
        err := rows.Scan(&r.ID, &r.Name, &r.NetscriptID, &r.Handler, &r.Singleton)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeActionTypeRef provide iterator to all rows of the ACTION_TYPE_REF matching given criteria.
func RangeActionTypeRef(db *sql.DB, where string) iter.Seq2[*ActionTypeRefRow, error] {
	return func(yield func(v *ActionTypeRefRow, err error) bool) {
	    query := "SELECT ID,NAME,NETSCRIPT_ID,HANDLER,SINGLETON FROM ACTION_TYPE_REF"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ActionTypeRefRow
	        err := rows.Scan(&r.ID, &r.Name, &r.NetscriptID, &r.Handler, &r.Singleton)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AddressPairRow struct represents rows of the ADDRESS_PAIR table.
type AddressPairRow struct {
    ID	int
    GroupID	string
    Name	sql.NullString
    SaddrNamedObjID	uint
    DaddrNamedObjID	uint
    NamedAddrGroupType	int8
    SaddrNamedObjListID	sql.NullInt32
    DaddrNamedObjListID	sql.NullInt32
    Locked	sql.NullByte
}

// IterateAddressPair provide access to all rows of the ADDRESS_PAIR matching given criteria.
func IterateAddressPair(db *sql.DB, where string, callback func(v *AddressPairRow) error) error {
    query := "SELECT ID,GROUP_ID,NAME,SADDR_NAMED_OBJ_ID,DADDR_NAMED_OBJ_ID,NAMED_ADDR_GROUP_TYPE,SADDR_NAMED_OBJ_LIST_ID,DADDR_NAMED_OBJ_LIST_ID,LOCKED FROM ADDRESS_PAIR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AddressPairRow
        err := rows.Scan(&r.ID, &r.GroupID, &r.Name, &r.SaddrNamedObjID, &r.DaddrNamedObjID, &r.NamedAddrGroupType, &r.SaddrNamedObjListID, &r.DaddrNamedObjListID, &r.Locked)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAddressPair provide iterator to all rows of the ADDRESS_PAIR matching given criteria.
func RangeAddressPair(db *sql.DB, where string) iter.Seq2[*AddressPairRow, error] {
	return func(yield func(v *AddressPairRow, err error) bool) {
	    query := "SELECT ID,GROUP_ID,NAME,SADDR_NAMED_OBJ_ID,DADDR_NAMED_OBJ_ID,NAMED_ADDR_GROUP_TYPE,SADDR_NAMED_OBJ_LIST_ID,DADDR_NAMED_OBJ_LIST_ID,LOCKED FROM ADDRESS_PAIR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AddressPairRow
	        err := rows.Scan(&r.ID, &r.GroupID, &r.Name, &r.SaddrNamedObjID, &r.DaddrNamedObjID, &r.NamedAddrGroupType, &r.SaddrNamedObjListID, &r.DaddrNamedObjListID, &r.Locked)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AdminSmtpRow struct represents rows of the ADMIN_SMTP table.
type AdminSmtpRow struct {
    ID	int16
    ServerAddress	sql.NullString
    ServerPort	sql.NullInt32
    NotifyEmailNoid	sql.NullInt32
    FromEmailNoid	sql.NullInt32
    ReplytoEmailNoid	sql.NullInt32
    Secure	sql.NullByte
    Username	sql.NullString
    Password	sql.NullString
    Aggregation	int
    UseStarttls	sql.NullByte
}

// IterateAdminSmtp provide access to all rows of the ADMIN_SMTP matching given criteria.
func IterateAdminSmtp(db *sql.DB, where string, callback func(v *AdminSmtpRow) error) error {
    query := "SELECT ID,SERVER_ADDRESS,SERVER_PORT,NOTIFY_EMAIL_NOID,FROM_EMAIL_NOID,REPLYTO_EMAIL_NOID,SECURE,USERNAME,PASSWORD,AGGREGATION,USE_STARTTLS FROM ADMIN_SMTP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AdminSmtpRow
        err := rows.Scan(&r.ID, &r.ServerAddress, &r.ServerPort, &r.NotifyEmailNoid, &r.FromEmailNoid, &r.ReplytoEmailNoid, &r.Secure, &r.Username, &r.Password, &r.Aggregation, &r.UseStarttls)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAdminSmtp provide iterator to all rows of the ADMIN_SMTP matching given criteria.
func RangeAdminSmtp(db *sql.DB, where string) iter.Seq2[*AdminSmtpRow, error] {
	return func(yield func(v *AdminSmtpRow, err error) bool) {
	    query := "SELECT ID,SERVER_ADDRESS,SERVER_PORT,NOTIFY_EMAIL_NOID,FROM_EMAIL_NOID,REPLYTO_EMAIL_NOID,SECURE,USERNAME,PASSWORD,AGGREGATION,USE_STARTTLS FROM ADMIN_SMTP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AdminSmtpRow
	        err := rows.Scan(&r.ID, &r.ServerAddress, &r.ServerPort, &r.NotifyEmailNoid, &r.FromEmailNoid, &r.ReplytoEmailNoid, &r.Secure, &r.Username, &r.Password, &r.Aggregation, &r.UseStarttls)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AdAgentRow struct represents rows of the AD_AGENT table.
type AdAgentRow struct {
    ID	uint
    Version	uint
    Description	sql.NullString
    IPAddr	sql.NullString
    Hostname	sql.NullString
    Port	int
}

// IterateAdAgent provide access to all rows of the AD_AGENT matching given criteria.
func IterateAdAgent(db *sql.DB, where string, callback func(v *AdAgentRow) error) error {
    query := "SELECT ID,VERSION,DESCRIPTION,IP_ADDR,HOSTNAME,PORT FROM AD_AGENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AdAgentRow
        err := rows.Scan(&r.ID, &r.Version, &r.Description, &r.IPAddr, &r.Hostname, &r.Port)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAdAgent provide iterator to all rows of the AD_AGENT matching given criteria.
func RangeAdAgent(db *sql.DB, where string) iter.Seq2[*AdAgentRow, error] {
	return func(yield func(v *AdAgentRow, err error) bool) {
	    query := "SELECT ID,VERSION,DESCRIPTION,IP_ADDR,HOSTNAME,PORT FROM AD_AGENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AdAgentRow
	        err := rows.Scan(&r.ID, &r.Version, &r.Description, &r.IPAddr, &r.Hostname, &r.Port)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AdAgentDcDiagRow struct represents rows of the AD_AGENT_DC_DIAG table.
type AdAgentDcDiagRow struct {
    ID	uint
    Version	uint
    IPAddr	sql.NullString
    LastSuccessTs	sql.NullInt64
    LastSucessEvts	uint64
    LastFailTs	sql.NullInt64
    LastFailReason	sql.NullString
    NumEvtsHr	uint64
    NumEvtsTotal	uint64
    AgentDiagID	uint
}

// IterateAdAgentDcDiag provide access to all rows of the AD_AGENT_DC_DIAG matching given criteria.
func IterateAdAgentDcDiag(db *sql.DB, where string, callback func(v *AdAgentDcDiagRow) error) error {
    query := "SELECT ID,VERSION,IP_ADDR,LAST_SUCCESS_TS,LAST_SUCESS_EVTS,LAST_FAIL_TS,LAST_FAIL_REASON,NUM_EVTS_HR,NUM_EVTS_TOTAL,AGENT_DIAG_ID FROM AD_AGENT_DC_DIAG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AdAgentDcDiagRow
        err := rows.Scan(&r.ID, &r.Version, &r.IPAddr, &r.LastSuccessTs, &r.LastSucessEvts, &r.LastFailTs, &r.LastFailReason, &r.NumEvtsHr, &r.NumEvtsTotal, &r.AgentDiagID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAdAgentDcDiag provide iterator to all rows of the AD_AGENT_DC_DIAG matching given criteria.
func RangeAdAgentDcDiag(db *sql.DB, where string) iter.Seq2[*AdAgentDcDiagRow, error] {
	return func(yield func(v *AdAgentDcDiagRow, err error) bool) {
	    query := "SELECT ID,VERSION,IP_ADDR,LAST_SUCCESS_TS,LAST_SUCESS_EVTS,LAST_FAIL_TS,LAST_FAIL_REASON,NUM_EVTS_HR,NUM_EVTS_TOTAL,AGENT_DIAG_ID FROM AD_AGENT_DC_DIAG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AdAgentDcDiagRow
	        err := rows.Scan(&r.ID, &r.Version, &r.IPAddr, &r.LastSuccessTs, &r.LastSucessEvts, &r.LastFailTs, &r.LastFailReason, &r.NumEvtsHr, &r.NumEvtsTotal, &r.AgentDiagID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AdAgentDiagRow struct represents rows of the AD_AGENT_DIAG table.
type AdAgentDiagRow struct {
    ID	uint
    Version	uint
    NumLogins	uint64
    NumEvtsHr	uint64
    NumEvtsTotal	uint64
    ConnHr	uint64
    ConnTotal	uint64
    MemoryMb	uint
    DiskMb	uint
    LastSuccessDcUserPollTs	sql.NullInt64
    LastSuccessDcUserPollIP	sql.NullString
    DcUserCount	uint64
    DcUserGroupCount	uint64
    RawXml	string
    UpdateTime	string
    AgentID	uint
}

// IterateAdAgentDiag provide access to all rows of the AD_AGENT_DIAG matching given criteria.
func IterateAdAgentDiag(db *sql.DB, where string, callback func(v *AdAgentDiagRow) error) error {
    query := "SELECT ID,VERSION,NUM_LOGINS,NUM_EVTS_HR,NUM_EVTS_TOTAL,CONN_HR,CONN_TOTAL,MEMORY_MB,DISK_MB,LAST_SUCCESS_DC_USER_POLL_TS,LAST_SUCCESS_DC_USER_POLL_IP,DC_USER_COUNT,DC_USER_GROUP_COUNT,RAW_XML,UPDATE_TIME,AGENT_ID FROM AD_AGENT_DIAG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AdAgentDiagRow
        err := rows.Scan(&r.ID, &r.Version, &r.NumLogins, &r.NumEvtsHr, &r.NumEvtsTotal, &r.ConnHr, &r.ConnTotal, &r.MemoryMb, &r.DiskMb, &r.LastSuccessDcUserPollTs, &r.LastSuccessDcUserPollIP, &r.DcUserCount, &r.DcUserGroupCount, &r.RawXml, &r.UpdateTime, &r.AgentID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAdAgentDiag provide iterator to all rows of the AD_AGENT_DIAG matching given criteria.
func RangeAdAgentDiag(db *sql.DB, where string) iter.Seq2[*AdAgentDiagRow, error] {
	return func(yield func(v *AdAgentDiagRow, err error) bool) {
	    query := "SELECT ID,VERSION,NUM_LOGINS,NUM_EVTS_HR,NUM_EVTS_TOTAL,CONN_HR,CONN_TOTAL,MEMORY_MB,DISK_MB,LAST_SUCCESS_DC_USER_POLL_TS,LAST_SUCCESS_DC_USER_POLL_IP,DC_USER_COUNT,DC_USER_GROUP_COUNT,RAW_XML,UPDATE_TIME,AGENT_ID FROM AD_AGENT_DIAG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AdAgentDiagRow
	        err := rows.Scan(&r.ID, &r.Version, &r.NumLogins, &r.NumEvtsHr, &r.NumEvtsTotal, &r.ConnHr, &r.ConnTotal, &r.MemoryMb, &r.DiskMb, &r.LastSuccessDcUserPollTs, &r.LastSuccessDcUserPollIP, &r.DcUserCount, &r.DcUserGroupCount, &r.RawXml, &r.UpdateTime, &r.AgentID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AdAgentGroupRow struct represents rows of the AD_AGENT_GROUP table.
type AdAgentGroupRow struct {
    ID	uint
    Version	uint
    Name	sql.NullString
    Description	sql.NullString
    Timeout	uint
    Retries	uint
    FailedTimeout	uint
}

// IterateAdAgentGroup provide access to all rows of the AD_AGENT_GROUP matching given criteria.
func IterateAdAgentGroup(db *sql.DB, where string, callback func(v *AdAgentGroupRow) error) error {
    query := "SELECT ID,VERSION,NAME,DESCRIPTION,TIMEOUT,RETRIES,FAILED_TIMEOUT FROM AD_AGENT_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AdAgentGroupRow
        err := rows.Scan(&r.ID, &r.Version, &r.Name, &r.Description, &r.Timeout, &r.Retries, &r.FailedTimeout)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAdAgentGroup provide iterator to all rows of the AD_AGENT_GROUP matching given criteria.
func RangeAdAgentGroup(db *sql.DB, where string) iter.Seq2[*AdAgentGroupRow, error] {
	return func(yield func(v *AdAgentGroupRow, err error) bool) {
	    query := "SELECT ID,VERSION,NAME,DESCRIPTION,TIMEOUT,RETRIES,FAILED_TIMEOUT FROM AD_AGENT_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AdAgentGroupRow
	        err := rows.Scan(&r.ID, &r.Version, &r.Name, &r.Description, &r.Timeout, &r.Retries, &r.FailedTimeout)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AdAgentGroupMappingRow struct represents rows of the AD_AGENT_GROUP_MAPPING table.
type AdAgentGroupMappingRow struct {
    AgentID	uint
    AgentGroupID	uint
    AgentOrder	int
}

// IterateAdAgentGroupMapping provide access to all rows of the AD_AGENT_GROUP_MAPPING matching given criteria.
func IterateAdAgentGroupMapping(db *sql.DB, where string, callback func(v *AdAgentGroupMappingRow) error) error {
    query := "SELECT AGENT_ID,AGENT_GROUP_ID,AGENT_ORDER FROM AD_AGENT_GROUP_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AdAgentGroupMappingRow
        err := rows.Scan(&r.AgentID, &r.AgentGroupID, &r.AgentOrder)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAdAgentGroupMapping provide iterator to all rows of the AD_AGENT_GROUP_MAPPING matching given criteria.
func RangeAdAgentGroupMapping(db *sql.DB, where string) iter.Seq2[*AdAgentGroupMappingRow, error] {
	return func(yield func(v *AdAgentGroupMappingRow, err error) bool) {
	    query := "SELECT AGENT_ID,AGENT_GROUP_ID,AGENT_ORDER FROM AD_AGENT_GROUP_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AdAgentGroupMappingRow
	        err := rows.Scan(&r.AgentID, &r.AgentGroupID, &r.AgentOrder)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AdAgentGrpSmsRow struct represents rows of the AD_AGENT_GRP_SMS table.
type AdAgentGrpSmsRow struct {
    ID	uint
    Version	uint
    Description	sql.NullString
    Enabled	int8
    AgentGrpID	uint
}

// IterateAdAgentGrpSms provide access to all rows of the AD_AGENT_GRP_SMS matching given criteria.
func IterateAdAgentGrpSms(db *sql.DB, where string, callback func(v *AdAgentGrpSmsRow) error) error {
    query := "SELECT ID,VERSION,DESCRIPTION,ENABLED,AGENT_GRP_ID FROM AD_AGENT_GRP_SMS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AdAgentGrpSmsRow
        err := rows.Scan(&r.ID, &r.Version, &r.Description, &r.Enabled, &r.AgentGrpID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAdAgentGrpSms provide iterator to all rows of the AD_AGENT_GRP_SMS matching given criteria.
func RangeAdAgentGrpSms(db *sql.DB, where string) iter.Seq2[*AdAgentGrpSmsRow, error] {
	return func(yield func(v *AdAgentGrpSmsRow, err error) bool) {
	    query := "SELECT ID,VERSION,DESCRIPTION,ENABLED,AGENT_GRP_ID FROM AD_AGENT_GRP_SMS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AdAgentGrpSmsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.Description, &r.Enabled, &r.AgentGrpID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AdAgentGrpStateRow struct represents rows of the AD_AGENT_GRP_STATE table.
type AdAgentGrpStateRow struct {
    ID	uint
    Version	uint
    AgentGrpMapping	uint
    ActiveAgentID	sql.NullInt32
    LastRecordTime	sql.NullInt64
    LastPollTime	sql.NullInt64
    LastRecordNumber	sql.NullInt64
    RecordCount	sql.NullInt64
    LastGroupPollTime	sql.NullInt64
    EventRateDay	sql.NullInt32
}

// IterateAdAgentGrpState provide access to all rows of the AD_AGENT_GRP_STATE matching given criteria.
func IterateAdAgentGrpState(db *sql.DB, where string, callback func(v *AdAgentGrpStateRow) error) error {
    query := "SELECT ID,VERSION,AGENT_GRP_MAPPING,ACTIVE_AGENT_ID,LAST_RECORD_TIME,LAST_POLL_TIME,LAST_RECORD_NUMBER,RECORD_COUNT,LAST_GROUP_POLL_TIME,EVENT_RATE_DAY FROM AD_AGENT_GRP_STATE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AdAgentGrpStateRow
        err := rows.Scan(&r.ID, &r.Version, &r.AgentGrpMapping, &r.ActiveAgentID, &r.LastRecordTime, &r.LastPollTime, &r.LastRecordNumber, &r.RecordCount, &r.LastGroupPollTime, &r.EventRateDay)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAdAgentGrpState provide iterator to all rows of the AD_AGENT_GRP_STATE matching given criteria.
func RangeAdAgentGrpState(db *sql.DB, where string) iter.Seq2[*AdAgentGrpStateRow, error] {
	return func(yield func(v *AdAgentGrpStateRow, err error) bool) {
	    query := "SELECT ID,VERSION,AGENT_GRP_MAPPING,ACTIVE_AGENT_ID,LAST_RECORD_TIME,LAST_POLL_TIME,LAST_RECORD_NUMBER,RECORD_COUNT,LAST_GROUP_POLL_TIME,EVENT_RATE_DAY FROM AD_AGENT_GRP_STATE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AdAgentGrpStateRow
	        err := rows.Scan(&r.ID, &r.Version, &r.AgentGrpMapping, &r.ActiveAgentID, &r.LastRecordTime, &r.LastPollTime, &r.LastRecordNumber, &r.RecordCount, &r.LastGroupPollTime, &r.EventRateDay)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AdAgentMetadataRow struct represents rows of the AD_AGENT_METADATA table.
type AdAgentMetadataRow struct {
    ID	uint
    Version	uint
    IPAddrs	string
    Hostname	sql.NullString
    Port	int
    AgentVersion	sql.NullString
    SupportedVersions	sql.NullString
    DomainName	sql.NullString
    OsVersion	sql.NullString
    DcIPAddrs	sql.NullString
    DcOsVers	sql.NullString
    BootTs	sql.NullInt64
    BlacklistIPAddrs	sql.NullString
    WhitelistIPAddrs	sql.NullString
    BaseDn	sql.NullString
    StaleTimeout	sql.NullInt32
    SessionPolling	sql.NullInt32
    UsergroupPolling	sql.NullInt32
    AgentID	uint
    IsAgentResponsive	int8
    ConnState	sql.NullString
    LastSuccessPollTs	sql.NullInt64
    WsPollEnabled	int8
    LdapsEnabled	int8
}

// IterateAdAgentMetadata provide access to all rows of the AD_AGENT_METADATA matching given criteria.
func IterateAdAgentMetadata(db *sql.DB, where string, callback func(v *AdAgentMetadataRow) error) error {
    query := "SELECT ID,VERSION,IP_ADDRS,HOSTNAME,PORT,AGENT_VERSION,SUPPORTED_VERSIONS,DOMAIN_NAME,OS_VERSION,DC_IP_ADDRS,DC_OS_VERS,BOOT_TS,BLACKLIST_IP_ADDRS,WHITELIST_IP_ADDRS,BASE_DN,STALE_TIMEOUT,SESSION_POLLING,USERGROUP_POLLING,AGENT_ID,IS_AGENT_RESPONSIVE,CONN_STATE,LAST_SUCCESS_POLL_TS,WS_POLL_ENABLED,LDAPS_ENABLED FROM AD_AGENT_METADATA"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AdAgentMetadataRow
        err := rows.Scan(&r.ID, &r.Version, &r.IPAddrs, &r.Hostname, &r.Port, &r.AgentVersion, &r.SupportedVersions, &r.DomainName, &r.OsVersion, &r.DcIPAddrs, &r.DcOsVers, &r.BootTs, &r.BlacklistIPAddrs, &r.WhitelistIPAddrs, &r.BaseDn, &r.StaleTimeout, &r.SessionPolling, &r.UsergroupPolling, &r.AgentID, &r.IsAgentResponsive, &r.ConnState, &r.LastSuccessPollTs, &r.WsPollEnabled, &r.LdapsEnabled)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAdAgentMetadata provide iterator to all rows of the AD_AGENT_METADATA matching given criteria.
func RangeAdAgentMetadata(db *sql.DB, where string) iter.Seq2[*AdAgentMetadataRow, error] {
	return func(yield func(v *AdAgentMetadataRow, err error) bool) {
	    query := "SELECT ID,VERSION,IP_ADDRS,HOSTNAME,PORT,AGENT_VERSION,SUPPORTED_VERSIONS,DOMAIN_NAME,OS_VERSION,DC_IP_ADDRS,DC_OS_VERS,BOOT_TS,BLACKLIST_IP_ADDRS,WHITELIST_IP_ADDRS,BASE_DN,STALE_TIMEOUT,SESSION_POLLING,USERGROUP_POLLING,AGENT_ID,IS_AGENT_RESPONSIVE,CONN_STATE,LAST_SUCCESS_POLL_TS,WS_POLL_ENABLED,LDAPS_ENABLED FROM AD_AGENT_METADATA"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AdAgentMetadataRow
	        err := rows.Scan(&r.ID, &r.Version, &r.IPAddrs, &r.Hostname, &r.Port, &r.AgentVersion, &r.SupportedVersions, &r.DomainName, &r.OsVersion, &r.DcIPAddrs, &r.DcOsVers, &r.BootTs, &r.BlacklistIPAddrs, &r.WhitelistIPAddrs, &r.BaseDn, &r.StaleTimeout, &r.SessionPolling, &r.UsergroupPolling, &r.AgentID, &r.IsAgentResponsive, &r.ConnState, &r.LastSuccessPollTs, &r.WsPollEnabled, &r.LdapsEnabled)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AdDomainUserRow struct represents rows of the AD_DOMAIN_USER table.
type AdDomainUserRow struct {
    ID	uint
    Version	uint
    Name	string
    IsCurrent	int8
    AdGrpID	uint
    UpdateTime	string
}

// IterateAdDomainUser provide access to all rows of the AD_DOMAIN_USER matching given criteria.
func IterateAdDomainUser(db *sql.DB, where string, callback func(v *AdDomainUserRow) error) error {
    query := "SELECT ID,VERSION,NAME,IS_CURRENT,AD_GRP_ID,UPDATE_TIME FROM AD_DOMAIN_USER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AdDomainUserRow
        err := rows.Scan(&r.ID, &r.Version, &r.Name, &r.IsCurrent, &r.AdGrpID, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAdDomainUser provide iterator to all rows of the AD_DOMAIN_USER matching given criteria.
func RangeAdDomainUser(db *sql.DB, where string) iter.Seq2[*AdDomainUserRow, error] {
	return func(yield func(v *AdDomainUserRow, err error) bool) {
	    query := "SELECT ID,VERSION,NAME,IS_CURRENT,AD_GRP_ID,UPDATE_TIME FROM AD_DOMAIN_USER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AdDomainUserRow
	        err := rows.Scan(&r.ID, &r.Version, &r.Name, &r.IsCurrent, &r.AdGrpID, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AdLdapServerConfigRow struct represents rows of the AD_LDAP_SERVER_CONFIG table.
type AdLdapServerConfigRow struct {
    ID	uint
    AuthenticationMode	string
    AuthorizationMode	string
    FallbackMode	string
    FallbackGroupIDFk	sql.NullInt32
    LdapDefaultGroupMappingMechanism	string
    LdapDefaultGroupMappingAttribute	sql.NullString
}

// IterateAdLdapServerConfig provide access to all rows of the AD_LDAP_SERVER_CONFIG matching given criteria.
func IterateAdLdapServerConfig(db *sql.DB, where string, callback func(v *AdLdapServerConfigRow) error) error {
    query := "SELECT ID,AUTHENTICATION_MODE,AUTHORIZATION_MODE,FALLBACK_MODE,FALLBACK_GROUP_ID_FK,LDAP_DEFAULT_GROUP_MAPPING_MECHANISM,LDAP_DEFAULT_GROUP_MAPPING_ATTRIBUTE FROM AD_LDAP_SERVER_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AdLdapServerConfigRow
        err := rows.Scan(&r.ID, &r.AuthenticationMode, &r.AuthorizationMode, &r.FallbackMode, &r.FallbackGroupIDFk, &r.LdapDefaultGroupMappingMechanism, &r.LdapDefaultGroupMappingAttribute)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAdLdapServerConfig provide iterator to all rows of the AD_LDAP_SERVER_CONFIG matching given criteria.
func RangeAdLdapServerConfig(db *sql.DB, where string) iter.Seq2[*AdLdapServerConfigRow, error] {
	return func(yield func(v *AdLdapServerConfigRow, err error) bool) {
	    query := "SELECT ID,AUTHENTICATION_MODE,AUTHORIZATION_MODE,FALLBACK_MODE,FALLBACK_GROUP_ID_FK,LDAP_DEFAULT_GROUP_MAPPING_MECHANISM,LDAP_DEFAULT_GROUP_MAPPING_ATTRIBUTE FROM AD_LDAP_SERVER_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AdLdapServerConfigRow
	        err := rows.Scan(&r.ID, &r.AuthenticationMode, &r.AuthorizationMode, &r.FallbackMode, &r.FallbackGroupIDFk, &r.LdapDefaultGroupMappingMechanism, &r.LdapDefaultGroupMappingAttribute)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AdServerRow struct represents rows of the AD_SERVER table.
type AdServerRow struct {
    ID	uint
    Hostname	sql.NullString
    AdminName	sql.NullString
    AdminPassword	sql.NullString
    DomainName	sql.NullString
    Version	sql.NullByte
    State	sql.NullByte
    LastRecordTime	sql.NullInt64
    LastPollTime	sql.NullInt64
    LastRecordNumber	sql.NullInt64
    ServerTime	sql.NullInt64
    RecordCount	sql.NullInt64
    RecordDay	sql.NullInt64
}

// IterateAdServer provide access to all rows of the AD_SERVER matching given criteria.
func IterateAdServer(db *sql.DB, where string, callback func(v *AdServerRow) error) error {
    query := "SELECT ID,HOSTNAME,ADMIN_NAME,ADMIN_PASSWORD,DOMAIN_NAME,VERSION,STATE,LAST_RECORD_TIME,LAST_POLL_TIME,LAST_RECORD_NUMBER,SERVER_TIME,RECORD_COUNT,RECORD_DAY FROM AD_SERVER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AdServerRow
        err := rows.Scan(&r.ID, &r.Hostname, &r.AdminName, &r.AdminPassword, &r.DomainName, &r.Version, &r.State, &r.LastRecordTime, &r.LastPollTime, &r.LastRecordNumber, &r.ServerTime, &r.RecordCount, &r.RecordDay)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAdServer provide iterator to all rows of the AD_SERVER matching given criteria.
func RangeAdServer(db *sql.DB, where string) iter.Seq2[*AdServerRow, error] {
	return func(yield func(v *AdServerRow, err error) bool) {
	    query := "SELECT ID,HOSTNAME,ADMIN_NAME,ADMIN_PASSWORD,DOMAIN_NAME,VERSION,STATE,LAST_RECORD_TIME,LAST_POLL_TIME,LAST_RECORD_NUMBER,SERVER_TIME,RECORD_COUNT,RECORD_DAY FROM AD_SERVER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AdServerRow
	        err := rows.Scan(&r.ID, &r.Hostname, &r.AdminName, &r.AdminPassword, &r.DomainName, &r.Version, &r.State, &r.LastRecordTime, &r.LastPollTime, &r.LastRecordNumber, &r.ServerTime, &r.RecordCount, &r.RecordDay)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AdUserGroupRow struct represents rows of the AD_USER_GROUP table.
type AdUserGroupRow struct {
    ID	uint
    Version	uint
    Dn	string
    Uid	uint
    AdGrpID	uint
    UpdateTime	string
}

// IterateAdUserGroup provide access to all rows of the AD_USER_GROUP matching given criteria.
func IterateAdUserGroup(db *sql.DB, where string, callback func(v *AdUserGroupRow) error) error {
    query := "SELECT ID,VERSION,DN,UID,AD_GRP_ID,UPDATE_TIME FROM AD_USER_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AdUserGroupRow
        err := rows.Scan(&r.ID, &r.Version, &r.Dn, &r.Uid, &r.AdGrpID, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAdUserGroup provide iterator to all rows of the AD_USER_GROUP matching given criteria.
func RangeAdUserGroup(db *sql.DB, where string) iter.Seq2[*AdUserGroupRow, error] {
	return func(yield func(v *AdUserGroupRow, err error) bool) {
	    query := "SELECT ID,VERSION,DN,UID,AD_GRP_ID,UPDATE_TIME FROM AD_USER_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AdUserGroupRow
	        err := rows.Scan(&r.ID, &r.Version, &r.Dn, &r.Uid, &r.AdGrpID, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AdUserGroupMappingRow struct represents rows of the AD_USER_GROUP_MAPPING table.
type AdUserGroupMappingRow struct {
    AdUserID	uint
    AdGroupID	uint
    UpdateTime	string
}

// IterateAdUserGroupMapping provide access to all rows of the AD_USER_GROUP_MAPPING matching given criteria.
func IterateAdUserGroupMapping(db *sql.DB, where string, callback func(v *AdUserGroupMappingRow) error) error {
    query := "SELECT AD_USER_ID,AD_GROUP_ID,UPDATE_TIME FROM AD_USER_GROUP_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AdUserGroupMappingRow
        err := rows.Scan(&r.AdUserID, &r.AdGroupID, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAdUserGroupMapping provide iterator to all rows of the AD_USER_GROUP_MAPPING matching given criteria.
func RangeAdUserGroupMapping(db *sql.DB, where string) iter.Seq2[*AdUserGroupMappingRow, error] {
	return func(yield func(v *AdUserGroupMappingRow, err error) bool) {
	    query := "SELECT AD_USER_ID,AD_GROUP_ID,UPDATE_TIME FROM AD_USER_GROUP_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AdUserGroupMappingRow
	        err := rows.Scan(&r.AdUserID, &r.AdGroupID, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AlertActionRow struct represents rows of the ALERT_ACTION table.
type AlertActionRow struct {
    ActionsetID	string
    SinkID	string
}

// IterateAlertAction provide access to all rows of the ALERT_ACTION matching given criteria.
func IterateAlertAction(db *sql.DB, where string, callback func(v *AlertActionRow) error) error {
    query := "SELECT ACTIONSET_ID,SINK_ID FROM ALERT_ACTION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AlertActionRow
        err := rows.Scan(&r.ActionsetID, &r.SinkID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAlertAction provide iterator to all rows of the ALERT_ACTION matching given criteria.
func RangeAlertAction(db *sql.DB, where string) iter.Seq2[*AlertActionRow, error] {
	return func(yield func(v *AlertActionRow, err error) bool) {
	    query := "SELECT ACTIONSET_ID,SINK_ID FROM ALERT_ACTION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AlertActionRow
	        err := rows.Scan(&r.ActionsetID, &r.SinkID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AlertChannelRow struct represents rows of the ALERT_CHANNEL table.
type AlertChannelRow struct {
    ChannelID	string
    Type	sql.NullString
    Period	sql.NullInt32
    Threshold	sql.NullInt32
    Coalesce	sql.NullInt32
    Email	sql.NullString
    Pager	sql.NullString
    Snmphost	sql.NullString
    Snmpport	sql.NullInt32
    Syslog	sql.NullString
    CommunityString	sql.NullString
}

// IterateAlertChannel provide access to all rows of the ALERT_CHANNEL matching given criteria.
func IterateAlertChannel(db *sql.DB, where string, callback func(v *AlertChannelRow) error) error {
    query := "SELECT CHANNEL_ID,TYPE,PERIOD,THRESHOLD,COALESCE,EMAIL,PAGER,SNMPHOST,SNMPPORT,SYSLOG,COMMUNITY_STRING FROM ALERT_CHANNEL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AlertChannelRow
        err := rows.Scan(&r.ChannelID, &r.Type, &r.Period, &r.Threshold, &r.Coalesce, &r.Email, &r.Pager, &r.Snmphost, &r.Snmpport, &r.Syslog, &r.CommunityString)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAlertChannel provide iterator to all rows of the ALERT_CHANNEL matching given criteria.
func RangeAlertChannel(db *sql.DB, where string) iter.Seq2[*AlertChannelRow, error] {
	return func(yield func(v *AlertChannelRow, err error) bool) {
	    query := "SELECT CHANNEL_ID,TYPE,PERIOD,THRESHOLD,COALESCE,EMAIL,PAGER,SNMPHOST,SNMPPORT,SYSLOG,COMMUNITY_STRING FROM ALERT_CHANNEL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AlertChannelRow
	        err := rows.Scan(&r.ChannelID, &r.Type, &r.Period, &r.Threshold, &r.Coalesce, &r.Email, &r.Pager, &r.Snmphost, &r.Snmpport, &r.Syslog, &r.CommunityString)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AlertSinkRow struct represents rows of the ALERT_SINK table.
type AlertSinkRow struct {
    SinkID	string
    SinkType	string
    Displayname	sql.NullString
    ChannelID	sql.NullString
    ObjectType	string
    UserDefined	string
    Deleted	string
    IterationID	string
    Version	sql.NullString
    PkgDir	string
    UpdateTime	int64
    NgfwVersion	sql.NullString
}

// IterateAlertSink provide access to all rows of the ALERT_SINK matching given criteria.
func IterateAlertSink(db *sql.DB, where string, callback func(v *AlertSinkRow) error) error {
    query := "SELECT SINK_ID,SINK_TYPE,DISPLAYNAME,CHANNEL_ID,OBJECT_TYPE,USER_DEFINED,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME,NGFW_VERSION FROM ALERT_SINK"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AlertSinkRow
        err := rows.Scan(&r.SinkID, &r.SinkType, &r.Displayname, &r.ChannelID, &r.ObjectType, &r.UserDefined, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime, &r.NgfwVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAlertSink provide iterator to all rows of the ALERT_SINK matching given criteria.
func RangeAlertSink(db *sql.DB, where string) iter.Seq2[*AlertSinkRow, error] {
	return func(yield func(v *AlertSinkRow, err error) bool) {
	    query := "SELECT SINK_ID,SINK_TYPE,DISPLAYNAME,CHANNEL_ID,OBJECT_TYPE,USER_DEFINED,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME,NGFW_VERSION FROM ALERT_SINK"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AlertSinkRow
	        err := rows.Scan(&r.SinkID, &r.SinkType, &r.Displayname, &r.ChannelID, &r.ObjectType, &r.UserDefined, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime, &r.NgfwVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ArchiveConfigRow struct represents rows of the ARCHIVE_CONFIG table.
type ArchiveConfigRow struct {
    ID	uint
    DoDelete	sql.NullByte
    DoNotify	sql.NullByte
    DoEncrypt	sql.NullByte
    EncryptPassword	sql.NullString
    UpdateTime	string
    ArchiveSpan	sql.NullByte
    SpanDateStart	sql.NullTime
    SpanDateEnd	sql.NullTime
    SpanMonthStart	sql.NullByte
    SpanMonthEnd	sql.NullByte
    LocID	sql.NullInt32
    ScheduleID	sql.NullInt32
}

// IterateArchiveConfig provide access to all rows of the ARCHIVE_CONFIG matching given criteria.
func IterateArchiveConfig(db *sql.DB, where string, callback func(v *ArchiveConfigRow) error) error {
    query := "SELECT ID,DO_DELETE,DO_NOTIFY,DO_ENCRYPT,ENCRYPT_PASSWORD,UPDATE_TIME,ARCHIVE_SPAN,SPAN_DATE_START,SPAN_DATE_END,SPAN_MONTH_START,SPAN_MONTH_END,LOC_ID,SCHEDULE_ID FROM ARCHIVE_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ArchiveConfigRow
        err := rows.Scan(&r.ID, &r.DoDelete, &r.DoNotify, &r.DoEncrypt, &r.EncryptPassword, &r.UpdateTime, &r.ArchiveSpan, &r.SpanDateStart, &r.SpanDateEnd, &r.SpanMonthStart, &r.SpanMonthEnd, &r.LocID, &r.ScheduleID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeArchiveConfig provide iterator to all rows of the ARCHIVE_CONFIG matching given criteria.
func RangeArchiveConfig(db *sql.DB, where string) iter.Seq2[*ArchiveConfigRow, error] {
	return func(yield func(v *ArchiveConfigRow, err error) bool) {
	    query := "SELECT ID,DO_DELETE,DO_NOTIFY,DO_ENCRYPT,ENCRYPT_PASSWORD,UPDATE_TIME,ARCHIVE_SPAN,SPAN_DATE_START,SPAN_DATE_END,SPAN_MONTH_START,SPAN_MONTH_END,LOC_ID,SCHEDULE_ID FROM ARCHIVE_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ArchiveConfigRow
	        err := rows.Scan(&r.ID, &r.DoDelete, &r.DoNotify, &r.DoEncrypt, &r.EncryptPassword, &r.UpdateTime, &r.ArchiveSpan, &r.SpanDateStart, &r.SpanDateEnd, &r.SpanMonthStart, &r.SpanMonthEnd, &r.LocID, &r.ScheduleID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AtpConfigurationRow struct represents rows of the ATP_CONFIGURATION table.
type AtpConfigurationRow struct {
    SmsClientUuid	string
    AtpIPAddress	string
    AtpApiKey	string
    NamedCertificateID	int
    SavedQueryID	uint
    Enabled	int8
    HighRiskAnalysis	int8
}

// IterateAtpConfiguration provide access to all rows of the ATP_CONFIGURATION matching given criteria.
func IterateAtpConfiguration(db *sql.DB, where string, callback func(v *AtpConfigurationRow) error) error {
    query := "SELECT SMS_CLIENT_UUID,ATP_IP_ADDRESS,ATP_API_KEY,NAMED_CERTIFICATE_ID,SAVED_QUERY_ID,ENABLED,HIGH_RISK_ANALYSIS FROM ATP_CONFIGURATION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AtpConfigurationRow
        err := rows.Scan(&r.SmsClientUuid, &r.AtpIPAddress, &r.AtpApiKey, &r.NamedCertificateID, &r.SavedQueryID, &r.Enabled, &r.HighRiskAnalysis)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAtpConfiguration provide iterator to all rows of the ATP_CONFIGURATION matching given criteria.
func RangeAtpConfiguration(db *sql.DB, where string) iter.Seq2[*AtpConfigurationRow, error] {
	return func(yield func(v *AtpConfigurationRow, err error) bool) {
	    query := "SELECT SMS_CLIENT_UUID,ATP_IP_ADDRESS,ATP_API_KEY,NAMED_CERTIFICATE_ID,SAVED_QUERY_ID,ENABLED,HIGH_RISK_ANALYSIS FROM ATP_CONFIGURATION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AtpConfigurationRow
	        err := rows.Scan(&r.SmsClientUuid, &r.AtpIPAddress, &r.AtpApiKey, &r.NamedCertificateID, &r.SavedQueryID, &r.Enabled, &r.HighRiskAnalysis)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AttackApplySettingsRow struct represents rows of the ATTACK_APPLY_SETTINGS table.
type AttackApplySettingsRow struct {
    ProfileID	string
    ID	string
    AddrPairsGroupID	sql.NullString
    Deleted	string
    IterationID	string
    Version	string
    PkgDir	string
    UpdateTime	int64
}

// IterateAttackApplySettings provide access to all rows of the ATTACK_APPLY_SETTINGS matching given criteria.
func IterateAttackApplySettings(db *sql.DB, where string, callback func(v *AttackApplySettingsRow) error) error {
    query := "SELECT PROFILE_ID,ID,ADDR_PAIRS_GROUP_ID,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME FROM ATTACK_APPLY_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AttackApplySettingsRow
        err := rows.Scan(&r.ProfileID, &r.ID, &r.AddrPairsGroupID, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAttackApplySettings provide iterator to all rows of the ATTACK_APPLY_SETTINGS matching given criteria.
func RangeAttackApplySettings(db *sql.DB, where string) iter.Seq2[*AttackApplySettingsRow, error] {
	return func(yield func(v *AttackApplySettingsRow, err error) bool) {
	    query := "SELECT PROFILE_ID,ID,ADDR_PAIRS_GROUP_ID,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME FROM ATTACK_APPLY_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AttackApplySettingsRow
	        err := rows.Scan(&r.ProfileID, &r.ID, &r.AddrPairsGroupID, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AttackExceptionSettingsRow struct represents rows of the ATTACK_EXCEPTION_SETTINGS table.
type AttackExceptionSettingsRow struct {
    ProfileID	string
    ID	string
    AddrPairsGroupID	sql.NullString
    Deleted	string
    IterationID	string
    Version	string
    PkgDir	string
    UpdateTime	int64
}

// IterateAttackExceptionSettings provide access to all rows of the ATTACK_EXCEPTION_SETTINGS matching given criteria.
func IterateAttackExceptionSettings(db *sql.DB, where string, callback func(v *AttackExceptionSettingsRow) error) error {
    query := "SELECT PROFILE_ID,ID,ADDR_PAIRS_GROUP_ID,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME FROM ATTACK_EXCEPTION_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AttackExceptionSettingsRow
        err := rows.Scan(&r.ProfileID, &r.ID, &r.AddrPairsGroupID, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAttackExceptionSettings provide iterator to all rows of the ATTACK_EXCEPTION_SETTINGS matching given criteria.
func RangeAttackExceptionSettings(db *sql.DB, where string) iter.Seq2[*AttackExceptionSettingsRow, error] {
	return func(yield func(v *AttackExceptionSettingsRow, err error) bool) {
	    query := "SELECT PROFILE_ID,ID,ADDR_PAIRS_GROUP_ID,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME FROM ATTACK_EXCEPTION_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AttackExceptionSettingsRow
	        err := rows.Scan(&r.ProfileID, &r.ID, &r.AddrPairsGroupID, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AuditRecordRow struct represents rows of the AUDIT_RECORD table.
type AuditRecordRow struct {
    Username	string
    ClientIPAddress	sql.NullString
    ClientPort	sql.NullInt32
    SessionID	int
    OpTimeMillis	int64
    OpStatus	sql.NullString
    OpDescription	sql.NullString
    Idx	uint64
}

// IterateAuditRecord provide access to all rows of the AUDIT_RECORD matching given criteria.
func IterateAuditRecord(db *sql.DB, where string, callback func(v *AuditRecordRow) error) error {
    query := "SELECT USERNAME,CLIENT_IP_ADDRESS,CLIENT_PORT,SESSION_ID,OP_TIME_MILLIS,OP_STATUS,OP_DESCRIPTION,IDX FROM AUDIT_RECORD"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AuditRecordRow
        err := rows.Scan(&r.Username, &r.ClientIPAddress, &r.ClientPort, &r.SessionID, &r.OpTimeMillis, &r.OpStatus, &r.OpDescription, &r.Idx)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAuditRecord provide iterator to all rows of the AUDIT_RECORD matching given criteria.
func RangeAuditRecord(db *sql.DB, where string) iter.Seq2[*AuditRecordRow, error] {
	return func(yield func(v *AuditRecordRow, err error) bool) {
	    query := "SELECT USERNAME,CLIENT_IP_ADDRESS,CLIENT_PORT,SESSION_ID,OP_TIME_MILLIS,OP_STATUS,OP_DESCRIPTION,IDX FROM AUDIT_RECORD"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AuditRecordRow
	        err := rows.Scan(&r.Username, &r.ClientIPAddress, &r.ClientPort, &r.SessionID, &r.OpTimeMillis, &r.OpStatus, &r.OpDescription, &r.Idx)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AuthUserRow struct represents rows of the AUTH_USER table.
type AuthUserRow struct {
    Userid	int
    Username	string
    Password	sql.NullString
    Enabled	sql.NullByte
    System	sql.NullByte
    LocalOnly	sql.NullByte
    Name	sql.NullString
    Email	sql.NullString
    Phone1	sql.NullString
    Phone2	sql.NullString
    Created	string
    LastChange	string
    LastPwdUpdate	string
    MaxPwdAgeDays	sql.NullInt32
    PwdExpireEnbl	sql.NullByte
    ForcePwdUpdate	sql.NullByte
    DefaultGroupID	sql.NullInt32
    EncryptApiKey	sql.NullString
}

// IterateAuthUser provide access to all rows of the AUTH_USER matching given criteria.
func IterateAuthUser(db *sql.DB, where string, callback func(v *AuthUserRow) error) error {
    query := "SELECT USERID,USERNAME,PASSWORD,ENABLED,SYSTEM,LOCAL_ONLY,NAME,EMAIL,PHONE1,PHONE2,CREATED,LAST_CHANGE,LAST_PWD_UPDATE,MAX_PWD_AGE_DAYS,PWD_EXPIRE_ENBL,FORCE_PWD_UPDATE,DEFAULT_GROUP_ID,ENCRYPT_API_KEY FROM AUTH_USER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AuthUserRow
        err := rows.Scan(&r.Userid, &r.Username, &r.Password, &r.Enabled, &r.System, &r.LocalOnly, &r.Name, &r.Email, &r.Phone1, &r.Phone2, &r.Created, &r.LastChange, &r.LastPwdUpdate, &r.MaxPwdAgeDays, &r.PwdExpireEnbl, &r.ForcePwdUpdate, &r.DefaultGroupID, &r.EncryptApiKey)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAuthUser provide iterator to all rows of the AUTH_USER matching given criteria.
func RangeAuthUser(db *sql.DB, where string) iter.Seq2[*AuthUserRow, error] {
	return func(yield func(v *AuthUserRow, err error) bool) {
	    query := "SELECT USERID,USERNAME,PASSWORD,ENABLED,SYSTEM,LOCAL_ONLY,NAME,EMAIL,PHONE1,PHONE2,CREATED,LAST_CHANGE,LAST_PWD_UPDATE,MAX_PWD_AGE_DAYS,PWD_EXPIRE_ENBL,FORCE_PWD_UPDATE,DEFAULT_GROUP_ID,ENCRYPT_API_KEY FROM AUTH_USER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AuthUserRow
	        err := rows.Scan(&r.Userid, &r.Username, &r.Password, &r.Enabled, &r.System, &r.LocalOnly, &r.Name, &r.Email, &r.Phone1, &r.Phone2, &r.Created, &r.LastChange, &r.LastPwdUpdate, &r.MaxPwdAgeDays, &r.PwdExpireEnbl, &r.ForcePwdUpdate, &r.DefaultGroupID, &r.EncryptApiKey)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// AuthUserUserGroupsRow struct represents rows of the AUTH_USER_USER_GROUPS table.
type AuthUserUserGroupsRow struct {
    UserGroupIDFk	uint
    AuthUserIDFk	int
}

// IterateAuthUserUserGroups provide access to all rows of the AUTH_USER_USER_GROUPS matching given criteria.
func IterateAuthUserUserGroups(db *sql.DB, where string, callback func(v *AuthUserUserGroupsRow) error) error {
    query := "SELECT USER_GROUP_ID_FK,AUTH_USER_ID_FK FROM AUTH_USER_USER_GROUPS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r AuthUserUserGroupsRow
        err := rows.Scan(&r.UserGroupIDFk, &r.AuthUserIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeAuthUserUserGroups provide iterator to all rows of the AUTH_USER_USER_GROUPS matching given criteria.
func RangeAuthUserUserGroups(db *sql.DB, where string) iter.Seq2[*AuthUserUserGroupsRow, error] {
	return func(yield func(v *AuthUserUserGroupsRow, err error) bool) {
	    query := "SELECT USER_GROUP_ID_FK,AUTH_USER_ID_FK FROM AUTH_USER_USER_GROUPS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r AuthUserUserGroupsRow
	        err := rows.Scan(&r.UserGroupIDFk, &r.AuthUserIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// BackupScheduleRow struct represents rows of the BACKUP_SCHEDULE table.
type BackupScheduleRow struct {
    Name	string
    LastBackupTime	int64
    Value	[]byte
}

// IterateBackupSchedule provide access to all rows of the BACKUP_SCHEDULE matching given criteria.
func IterateBackupSchedule(db *sql.DB, where string, callback func(v *BackupScheduleRow) error) error {
    query := "SELECT NAME,LAST_BACKUP_TIME,VALUE FROM BACKUP_SCHEDULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r BackupScheduleRow
        err := rows.Scan(&r.Name, &r.LastBackupTime, &r.Value)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeBackupSchedule provide iterator to all rows of the BACKUP_SCHEDULE matching given criteria.
func RangeBackupSchedule(db *sql.DB, where string) iter.Seq2[*BackupScheduleRow, error] {
	return func(yield func(v *BackupScheduleRow, err error) bool) {
	    query := "SELECT NAME,LAST_BACKUP_TIME,VALUE FROM BACKUP_SCHEDULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r BackupScheduleRow
	        err := rows.Scan(&r.Name, &r.LastBackupTime, &r.Value)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// BasicScheduleRow struct represents rows of the BASIC_SCHEDULE table.
type BasicScheduleRow struct {
    ID	uint
    CompositeScheduleID	sql.NullInt32
    Name	sql.NullString
    RecurrenceType	sql.NullInt32
    Include	sql.NullByte
    StartTime	sql.NullInt32
    Duration	sql.NullInt32
    StartTimeUnit	sql.NullInt32
    DurationTimeUnit	sql.NullInt32
    RecurEvery	sql.NullInt32
    NoEndDate	sql.NullByte
    StartDate	string
    EndDate	string
    NumOccurrences	sql.NullInt32
    Active	sql.NullByte
    RecurrenceTimeUnit	sql.NullInt32
    DayType	sql.NullInt32
    DaysOfWeek	sql.NullString
    MonthType	sql.NullInt32
    DayOfMonth	sql.NullInt32
    DayInMonth	sql.NullInt32
    DayOfWeek	sql.NullInt32
    Month	sql.NullInt32
}

// IterateBasicSchedule provide access to all rows of the BASIC_SCHEDULE matching given criteria.
func IterateBasicSchedule(db *sql.DB, where string, callback func(v *BasicScheduleRow) error) error {
    query := "SELECT ID,COMPOSITE_SCHEDULE_ID,NAME,RECURRENCE_TYPE,INCLUDE,START_TIME,DURATION,START_TIME_UNIT,DURATION_TIME_UNIT,RECUR_EVERY,NO_END_DATE,START_DATE,END_DATE,NUM_OCCURRENCES,ACTIVE,RECURRENCE_TIME_UNIT,DAY_TYPE,DAYS_OF_WEEK,MONTH_TYPE,DAY_OF_MONTH,DAY_IN_MONTH,DAY_OF_WEEK,MONTH FROM BASIC_SCHEDULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r BasicScheduleRow
        err := rows.Scan(&r.ID, &r.CompositeScheduleID, &r.Name, &r.RecurrenceType, &r.Include, &r.StartTime, &r.Duration, &r.StartTimeUnit, &r.DurationTimeUnit, &r.RecurEvery, &r.NoEndDate, &r.StartDate, &r.EndDate, &r.NumOccurrences, &r.Active, &r.RecurrenceTimeUnit, &r.DayType, &r.DaysOfWeek, &r.MonthType, &r.DayOfMonth, &r.DayInMonth, &r.DayOfWeek, &r.Month)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeBasicSchedule provide iterator to all rows of the BASIC_SCHEDULE matching given criteria.
func RangeBasicSchedule(db *sql.DB, where string) iter.Seq2[*BasicScheduleRow, error] {
	return func(yield func(v *BasicScheduleRow, err error) bool) {
	    query := "SELECT ID,COMPOSITE_SCHEDULE_ID,NAME,RECURRENCE_TYPE,INCLUDE,START_TIME,DURATION,START_TIME_UNIT,DURATION_TIME_UNIT,RECUR_EVERY,NO_END_DATE,START_DATE,END_DATE,NUM_OCCURRENCES,ACTIVE,RECURRENCE_TIME_UNIT,DAY_TYPE,DAYS_OF_WEEK,MONTH_TYPE,DAY_OF_MONTH,DAY_IN_MONTH,DAY_OF_WEEK,MONTH FROM BASIC_SCHEDULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r BasicScheduleRow
	        err := rows.Scan(&r.ID, &r.CompositeScheduleID, &r.Name, &r.RecurrenceType, &r.Include, &r.StartTime, &r.Duration, &r.StartTimeUnit, &r.DurationTimeUnit, &r.RecurEvery, &r.NoEndDate, &r.StartDate, &r.EndDate, &r.NumOccurrences, &r.Active, &r.RecurrenceTimeUnit, &r.DayType, &r.DaysOfWeek, &r.MonthType, &r.DayOfMonth, &r.DayInMonth, &r.DayOfWeek, &r.Month)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CacLdapServerConfigRow struct represents rows of the CAC_LDAP_SERVER_CONFIG table.
type CacLdapServerConfigRow struct {
    ID	uint
    GroupSearchBase	sql.NullString
    UserSearchAttribute	sql.NullString
    GroupNameAttribute	sql.NullString
    UsernameDisplayAttribute	sql.NullString
}

// IterateCacLdapServerConfig provide access to all rows of the CAC_LDAP_SERVER_CONFIG matching given criteria.
func IterateCacLdapServerConfig(db *sql.DB, where string, callback func(v *CacLdapServerConfigRow) error) error {
    query := "SELECT ID,GROUP_SEARCH_BASE,USER_SEARCH_ATTRIBUTE,GROUP_NAME_ATTRIBUTE,USERNAME_DISPLAY_ATTRIBUTE FROM CAC_LDAP_SERVER_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CacLdapServerConfigRow
        err := rows.Scan(&r.ID, &r.GroupSearchBase, &r.UserSearchAttribute, &r.GroupNameAttribute, &r.UsernameDisplayAttribute)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCacLdapServerConfig provide iterator to all rows of the CAC_LDAP_SERVER_CONFIG matching given criteria.
func RangeCacLdapServerConfig(db *sql.DB, where string) iter.Seq2[*CacLdapServerConfigRow, error] {
	return func(yield func(v *CacLdapServerConfigRow, err error) bool) {
	    query := "SELECT ID,GROUP_SEARCH_BASE,USER_SEARCH_ATTRIBUTE,GROUP_NAME_ATTRIBUTE,USERNAME_DISPLAY_ATTRIBUTE FROM CAC_LDAP_SERVER_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CacLdapServerConfigRow
	        err := rows.Scan(&r.ID, &r.GroupSearchBase, &r.UserSearchAttribute, &r.GroupNameAttribute, &r.UsernameDisplayAttribute)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CategoryRow struct represents rows of the CATEGORY table.
type CategoryRow struct {
    ID	string
    Name	string
    Editable	sql.NullByte
    CategoryType	sql.NullString
    Version	sql.NullString
    Iteration	string
    Type	sql.NullString
    Description	sql.NullString
    DefaultActionsetID	sql.NullString
    DefaultState	sql.NullByte
    Modified	sql.NullByte
    LegacyNumber	sql.NullInt32
    ParentID	int
    Xpath	sql.NullString
    XpathEditable	sql.NullByte
    ProtectionType	sql.NullString
    AnonymousCategory	sql.NullByte
    CriteriaXml	sql.NullString
    NgfwVersion	sql.NullString
    CriteriaType	sql.NullString
}

// IterateCategory provide access to all rows of the CATEGORY matching given criteria.
func IterateCategory(db *sql.DB, where string, callback func(v *CategoryRow) error) error {
    query := "SELECT ID,NAME,EDITABLE,CATEGORY_TYPE,VERSION,ITERATION,TYPE,DESCRIPTION,DEFAULT_ACTIONSET_ID,DEFAULT_STATE,MODIFIED,LEGACY_NUMBER,PARENT_ID,XPATH,XPATH_EDITABLE,PROTECTION_TYPE,ANONYMOUS_CATEGORY,CRITERIA_XML,NGFW_VERSION,CRITERIA_TYPE FROM CATEGORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CategoryRow
        err := rows.Scan(&r.ID, &r.Name, &r.Editable, &r.CategoryType, &r.Version, &r.Iteration, &r.Type, &r.Description, &r.DefaultActionsetID, &r.DefaultState, &r.Modified, &r.LegacyNumber, &r.ParentID, &r.Xpath, &r.XpathEditable, &r.ProtectionType, &r.AnonymousCategory, &r.CriteriaXml, &r.NgfwVersion, &r.CriteriaType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCategory provide iterator to all rows of the CATEGORY matching given criteria.
func RangeCategory(db *sql.DB, where string) iter.Seq2[*CategoryRow, error] {
	return func(yield func(v *CategoryRow, err error) bool) {
	    query := "SELECT ID,NAME,EDITABLE,CATEGORY_TYPE,VERSION,ITERATION,TYPE,DESCRIPTION,DEFAULT_ACTIONSET_ID,DEFAULT_STATE,MODIFIED,LEGACY_NUMBER,PARENT_ID,XPATH,XPATH_EDITABLE,PROTECTION_TYPE,ANONYMOUS_CATEGORY,CRITERIA_XML,NGFW_VERSION,CRITERIA_TYPE FROM CATEGORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CategoryRow
	        err := rows.Scan(&r.ID, &r.Name, &r.Editable, &r.CategoryType, &r.Version, &r.Iteration, &r.Type, &r.Description, &r.DefaultActionsetID, &r.DefaultState, &r.Modified, &r.LegacyNumber, &r.ParentID, &r.Xpath, &r.XpathEditable, &r.ProtectionType, &r.AnonymousCategory, &r.CriteriaXml, &r.NgfwVersion, &r.CriteriaType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CategoryGroupRow struct represents rows of the CATEGORY_GROUP table.
type CategoryGroupRow struct {
    ID	uint
    Name	sql.NullString
}

// IterateCategoryGroup provide access to all rows of the CATEGORY_GROUP matching given criteria.
func IterateCategoryGroup(db *sql.DB, where string, callback func(v *CategoryGroupRow) error) error {
    query := "SELECT ID,NAME FROM CATEGORY_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CategoryGroupRow
        err := rows.Scan(&r.ID, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCategoryGroup provide iterator to all rows of the CATEGORY_GROUP matching given criteria.
func RangeCategoryGroup(db *sql.DB, where string) iter.Seq2[*CategoryGroupRow, error] {
	return func(yield func(v *CategoryGroupRow, err error) bool) {
	    query := "SELECT ID,NAME FROM CATEGORY_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CategoryGroupRow
	        err := rows.Scan(&r.ID, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CaCrlUpdateUrlRow struct represents rows of the CA_CRL_UPDATE_URL table.
type CaCrlUpdateUrlRow struct {
    ID	uint
    X509CertificateID	sql.NullInt32
    UpdateUrl	sql.NullString
    CrlPeriod	sql.NullInt32
}

// IterateCaCrlUpdateUrl provide access to all rows of the CA_CRL_UPDATE_URL matching given criteria.
func IterateCaCrlUpdateUrl(db *sql.DB, where string, callback func(v *CaCrlUpdateUrlRow) error) error {
    query := "SELECT ID,X509_CERTIFICATE_ID,UPDATE_URL,CRL_PERIOD FROM CA_CRL_UPDATE_URL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CaCrlUpdateUrlRow
        err := rows.Scan(&r.ID, &r.X509CertificateID, &r.UpdateUrl, &r.CrlPeriod)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCaCrlUpdateUrl provide iterator to all rows of the CA_CRL_UPDATE_URL matching given criteria.
func RangeCaCrlUpdateUrl(db *sql.DB, where string) iter.Seq2[*CaCrlUpdateUrlRow, error] {
	return func(yield func(v *CaCrlUpdateUrlRow, err error) bool) {
	    query := "SELECT ID,X509_CERTIFICATE_ID,UPDATE_URL,CRL_PERIOD FROM CA_CRL_UPDATE_URL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CaCrlUpdateUrlRow
	        err := rows.Scan(&r.ID, &r.X509CertificateID, &r.UpdateUrl, &r.CrlPeriod)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CcExceptionRuleRow struct represents rows of the CC_EXCEPTION_RULE table.
type CcExceptionRuleRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    RuleName	sql.NullString
    RuleID	sql.NullInt32
    RuleEnabled	sql.NullByte
    MphyRuleType	sql.NullInt16
    MphyPortMask	sql.NullInt32
    EthRuleType	sql.NullInt16
    EthValue	sql.NullInt32
    VLANRuleType	sql.NullInt16
    MplsRuleType	sql.NullInt16
    MplsValue	sql.NullInt32
    MplsRangeMin	sql.NullInt32
    MplsRangeMax	sql.NullInt32
    IPProtoRuleType	sql.NullInt16
    IPProtoValue	sql.NullInt32
    IPSrcRuleType	sql.NullInt16
    IPDstRuleType	sql.NullInt16
    UdpSrcPortRuleType	sql.NullInt16
    UdpSrcPortValue	sql.NullInt32
    UdpSrcPortRangeMin	sql.NullInt32
    UdpSrcPortRangeMax	sql.NullInt32
    UdpDstPortRuleType	sql.NullInt16
    UdpDstPortValue	sql.NullInt32
    UdpDstPortRangeMin	sql.NullInt32
    UdpDstPortRangeMax	sql.NullInt32
    TcpSrcPortRuleType	sql.NullInt16
    TcpSrcPortValue	sql.NullInt32
    TcpSrcPortRangeMin	sql.NullInt32
    TcpSrcPortRangeMax	sql.NullInt32
    TcpDstPortRuleType	sql.NullInt16
    TcpDstPortValue	sql.NullInt32
    TcpDstPortRangeMin	sql.NullInt32
    TcpDstPortRangeMax	sql.NullInt32
    IPSrcNamedObjID	sql.NullInt32
    IPDstNamedObjID	sql.NullInt32
    VLANNamedObjID	sql.NullInt32
}

// IterateCcExceptionRule provide access to all rows of the CC_EXCEPTION_RULE matching given criteria.
func IterateCcExceptionRule(db *sql.DB, where string, callback func(v *CcExceptionRuleRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,RULE_NAME,RULE_ID,RULE_ENABLED,MPHY_RULE_TYPE,MPHY_PORT_MASK,ETH_RULE_TYPE,ETH_VALUE,VLAN_RULE_TYPE,MPLS_RULE_TYPE,MPLS_VALUE,MPLS_RANGE_MIN,MPLS_RANGE_MAX,IP_PROTO_RULE_TYPE,IP_PROTO_VALUE,IP_SRC_RULE_TYPE,IP_DST_RULE_TYPE,UDP_SRC_PORT_RULE_TYPE,UDP_SRC_PORT_VALUE,UDP_SRC_PORT_RANGE_MIN,UDP_SRC_PORT_RANGE_MAX,UDP_DST_PORT_RULE_TYPE,UDP_DST_PORT_VALUE,UDP_DST_PORT_RANGE_MIN,UDP_DST_PORT_RANGE_MAX,TCP_SRC_PORT_RULE_TYPE,TCP_SRC_PORT_VALUE,TCP_SRC_PORT_RANGE_MIN,TCP_SRC_PORT_RANGE_MAX,TCP_DST_PORT_RULE_TYPE,TCP_DST_PORT_VALUE,TCP_DST_PORT_RANGE_MIN,TCP_DST_PORT_RANGE_MAX,IP_SRC_NAMED_OBJ_ID,IP_DST_NAMED_OBJ_ID,VLAN_NAMED_OBJ_ID FROM CC_EXCEPTION_RULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CcExceptionRuleRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.RuleName, &r.RuleID, &r.RuleEnabled, &r.MphyRuleType, &r.MphyPortMask, &r.EthRuleType, &r.EthValue, &r.VLANRuleType, &r.MplsRuleType, &r.MplsValue, &r.MplsRangeMin, &r.MplsRangeMax, &r.IPProtoRuleType, &r.IPProtoValue, &r.IPSrcRuleType, &r.IPDstRuleType, &r.UdpSrcPortRuleType, &r.UdpSrcPortValue, &r.UdpSrcPortRangeMin, &r.UdpSrcPortRangeMax, &r.UdpDstPortRuleType, &r.UdpDstPortValue, &r.UdpDstPortRangeMin, &r.UdpDstPortRangeMax, &r.TcpSrcPortRuleType, &r.TcpSrcPortValue, &r.TcpSrcPortRangeMin, &r.TcpSrcPortRangeMax, &r.TcpDstPortRuleType, &r.TcpDstPortValue, &r.TcpDstPortRangeMin, &r.TcpDstPortRangeMax, &r.IPSrcNamedObjID, &r.IPDstNamedObjID, &r.VLANNamedObjID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCcExceptionRule provide iterator to all rows of the CC_EXCEPTION_RULE matching given criteria.
func RangeCcExceptionRule(db *sql.DB, where string) iter.Seq2[*CcExceptionRuleRow, error] {
	return func(yield func(v *CcExceptionRuleRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,RULE_NAME,RULE_ID,RULE_ENABLED,MPHY_RULE_TYPE,MPHY_PORT_MASK,ETH_RULE_TYPE,ETH_VALUE,VLAN_RULE_TYPE,MPLS_RULE_TYPE,MPLS_VALUE,MPLS_RANGE_MIN,MPLS_RANGE_MAX,IP_PROTO_RULE_TYPE,IP_PROTO_VALUE,IP_SRC_RULE_TYPE,IP_DST_RULE_TYPE,UDP_SRC_PORT_RULE_TYPE,UDP_SRC_PORT_VALUE,UDP_SRC_PORT_RANGE_MIN,UDP_SRC_PORT_RANGE_MAX,UDP_DST_PORT_RULE_TYPE,UDP_DST_PORT_VALUE,UDP_DST_PORT_RANGE_MIN,UDP_DST_PORT_RANGE_MAX,TCP_SRC_PORT_RULE_TYPE,TCP_SRC_PORT_VALUE,TCP_SRC_PORT_RANGE_MIN,TCP_SRC_PORT_RANGE_MAX,TCP_DST_PORT_RULE_TYPE,TCP_DST_PORT_VALUE,TCP_DST_PORT_RANGE_MIN,TCP_DST_PORT_RANGE_MAX,IP_SRC_NAMED_OBJ_ID,IP_DST_NAMED_OBJ_ID,VLAN_NAMED_OBJ_ID FROM CC_EXCEPTION_RULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CcExceptionRuleRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.RuleName, &r.RuleID, &r.RuleEnabled, &r.MphyRuleType, &r.MphyPortMask, &r.EthRuleType, &r.EthValue, &r.VLANRuleType, &r.MplsRuleType, &r.MplsValue, &r.MplsRangeMin, &r.MplsRangeMax, &r.IPProtoRuleType, &r.IPProtoValue, &r.IPSrcRuleType, &r.IPDstRuleType, &r.UdpSrcPortRuleType, &r.UdpSrcPortValue, &r.UdpSrcPortRangeMin, &r.UdpSrcPortRangeMax, &r.UdpDstPortRuleType, &r.UdpDstPortValue, &r.UdpDstPortRangeMin, &r.UdpDstPortRangeMax, &r.TcpSrcPortRuleType, &r.TcpSrcPortValue, &r.TcpSrcPortRangeMin, &r.TcpSrcPortRangeMax, &r.TcpDstPortRuleType, &r.TcpDstPortValue, &r.TcpDstPortRangeMin, &r.TcpDstPortRangeMax, &r.IPSrcNamedObjID, &r.IPDstNamedObjID, &r.VLANNamedObjID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CcExceptionRuleGlobalsRow struct represents rows of the CC_EXCEPTION_RULE_GLOBALS table.
type CcExceptionRuleGlobalsRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    Maxsize	sql.NullInt32
    Action	sql.NullInt16
}

// IterateCcExceptionRuleGlobals provide access to all rows of the CC_EXCEPTION_RULE_GLOBALS matching given criteria.
func IterateCcExceptionRuleGlobals(db *sql.DB, where string, callback func(v *CcExceptionRuleGlobalsRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,MAXSIZE,ACTION FROM CC_EXCEPTION_RULE_GLOBALS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CcExceptionRuleGlobalsRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Maxsize, &r.Action)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCcExceptionRuleGlobals provide iterator to all rows of the CC_EXCEPTION_RULE_GLOBALS matching given criteria.
func RangeCcExceptionRuleGlobals(db *sql.DB, where string) iter.Seq2[*CcExceptionRuleGlobalsRow, error] {
	return func(yield func(v *CcExceptionRuleGlobalsRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,MAXSIZE,ACTION FROM CC_EXCEPTION_RULE_GLOBALS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CcExceptionRuleGlobalsRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Maxsize, &r.Action)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CcFlowMgmtRuleRow struct represents rows of the CC_FLOW_MGMT_RULE table.
type CcFlowMgmtRuleRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    Name	sql.NullString
    Enabled	sql.NullByte
    Priority	sql.NullByte
    EthType	sql.NullByte
    EthValue	sql.NullInt32
    FailAction	sql.NullByte
    IPProtocol	sql.NullInt16
    Algorithm	sql.NullByte
}

// IterateCcFlowMgmtRule provide access to all rows of the CC_FLOW_MGMT_RULE matching given criteria.
func IterateCcFlowMgmtRule(db *sql.DB, where string, callback func(v *CcFlowMgmtRuleRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,NAME,ENABLED,PRIORITY,ETH_TYPE,ETH_VALUE,FAIL_ACTION,IP_PROTOCOL,ALGORITHM FROM CC_FLOW_MGMT_RULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CcFlowMgmtRuleRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Name, &r.Enabled, &r.Priority, &r.EthType, &r.EthValue, &r.FailAction, &r.IPProtocol, &r.Algorithm)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCcFlowMgmtRule provide iterator to all rows of the CC_FLOW_MGMT_RULE matching given criteria.
func RangeCcFlowMgmtRule(db *sql.DB, where string) iter.Seq2[*CcFlowMgmtRuleRow, error] {
	return func(yield func(v *CcFlowMgmtRuleRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,NAME,ENABLED,PRIORITY,ETH_TYPE,ETH_VALUE,FAIL_ACTION,IP_PROTOCOL,ALGORITHM FROM CC_FLOW_MGMT_RULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CcFlowMgmtRuleRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Name, &r.Enabled, &r.Priority, &r.EthType, &r.EthValue, &r.FailAction, &r.IPProtocol, &r.Algorithm)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CcFlowMgmtRuleTargetRow struct represents rows of the CC_FLOW_MGMT_RULE_TARGET table.
type CcFlowMgmtRuleTargetRow struct {
    ID	uint
    RuleID	sql.NullInt32
    TargetType	sql.NullByte
    TargetID	sql.NullInt32
}

// IterateCcFlowMgmtRuleTarget provide access to all rows of the CC_FLOW_MGMT_RULE_TARGET matching given criteria.
func IterateCcFlowMgmtRuleTarget(db *sql.DB, where string, callback func(v *CcFlowMgmtRuleTargetRow) error) error {
    query := "SELECT ID,RULE_ID,TARGET_TYPE,TARGET_ID FROM CC_FLOW_MGMT_RULE_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CcFlowMgmtRuleTargetRow
        err := rows.Scan(&r.ID, &r.RuleID, &r.TargetType, &r.TargetID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCcFlowMgmtRuleTarget provide iterator to all rows of the CC_FLOW_MGMT_RULE_TARGET matching given criteria.
func RangeCcFlowMgmtRuleTarget(db *sql.DB, where string) iter.Seq2[*CcFlowMgmtRuleTargetRow, error] {
	return func(yield func(v *CcFlowMgmtRuleTargetRow, err error) bool) {
	    query := "SELECT ID,RULE_ID,TARGET_TYPE,TARGET_ID FROM CC_FLOW_MGMT_RULE_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CcFlowMgmtRuleTargetRow
	        err := rows.Scan(&r.ID, &r.RuleID, &r.TargetType, &r.TargetID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CcHashAlgorithmRow struct represents rows of the CC_HASH_ALGORITHM table.
type CcHashAlgorithmRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    AlgorithmNumber	sql.NullInt32
    Description	sql.NullString
}

// IterateCcHashAlgorithm provide access to all rows of the CC_HASH_ALGORITHM matching given criteria.
func IterateCcHashAlgorithm(db *sql.DB, where string, callback func(v *CcHashAlgorithmRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,ALGORITHM_NUMBER,DESCRIPTION FROM CC_HASH_ALGORITHM"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CcHashAlgorithmRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.AlgorithmNumber, &r.Description)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCcHashAlgorithm provide iterator to all rows of the CC_HASH_ALGORITHM matching given criteria.
func RangeCcHashAlgorithm(db *sql.DB, where string) iter.Seq2[*CcHashAlgorithmRow, error] {
	return func(yield func(v *CcHashAlgorithmRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,ALGORITHM_NUMBER,DESCRIPTION FROM CC_HASH_ALGORITHM"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CcHashAlgorithmRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.AlgorithmNumber, &r.Description)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CcSwVersionsRow struct represents rows of the CC_SW_VERSIONS table.
type CcSwVersionsRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    TosVersion	sql.NullString
    FpgaVersion	sql.NullString
}

// IterateCcSwVersions provide access to all rows of the CC_SW_VERSIONS matching given criteria.
func IterateCcSwVersions(db *sql.DB, where string, callback func(v *CcSwVersionsRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,TOS_VERSION,FPGA_VERSION FROM CC_SW_VERSIONS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CcSwVersionsRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.TosVersion, &r.FpgaVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCcSwVersions provide iterator to all rows of the CC_SW_VERSIONS matching given criteria.
func RangeCcSwVersions(db *sql.DB, where string) iter.Seq2[*CcSwVersionsRow, error] {
	return func(yield func(v *CcSwVersionsRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,TOS_VERSION,FPGA_VERSION FROM CC_SW_VERSIONS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CcSwVersionsRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.TosVersion, &r.FpgaVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CompositeScheduleRow struct represents rows of the COMPOSITE_SCHEDULE table.
type CompositeScheduleRow struct {
    ID	uint
    Name	sql.NullString
}

// IterateCompositeSchedule provide access to all rows of the COMPOSITE_SCHEDULE matching given criteria.
func IterateCompositeSchedule(db *sql.DB, where string, callback func(v *CompositeScheduleRow) error) error {
    query := "SELECT ID,NAME FROM COMPOSITE_SCHEDULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CompositeScheduleRow
        err := rows.Scan(&r.ID, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCompositeSchedule provide iterator to all rows of the COMPOSITE_SCHEDULE matching given criteria.
func RangeCompositeSchedule(db *sql.DB, where string) iter.Seq2[*CompositeScheduleRow, error] {
	return func(yield func(v *CompositeScheduleRow, err error) bool) {
	    query := "SELECT ID,NAME FROM COMPOSITE_SCHEDULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CompositeScheduleRow
	        err := rows.Scan(&r.ID, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ContentFilteringConfigRow struct represents rows of the CONTENT_FILTERING_CONFIG table.
type ContentFilteringConfigRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    ManualFilteringEnabled	sql.NullByte
    Z3ComFilteringEnabled	sql.NullByte
    DenyDefaultFilter	sql.NullByte
    ServerRegion	sql.NullByte
    FilterAction	sql.NullByte
    Z3ComFilteringServer	sql.NullString
    CustomResponsePage	sql.NullString
}

// IterateContentFilteringConfig provide access to all rows of the CONTENT_FILTERING_CONFIG matching given criteria.
func IterateContentFilteringConfig(db *sql.DB, where string, callback func(v *ContentFilteringConfigRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,MANUAL_FILTERING_ENABLED,3COM_FILTERING_ENABLED,DENY_DEFAULT_FILTER,SERVER_REGION,FILTER_ACTION,3COM_FILTERING_SERVER,CUSTOM_RESPONSE_PAGE FROM CONTENT_FILTERING_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ContentFilteringConfigRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.ManualFilteringEnabled, &r.Z3ComFilteringEnabled, &r.DenyDefaultFilter, &r.ServerRegion, &r.FilterAction, &r.Z3ComFilteringServer, &r.CustomResponsePage)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeContentFilteringConfig provide iterator to all rows of the CONTENT_FILTERING_CONFIG matching given criteria.
func RangeContentFilteringConfig(db *sql.DB, where string) iter.Seq2[*ContentFilteringConfigRow, error] {
	return func(yield func(v *ContentFilteringConfigRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,MANUAL_FILTERING_ENABLED,3COM_FILTERING_ENABLED,DENY_DEFAULT_FILTER,SERVER_REGION,FILTER_ACTION,3COM_FILTERING_SERVER,CUSTOM_RESPONSE_PAGE FROM CONTENT_FILTERING_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ContentFilteringConfigRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.ManualFilteringEnabled, &r.Z3ComFilteringEnabled, &r.DenyDefaultFilter, &r.ServerRegion, &r.FilterAction, &r.Z3ComFilteringServer, &r.CustomResponsePage)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ContentFilteringUrlPatternRow struct represents rows of the CONTENT_FILTERING_URL_PATTERN table.
type ContentFilteringUrlPatternRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    Allow	sql.NullByte
    RegularExpression	sql.NullByte
    Pattern	sql.NullString
}

// IterateContentFilteringUrlPattern provide access to all rows of the CONTENT_FILTERING_URL_PATTERN matching given criteria.
func IterateContentFilteringUrlPattern(db *sql.DB, where string, callback func(v *ContentFilteringUrlPatternRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,ALLOW,REGULAR_EXPRESSION,PATTERN FROM CONTENT_FILTERING_URL_PATTERN"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ContentFilteringUrlPatternRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Allow, &r.RegularExpression, &r.Pattern)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeContentFilteringUrlPattern provide iterator to all rows of the CONTENT_FILTERING_URL_PATTERN matching given criteria.
func RangeContentFilteringUrlPattern(db *sql.DB, where string) iter.Seq2[*ContentFilteringUrlPatternRow, error] {
	return func(yield func(v *ContentFilteringUrlPatternRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,ALLOW,REGULAR_EXPRESSION,PATTERN FROM CONTENT_FILTERING_URL_PATTERN"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ContentFilteringUrlPatternRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Allow, &r.RegularExpression, &r.Pattern)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ContentServiceMemberRow struct represents rows of the CONTENT_SERVICE_MEMBER table.
type ContentServiceMemberRow struct {
    DeviceShortID	uint
    Category	int
    CatType	string
    ApplyFilter	sql.NullByte
}

// IterateContentServiceMember provide access to all rows of the CONTENT_SERVICE_MEMBER matching given criteria.
func IterateContentServiceMember(db *sql.DB, where string, callback func(v *ContentServiceMemberRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,CATEGORY,CAT_TYPE,APPLY_FILTER FROM CONTENT_SERVICE_MEMBER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ContentServiceMemberRow
        err := rows.Scan(&r.DeviceShortID, &r.Category, &r.CatType, &r.ApplyFilter)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeContentServiceMember provide iterator to all rows of the CONTENT_SERVICE_MEMBER matching given criteria.
func RangeContentServiceMember(db *sql.DB, where string) iter.Seq2[*ContentServiceMemberRow, error] {
	return func(yield func(v *ContentServiceMemberRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,CATEGORY,CAT_TYPE,APPLY_FILTER FROM CONTENT_SERVICE_MEMBER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ContentServiceMemberRow
	        err := rows.Scan(&r.DeviceShortID, &r.Category, &r.CatType, &r.ApplyFilter)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CrlConfigRow struct represents rows of the CRL_CONFIG table.
type CrlConfigRow struct {
    CertID	int
    Source	string
    SourceType	string
    LastImport	sql.NullTime
    ThisUpdate	sql.NullTime
    NextUpdate	sql.NullTime
    CrlVersion	sql.NullByte
    SignatureAlgorithm	sql.NullString
    Issuer	sql.NullString
    EntryCount	sql.NullInt32
    Version	uint
    Signature	[]byte
    DerEncodedExtensions	[]byte
}

// IterateCrlConfig provide access to all rows of the CRL_CONFIG matching given criteria.
func IterateCrlConfig(db *sql.DB, where string, callback func(v *CrlConfigRow) error) error {
    query := "SELECT CERT_ID,SOURCE,SOURCE_TYPE,LAST_IMPORT,THIS_UPDATE,NEXT_UPDATE,CRL_VERSION,SIGNATURE_ALGORITHM,ISSUER,ENTRY_COUNT,VERSION,SIGNATURE,DER_ENCODED_EXTENSIONS FROM CRL_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CrlConfigRow
        err := rows.Scan(&r.CertID, &r.Source, &r.SourceType, &r.LastImport, &r.ThisUpdate, &r.NextUpdate, &r.CrlVersion, &r.SignatureAlgorithm, &r.Issuer, &r.EntryCount, &r.Version, &r.Signature, &r.DerEncodedExtensions)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCrlConfig provide iterator to all rows of the CRL_CONFIG matching given criteria.
func RangeCrlConfig(db *sql.DB, where string) iter.Seq2[*CrlConfigRow, error] {
	return func(yield func(v *CrlConfigRow, err error) bool) {
	    query := "SELECT CERT_ID,SOURCE,SOURCE_TYPE,LAST_IMPORT,THIS_UPDATE,NEXT_UPDATE,CRL_VERSION,SIGNATURE_ALGORITHM,ISSUER,ENTRY_COUNT,VERSION,SIGNATURE,DER_ENCODED_EXTENSIONS FROM CRL_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CrlConfigRow
	        err := rows.Scan(&r.CertID, &r.Source, &r.SourceType, &r.LastImport, &r.ThisUpdate, &r.NextUpdate, &r.CrlVersion, &r.SignatureAlgorithm, &r.Issuer, &r.EntryCount, &r.Version, &r.Signature, &r.DerEncodedExtensions)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CrlDataRow struct represents rows of the CRL_DATA table.
type CrlDataRow struct {
    CertID	int
    Version	uint
    DerEncodedCrl	[]byte
}

// IterateCrlData provide access to all rows of the CRL_DATA matching given criteria.
func IterateCrlData(db *sql.DB, where string, callback func(v *CrlDataRow) error) error {
    query := "SELECT CERT_ID,VERSION,DER_ENCODED_CRL FROM CRL_DATA"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CrlDataRow
        err := rows.Scan(&r.CertID, &r.Version, &r.DerEncodedCrl)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCrlData provide iterator to all rows of the CRL_DATA matching given criteria.
func RangeCrlData(db *sql.DB, where string) iter.Seq2[*CrlDataRow, error] {
	return func(yield func(v *CrlDataRow, err error) bool) {
	    query := "SELECT CERT_ID,VERSION,DER_ENCODED_CRL FROM CRL_DATA"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CrlDataRow
	        err := rows.Scan(&r.CertID, &r.Version, &r.DerEncodedCrl)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CustomWidgetSettingRow struct represents rows of the CUSTOM_WIDGET_SETTING table.
type CustomWidgetSettingRow struct {
    ID	uint
    SmsUserID	string
    WidgetSetting	sql.NullString
}

// IterateCustomWidgetSetting provide access to all rows of the CUSTOM_WIDGET_SETTING matching given criteria.
func IterateCustomWidgetSetting(db *sql.DB, where string, callback func(v *CustomWidgetSettingRow) error) error {
    query := "SELECT ID,SMS_USER_ID,WIDGET_SETTING FROM CUSTOM_WIDGET_SETTING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CustomWidgetSettingRow
        err := rows.Scan(&r.ID, &r.SmsUserID, &r.WidgetSetting)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCustomWidgetSetting provide iterator to all rows of the CUSTOM_WIDGET_SETTING matching given criteria.
func RangeCustomWidgetSetting(db *sql.DB, where string) iter.Seq2[*CustomWidgetSettingRow, error] {
	return func(yield func(v *CustomWidgetSettingRow, err error) bool) {
	    query := "SELECT ID,SMS_USER_ID,WIDGET_SETTING FROM CUSTOM_WIDGET_SETTING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CustomWidgetSettingRow
	        err := rows.Scan(&r.ID, &r.SmsUserID, &r.WidgetSetting)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CveRow struct represents rows of the CVE table.
type CveRow struct {
    CveID	string
    Comment	sql.NullString
    IgnoreCve	int8
    FirstOccuranceTime	sql.NullInt64
    LastOccuranceTime	sql.NullInt64
}

// IterateCve provide access to all rows of the CVE matching given criteria.
func IterateCve(db *sql.DB, where string, callback func(v *CveRow) error) error {
    query := "SELECT CVE_ID,COMMENT,IGNORE_CVE,FIRST_OCCURANCE_TIME,LAST_OCCURANCE_TIME FROM CVE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CveRow
        err := rows.Scan(&r.CveID, &r.Comment, &r.IgnoreCve, &r.FirstOccuranceTime, &r.LastOccuranceTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCve provide iterator to all rows of the CVE matching given criteria.
func RangeCve(db *sql.DB, where string) iter.Seq2[*CveRow, error] {
	return func(yield func(v *CveRow, err error) bool) {
	    query := "SELECT CVE_ID,COMMENT,IGNORE_CVE,FIRST_OCCURANCE_TIME,LAST_OCCURANCE_TIME FROM CVE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CveRow
	        err := rows.Scan(&r.CveID, &r.Comment, &r.IgnoreCve, &r.FirstOccuranceTime, &r.LastOccuranceTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CveSignatureRow struct represents rows of the CVE_SIGNATURE table.
type CveSignatureRow struct {
    CveIDFk	string
    SignatureIDFk	string
}

// IterateCveSignature provide access to all rows of the CVE_SIGNATURE matching given criteria.
func IterateCveSignature(db *sql.DB, where string, callback func(v *CveSignatureRow) error) error {
    query := "SELECT CVE_ID_FK,SIGNATURE_ID_FK FROM CVE_SIGNATURE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CveSignatureRow
        err := rows.Scan(&r.CveIDFk, &r.SignatureIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCveSignature provide iterator to all rows of the CVE_SIGNATURE matching given criteria.
func RangeCveSignature(db *sql.DB, where string) iter.Seq2[*CveSignatureRow, error] {
	return func(yield func(v *CveSignatureRow, err error) bool) {
	    query := "SELECT CVE_ID_FK,SIGNATURE_ID_FK FROM CVE_SIGNATURE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CveSignatureRow
	        err := rows.Scan(&r.CveIDFk, &r.SignatureIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// CveVulnScanEventRow struct represents rows of the CVE_VULN_SCAN_EVENT table.
type CveVulnScanEventRow struct {
    CveIDFk	string
    VulnScanEventIDFk	uint
}

// IterateCveVulnScanEvent provide access to all rows of the CVE_VULN_SCAN_EVENT matching given criteria.
func IterateCveVulnScanEvent(db *sql.DB, where string, callback func(v *CveVulnScanEventRow) error) error {
    query := "SELECT CVE_ID_FK,VULN_SCAN_EVENT_ID_FK FROM CVE_VULN_SCAN_EVENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r CveVulnScanEventRow
        err := rows.Scan(&r.CveIDFk, &r.VulnScanEventIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeCveVulnScanEvent provide iterator to all rows of the CVE_VULN_SCAN_EVENT matching given criteria.
func RangeCveVulnScanEvent(db *sql.DB, where string) iter.Seq2[*CveVulnScanEventRow, error] {
	return func(yield func(v *CveVulnScanEventRow, err error) bool) {
	    query := "SELECT CVE_ID_FK,VULN_SCAN_EVENT_ID_FK FROM CVE_VULN_SCAN_EVENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r CveVulnScanEventRow
	        err := rows.Scan(&r.CveIDFk, &r.VulnScanEventIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DashboardCellRow struct represents rows of the DASHBOARD_CELL table.
type DashboardCellRow struct {
    ID	string
    ColID	string
    SpecID	string
    Row	sql.NullByte
    System	sql.NullByte
}

// IterateDashboardCell provide access to all rows of the DASHBOARD_CELL matching given criteria.
func IterateDashboardCell(db *sql.DB, where string, callback func(v *DashboardCellRow) error) error {
    query := "SELECT ID,COL_ID,SPEC_ID,ROW,SYSTEM FROM DASHBOARD_CELL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DashboardCellRow
        err := rows.Scan(&r.ID, &r.ColID, &r.SpecID, &r.Row, &r.System)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDashboardCell provide iterator to all rows of the DASHBOARD_CELL matching given criteria.
func RangeDashboardCell(db *sql.DB, where string) iter.Seq2[*DashboardCellRow, error] {
	return func(yield func(v *DashboardCellRow, err error) bool) {
	    query := "SELECT ID,COL_ID,SPEC_ID,ROW,SYSTEM FROM DASHBOARD_CELL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DashboardCellRow
	        err := rows.Scan(&r.ID, &r.ColID, &r.SpecID, &r.Row, &r.System)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DashboardColRow struct represents rows of the DASHBOARD_COL table.
type DashboardColRow struct {
    ID	string
    ProfileID	string
    Name	string
    ColNum	sql.NullByte
    System	sql.NullByte
}

// IterateDashboardCol provide access to all rows of the DASHBOARD_COL matching given criteria.
func IterateDashboardCol(db *sql.DB, where string, callback func(v *DashboardColRow) error) error {
    query := "SELECT ID,PROFILE_ID,NAME,COL_NUM,SYSTEM FROM DASHBOARD_COL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DashboardColRow
        err := rows.Scan(&r.ID, &r.ProfileID, &r.Name, &r.ColNum, &r.System)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDashboardCol provide iterator to all rows of the DASHBOARD_COL matching given criteria.
func RangeDashboardCol(db *sql.DB, where string) iter.Seq2[*DashboardColRow, error] {
	return func(yield func(v *DashboardColRow, err error) bool) {
	    query := "SELECT ID,PROFILE_ID,NAME,COL_NUM,SYSTEM FROM DASHBOARD_COL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DashboardColRow
	        err := rows.Scan(&r.ID, &r.ProfileID, &r.Name, &r.ColNum, &r.System)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DashboardProfileRow struct represents rows of the DASHBOARD_PROFILE table.
type DashboardProfileRow struct {
    ID	string
    Name	string
    User	string
    System	sql.NullByte
}

// IterateDashboardProfile provide access to all rows of the DASHBOARD_PROFILE matching given criteria.
func IterateDashboardProfile(db *sql.DB, where string, callback func(v *DashboardProfileRow) error) error {
    query := "SELECT ID,NAME,USER,SYSTEM FROM DASHBOARD_PROFILE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DashboardProfileRow
        err := rows.Scan(&r.ID, &r.Name, &r.User, &r.System)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDashboardProfile provide iterator to all rows of the DASHBOARD_PROFILE matching given criteria.
func RangeDashboardProfile(db *sql.DB, where string) iter.Seq2[*DashboardProfileRow, error] {
	return func(yield func(v *DashboardProfileRow, err error) bool) {
	    query := "SELECT ID,NAME,USER,SYSTEM FROM DASHBOARD_PROFILE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DashboardProfileRow
	        err := rows.Scan(&r.ID, &r.Name, &r.User, &r.System)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DashChartCacheRow struct represents rows of the DASH_CHART_CACHE table.
type DashChartCacheRow struct {
    BucketOrdinal	sql.NullInt64
    Category	sql.NullInt32
    NoticeAction	sql.NullInt32
    Hits	sql.NullInt64
}

// IterateDashChartCache provide access to all rows of the DASH_CHART_CACHE matching given criteria.
func IterateDashChartCache(db *sql.DB, where string, callback func(v *DashChartCacheRow) error) error {
    query := "SELECT BUCKET_ORDINAL,CATEGORY,NOTICE_ACTION,HITS FROM DASH_CHART_CACHE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DashChartCacheRow
        err := rows.Scan(&r.BucketOrdinal, &r.Category, &r.NoticeAction, &r.Hits)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDashChartCache provide iterator to all rows of the DASH_CHART_CACHE matching given criteria.
func RangeDashChartCache(db *sql.DB, where string) iter.Seq2[*DashChartCacheRow, error] {
	return func(yield func(v *DashChartCacheRow, err error) bool) {
	    query := "SELECT BUCKET_ORDINAL,CATEGORY,NOTICE_ACTION,HITS FROM DASH_CHART_CACHE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DashChartCacheRow
	        err := rows.Scan(&r.BucketOrdinal, &r.Category, &r.NoticeAction, &r.Hits)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DatabaseIDRow struct represents rows of the DATABASE_ID table.
type DatabaseIDRow struct {
    ID	string
}

// IterateDatabaseID provide access to all rows of the DATABASE_ID matching given criteria.
func IterateDatabaseID(db *sql.DB, where string, callback func(v *DatabaseIDRow) error) error {
    query := "SELECT ID FROM DATABASE_ID"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DatabaseIDRow
        err := rows.Scan(&r.ID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDatabaseID provide iterator to all rows of the DATABASE_ID matching given criteria.
func RangeDatabaseID(db *sql.DB, where string) iter.Seq2[*DatabaseIDRow, error] {
	return func(yield func(v *DatabaseIDRow, err error) bool) {
	    query := "SELECT ID FROM DATABASE_ID"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DatabaseIDRow
	        err := rows.Scan(&r.ID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DatabaseModelRow struct represents rows of the DATABASE_MODEL table.
type DatabaseModelRow struct {
    Version	string
}

// IterateDatabaseModel provide access to all rows of the DATABASE_MODEL matching given criteria.
func IterateDatabaseModel(db *sql.DB, where string, callback func(v *DatabaseModelRow) error) error {
    query := "SELECT VERSION FROM DATABASE_MODEL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DatabaseModelRow
        err := rows.Scan(&r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDatabaseModel provide iterator to all rows of the DATABASE_MODEL matching given criteria.
func RangeDatabaseModel(db *sql.DB, where string) iter.Seq2[*DatabaseModelRow, error] {
	return func(yield func(v *DatabaseModelRow, err error) bool) {
	    query := "SELECT VERSION FROM DATABASE_MODEL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DatabaseModelRow
	        err := rows.Scan(&r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DbCleanupConfigRow struct represents rows of the DB_CLEANUP_CONFIG table.
type DbCleanupConfigRow struct {
    Objectid	string
    Objecttype	string
    Objectdescr	string
    Age	int
    MaxRows	int64
    ScheduleInterval	int
    CleanupPercent	int
    MinRowConstraint	int
    MaxRowConstraint	int64
    MinAgeConstraint	int
    LastCleanup	sql.NullInt64
    Visible	sql.NullInt32
}

// IterateDbCleanupConfig provide access to all rows of the DB_CLEANUP_CONFIG matching given criteria.
func IterateDbCleanupConfig(db *sql.DB, where string, callback func(v *DbCleanupConfigRow) error) error {
    query := "SELECT ObjectID,ObjectType,ObjectDescr,AGE,MAX_ROWS,SCHEDULE_INTERVAL,CLEANUP_PERCENT,MIN_ROW_CONSTRAINT,MAX_ROW_CONSTRAINT,MIN_AGE_CONSTRAINT,LAST_CLEANUP,VISIBLE FROM DB_CLEANUP_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DbCleanupConfigRow
        err := rows.Scan(&r.Objectid, &r.Objecttype, &r.Objectdescr, &r.Age, &r.MaxRows, &r.ScheduleInterval, &r.CleanupPercent, &r.MinRowConstraint, &r.MaxRowConstraint, &r.MinAgeConstraint, &r.LastCleanup, &r.Visible)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDbCleanupConfig provide iterator to all rows of the DB_CLEANUP_CONFIG matching given criteria.
func RangeDbCleanupConfig(db *sql.DB, where string) iter.Seq2[*DbCleanupConfigRow, error] {
	return func(yield func(v *DbCleanupConfigRow, err error) bool) {
	    query := "SELECT ObjectID,ObjectType,ObjectDescr,AGE,MAX_ROWS,SCHEDULE_INTERVAL,CLEANUP_PERCENT,MIN_ROW_CONSTRAINT,MAX_ROW_CONSTRAINT,MIN_AGE_CONSTRAINT,LAST_CLEANUP,VISIBLE FROM DB_CLEANUP_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DbCleanupConfigRow
	        err := rows.Scan(&r.Objectid, &r.Objecttype, &r.Objectdescr, &r.Age, &r.MaxRows, &r.ScheduleInterval, &r.CleanupPercent, &r.MinRowConstraint, &r.MaxRowConstraint, &r.MinAgeConstraint, &r.LastCleanup, &r.Visible)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DefaultWidgetSettingRow struct represents rows of the DEFAULT_WIDGET_SETTING table.
type DefaultWidgetSettingRow struct {
    ID	uint
    WidgetSetting	sql.NullString
}

// IterateDefaultWidgetSetting provide access to all rows of the DEFAULT_WIDGET_SETTING matching given criteria.
func IterateDefaultWidgetSetting(db *sql.DB, where string, callback func(v *DefaultWidgetSettingRow) error) error {
    query := "SELECT ID,WIDGET_SETTING FROM DEFAULT_WIDGET_SETTING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DefaultWidgetSettingRow
        err := rows.Scan(&r.ID, &r.WidgetSetting)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDefaultWidgetSetting provide iterator to all rows of the DEFAULT_WIDGET_SETTING matching given criteria.
func RangeDefaultWidgetSetting(db *sql.DB, where string) iter.Seq2[*DefaultWidgetSettingRow, error] {
	return func(yield func(v *DefaultWidgetSettingRow, err error) bool) {
	    query := "SELECT ID,WIDGET_SETTING FROM DEFAULT_WIDGET_SETTING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DefaultWidgetSettingRow
	        err := rows.Scan(&r.ID, &r.WidgetSetting)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceRow struct represents rows of the DEVICE table.
type DeviceRow struct {
    ID	uint
    TargetType	uint
    DevShortID	sql.NullInt32
    HiPriority	sql.NullByte
    LastDistrib	string
}

// IterateDevice provide access to all rows of the DEVICE matching given criteria.
func IterateDevice(db *sql.DB, where string, callback func(v *DeviceRow) error) error {
    query := "SELECT ID,TARGET_TYPE,DEV_SHORT_ID,HI_PRIORITY,LAST_DISTRIB FROM DEVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceRow
        err := rows.Scan(&r.ID, &r.TargetType, &r.DevShortID, &r.HiPriority, &r.LastDistrib)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDevice provide iterator to all rows of the DEVICE matching given criteria.
func RangeDevice(db *sql.DB, where string) iter.Seq2[*DeviceRow, error] {
	return func(yield func(v *DeviceRow, err error) bool) {
	    query := "SELECT ID,TARGET_TYPE,DEV_SHORT_ID,HI_PRIORITY,LAST_DISTRIB FROM DEVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceRow
	        err := rows.Scan(&r.ID, &r.TargetType, &r.DevShortID, &r.HiPriority, &r.LastDistrib)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DevicegroupUserGroupsRow struct represents rows of the DEVICEGROUP_USER_GROUPS table.
type DevicegroupUserGroupsRow struct {
    UserGroupsIDFk	uint
    DevicegroupIDFk	uint
}

// IterateDevicegroupUserGroups provide access to all rows of the DEVICEGROUP_USER_GROUPS matching given criteria.
func IterateDevicegroupUserGroups(db *sql.DB, where string, callback func(v *DevicegroupUserGroupsRow) error) error {
    query := "SELECT USER_GROUPS_ID_FK,DEVICEGROUP_ID_FK FROM DEVICEGROUP_USER_GROUPS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DevicegroupUserGroupsRow
        err := rows.Scan(&r.UserGroupsIDFk, &r.DevicegroupIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDevicegroupUserGroups provide iterator to all rows of the DEVICEGROUP_USER_GROUPS matching given criteria.
func RangeDevicegroupUserGroups(db *sql.DB, where string) iter.Seq2[*DevicegroupUserGroupsRow, error] {
	return func(yield func(v *DevicegroupUserGroupsRow, err error) bool) {
	    query := "SELECT USER_GROUPS_ID_FK,DEVICEGROUP_ID_FK FROM DEVICEGROUP_USER_GROUPS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DevicegroupUserGroupsRow
	        err := rows.Scan(&r.UserGroupsIDFk, &r.DevicegroupIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceAuditLogRow struct represents rows of the DEVICE_AUDIT_LOG table.
type DeviceAuditLogRow struct {
    DeviceShortID	sql.NullInt32
    SequenceNum	sql.NullInt64
    Time	sql.NullInt64
    AccessLevel	sql.NullByte
    Interface	sql.NullByte
    IPAddress1	sql.NullInt64
    IPAddress2	sql.NullInt64
    Category	sql.NullByte
    Result	sql.NullByte
    User	sql.NullString
    Message	sql.NullString
    Idx	int64
}

// IterateDeviceAuditLog provide access to all rows of the DEVICE_AUDIT_LOG matching given criteria.
func IterateDeviceAuditLog(db *sql.DB, where string, callback func(v *DeviceAuditLogRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,SEQUENCE_NUM,TIME,ACCESS_LEVEL,INTERFACE,IP_ADDRESS_1,IP_ADDRESS_2,CATEGORY,RESULT,USER,MESSAGE,IDX FROM DEVICE_AUDIT_LOG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceAuditLogRow
        err := rows.Scan(&r.DeviceShortID, &r.SequenceNum, &r.Time, &r.AccessLevel, &r.Interface, &r.IPAddress1, &r.IPAddress2, &r.Category, &r.Result, &r.User, &r.Message, &r.Idx)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceAuditLog provide iterator to all rows of the DEVICE_AUDIT_LOG matching given criteria.
func RangeDeviceAuditLog(db *sql.DB, where string) iter.Seq2[*DeviceAuditLogRow, error] {
	return func(yield func(v *DeviceAuditLogRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,SEQUENCE_NUM,TIME,ACCESS_LEVEL,INTERFACE,IP_ADDRESS_1,IP_ADDRESS_2,CATEGORY,RESULT,USER,MESSAGE,IDX FROM DEVICE_AUDIT_LOG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceAuditLogRow
	        err := rows.Scan(&r.DeviceShortID, &r.SequenceNum, &r.Time, &r.AccessLevel, &r.Interface, &r.IPAddress1, &r.IPAddress2, &r.Category, &r.Result, &r.User, &r.Message, &r.Idx)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceAuthPrefRow struct represents rows of the DEVICE_AUTH_PREF table.
type DeviceAuthPrefRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    InactiveTimeout	sql.NullInt32
    MaxSessionTime	sql.NullInt32
}

// IterateDeviceAuthPref provide access to all rows of the DEVICE_AUTH_PREF matching given criteria.
func IterateDeviceAuthPref(db *sql.DB, where string, callback func(v *DeviceAuthPrefRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,INACTIVE_TIMEOUT,MAX_SESSION_TIME FROM DEVICE_AUTH_PREF"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceAuthPrefRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.InactiveTimeout, &r.MaxSessionTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceAuthPref provide iterator to all rows of the DEVICE_AUTH_PREF matching given criteria.
func RangeDeviceAuthPref(db *sql.DB, where string) iter.Seq2[*DeviceAuthPrefRow, error] {
	return func(yield func(v *DeviceAuthPrefRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,INACTIVE_TIMEOUT,MAX_SESSION_TIME FROM DEVICE_AUTH_PREF"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceAuthPrefRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.InactiveTimeout, &r.MaxSessionTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceAzureLogMonitorInfoRow struct represents rows of the DEVICE_AZURE_LOG_MONITOR_INFO table.
type DeviceAzureLogMonitorInfoRow struct {
    DeviceShortID	uint
    IpsEventEnabled	int8
    InspEventEnabled	int8
    WorkspaceID	string
}

// IterateDeviceAzureLogMonitorInfo provide access to all rows of the DEVICE_AZURE_LOG_MONITOR_INFO matching given criteria.
func IterateDeviceAzureLogMonitorInfo(db *sql.DB, where string, callback func(v *DeviceAzureLogMonitorInfoRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,IPS_EVENT_ENABLED,INSP_EVENT_ENABLED,WORKSPACE_ID FROM DEVICE_AZURE_LOG_MONITOR_INFO"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceAzureLogMonitorInfoRow
        err := rows.Scan(&r.DeviceShortID, &r.IpsEventEnabled, &r.InspEventEnabled, &r.WorkspaceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceAzureLogMonitorInfo provide iterator to all rows of the DEVICE_AZURE_LOG_MONITOR_INFO matching given criteria.
func RangeDeviceAzureLogMonitorInfo(db *sql.DB, where string) iter.Seq2[*DeviceAzureLogMonitorInfoRow, error] {
	return func(yield func(v *DeviceAzureLogMonitorInfoRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,IPS_EVENT_ENABLED,INSP_EVENT_ENABLED,WORKSPACE_ID FROM DEVICE_AZURE_LOG_MONITOR_INFO"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceAzureLogMonitorInfoRow
	        err := rows.Scan(&r.DeviceShortID, &r.IpsEventEnabled, &r.InspEventEnabled, &r.WorkspaceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceBuildHistoryRow struct represents rows of the DEVICE_BUILD_HISTORY table.
type DeviceBuildHistoryRow struct {
    BuildID	int
    Platform	string
    Version	string
    Released	uint64
    Supported	int8
}

// IterateDeviceBuildHistory provide access to all rows of the DEVICE_BUILD_HISTORY matching given criteria.
func IterateDeviceBuildHistory(db *sql.DB, where string, callback func(v *DeviceBuildHistoryRow) error) error {
    query := "SELECT BUILD_ID,PLATFORM,VERSION,RELEASED,SUPPORTED FROM DEVICE_BUILD_HISTORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceBuildHistoryRow
        err := rows.Scan(&r.BuildID, &r.Platform, &r.Version, &r.Released, &r.Supported)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceBuildHistory provide iterator to all rows of the DEVICE_BUILD_HISTORY matching given criteria.
func RangeDeviceBuildHistory(db *sql.DB, where string) iter.Seq2[*DeviceBuildHistoryRow, error] {
	return func(yield func(v *DeviceBuildHistoryRow, err error) bool) {
	    query := "SELECT BUILD_ID,PLATFORM,VERSION,RELEASED,SUPPORTED FROM DEVICE_BUILD_HISTORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceBuildHistoryRow
	        err := rows.Scan(&r.BuildID, &r.Platform, &r.Version, &r.Released, &r.Supported)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceCapabilityRow struct represents rows of the DEVICE_CAPABILITY table.
type DeviceCapabilityRow struct {
    Name	string
    IpsVersion	sql.NullString
    NgfwVersion	sql.NullString
    Revision	sql.NullString
    DisplayName	sql.NullString
}

// IterateDeviceCapability provide access to all rows of the DEVICE_CAPABILITY matching given criteria.
func IterateDeviceCapability(db *sql.DB, where string, callback func(v *DeviceCapabilityRow) error) error {
    query := "SELECT NAME,IPS_VERSION,NGFW_VERSION,REVISION,DISPLAY_NAME FROM DEVICE_CAPABILITY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceCapabilityRow
        err := rows.Scan(&r.Name, &r.IpsVersion, &r.NgfwVersion, &r.Revision, &r.DisplayName)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceCapability provide iterator to all rows of the DEVICE_CAPABILITY matching given criteria.
func RangeDeviceCapability(db *sql.DB, where string) iter.Seq2[*DeviceCapabilityRow, error] {
	return func(yield func(v *DeviceCapabilityRow, err error) bool) {
	    query := "SELECT NAME,IPS_VERSION,NGFW_VERSION,REVISION,DISPLAY_NAME FROM DEVICE_CAPABILITY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceCapabilityRow
	        err := rows.Scan(&r.Name, &r.IpsVersion, &r.NgfwVersion, &r.Revision, &r.DisplayName)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceCcMappingRow struct represents rows of the DEVICE_CC_MAPPING table.
type DeviceCcMappingRow struct {
    DeviceShortID	uint
    CcShortID	uint
}

// IterateDeviceCcMapping provide access to all rows of the DEVICE_CC_MAPPING matching given criteria.
func IterateDeviceCcMapping(db *sql.DB, where string, callback func(v *DeviceCcMappingRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,CC_SHORT_ID FROM DEVICE_CC_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceCcMappingRow
        err := rows.Scan(&r.DeviceShortID, &r.CcShortID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceCcMapping provide iterator to all rows of the DEVICE_CC_MAPPING matching given criteria.
func RangeDeviceCcMapping(db *sql.DB, where string) iter.Seq2[*DeviceCcMappingRow, error] {
	return func(yield func(v *DeviceCcMappingRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,CC_SHORT_ID FROM DEVICE_CC_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceCcMappingRow
	        err := rows.Scan(&r.DeviceShortID, &r.CcShortID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceCertificateRow struct represents rows of the DEVICE_CERTIFICATE table.
type DeviceCertificateRow struct {
    ID	int
    Version	int
    DeviceShortID	uint
    DeviceCertName	string
    NamedCertificateID	int
    UseAuthentication	int8
    UseIpsecVpn	int8
    UseSslInspection	int8
}

// IterateDeviceCertificate provide access to all rows of the DEVICE_CERTIFICATE matching given criteria.
func IterateDeviceCertificate(db *sql.DB, where string, callback func(v *DeviceCertificateRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,DEVICE_CERT_NAME,NAMED_CERTIFICATE_ID,USE_AUTHENTICATION,USE_IPSEC_VPN,USE_SSL_INSPECTION FROM DEVICE_CERTIFICATE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceCertificateRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.DeviceCertName, &r.NamedCertificateID, &r.UseAuthentication, &r.UseIpsecVpn, &r.UseSslInspection)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceCertificate provide iterator to all rows of the DEVICE_CERTIFICATE matching given criteria.
func RangeDeviceCertificate(db *sql.DB, where string) iter.Seq2[*DeviceCertificateRow, error] {
	return func(yield func(v *DeviceCertificateRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,DEVICE_CERT_NAME,NAMED_CERTIFICATE_ID,USE_AUTHENTICATION,USE_IPSEC_VPN,USE_SSL_INSPECTION FROM DEVICE_CERTIFICATE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceCertificateRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.DeviceCertName, &r.NamedCertificateID, &r.UseAuthentication, &r.UseIpsecVpn, &r.UseSslInspection)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceCloudWatchInfoRow struct represents rows of the DEVICE_CLOUD_WATCH_INFO table.
type DeviceCloudWatchInfoRow struct {
    DeviceShortID	uint
    IpsEventEnabled	int8
    InspEventEnabled	int8
    LogGroupName	string
}

// IterateDeviceCloudWatchInfo provide access to all rows of the DEVICE_CLOUD_WATCH_INFO matching given criteria.
func IterateDeviceCloudWatchInfo(db *sql.DB, where string, callback func(v *DeviceCloudWatchInfoRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,IPS_EVENT_ENABLED,INSP_EVENT_ENABLED,LOG_GROUP_NAME FROM DEVICE_CLOUD_WATCH_INFO"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceCloudWatchInfoRow
        err := rows.Scan(&r.DeviceShortID, &r.IpsEventEnabled, &r.InspEventEnabled, &r.LogGroupName)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceCloudWatchInfo provide iterator to all rows of the DEVICE_CLOUD_WATCH_INFO matching given criteria.
func RangeDeviceCloudWatchInfo(db *sql.DB, where string) iter.Seq2[*DeviceCloudWatchInfoRow, error] {
	return func(yield func(v *DeviceCloudWatchInfoRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,IPS_EVENT_ENABLED,INSP_EVENT_ENABLED,LOG_GROUP_NAME FROM DEVICE_CLOUD_WATCH_INFO"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceCloudWatchInfoRow
	        err := rows.Scan(&r.DeviceShortID, &r.IpsEventEnabled, &r.InspEventEnabled, &r.LogGroupName)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceConfigSignatureRow struct represents rows of the DEVICE_CONFIG_SIGNATURE table.
type DeviceConfigSignatureRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    ConfigItemType	sql.NullByte
    ConfigSignature	sql.NullString
}

// IterateDeviceConfigSignature provide access to all rows of the DEVICE_CONFIG_SIGNATURE matching given criteria.
func IterateDeviceConfigSignature(db *sql.DB, where string, callback func(v *DeviceConfigSignatureRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,CONFIG_ITEM_TYPE,CONFIG_SIGNATURE FROM DEVICE_CONFIG_SIGNATURE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceConfigSignatureRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.ConfigItemType, &r.ConfigSignature)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceConfigSignature provide iterator to all rows of the DEVICE_CONFIG_SIGNATURE matching given criteria.
func RangeDeviceConfigSignature(db *sql.DB, where string) iter.Seq2[*DeviceConfigSignatureRow, error] {
	return func(yield func(v *DeviceConfigSignatureRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,CONFIG_ITEM_TYPE,CONFIG_SIGNATURE FROM DEVICE_CONFIG_SIGNATURE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceConfigSignatureRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.ConfigItemType, &r.ConfigSignature)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceDdosDataRow struct represents rows of the DEVICE_DDOS_DATA table.
type DeviceDdosDataRow struct {
    DeviceID	string
    SynProxyState	sql.NullInt32
    CpsFloodState	sql.NullInt32
    CpsFloodThreshold	sql.NullString
    ConnFloodState	sql.NullInt32
    ConnFloodThreshold	sql.NullString
    ExceptionsGroupID	sql.NullString
}

// IterateDeviceDdosData provide access to all rows of the DEVICE_DDOS_DATA matching given criteria.
func IterateDeviceDdosData(db *sql.DB, where string, callback func(v *DeviceDdosDataRow) error) error {
    query := "SELECT DEVICE_ID,SYN_PROXY_STATE,CPS_FLOOD_STATE,CPS_FLOOD_THRESHOLD,CONN_FLOOD_STATE,CONN_FLOOD_THRESHOLD,EXCEPTIONS_GROUP_ID FROM DEVICE_DDOS_DATA"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceDdosDataRow
        err := rows.Scan(&r.DeviceID, &r.SynProxyState, &r.CpsFloodState, &r.CpsFloodThreshold, &r.ConnFloodState, &r.ConnFloodThreshold, &r.ExceptionsGroupID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceDdosData provide iterator to all rows of the DEVICE_DDOS_DATA matching given criteria.
func RangeDeviceDdosData(db *sql.DB, where string) iter.Seq2[*DeviceDdosDataRow, error] {
	return func(yield func(v *DeviceDdosDataRow, err error) bool) {
	    query := "SELECT DEVICE_ID,SYN_PROXY_STATE,CPS_FLOOD_STATE,CPS_FLOOD_THRESHOLD,CONN_FLOOD_STATE,CONN_FLOOD_THRESHOLD,EXCEPTIONS_GROUP_ID FROM DEVICE_DDOS_DATA"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceDdosDataRow
	        err := rows.Scan(&r.DeviceID, &r.SynProxyState, &r.CpsFloodState, &r.CpsFloodThreshold, &r.ConnFloodState, &r.ConnFloodThreshold, &r.ExceptionsGroupID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceDdosPrefSettingsRow struct represents rows of the DEVICE_DDOS_PREF_SETTINGS table.
type DeviceDdosPrefSettingsRow struct {
    DeviceShortID	uint
    CpsAggrAlerts	sql.NullByte
    ConnFloodAggrAlerts	sql.NullByte
}

// IterateDeviceDdosPrefSettings provide access to all rows of the DEVICE_DDOS_PREF_SETTINGS matching given criteria.
func IterateDeviceDdosPrefSettings(db *sql.DB, where string, callback func(v *DeviceDdosPrefSettingsRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,CPS_AGGR_ALERTS,CONN_FLOOD_AGGR_ALERTS FROM DEVICE_DDOS_PREF_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceDdosPrefSettingsRow
        err := rows.Scan(&r.DeviceShortID, &r.CpsAggrAlerts, &r.ConnFloodAggrAlerts)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceDdosPrefSettings provide iterator to all rows of the DEVICE_DDOS_PREF_SETTINGS matching given criteria.
func RangeDeviceDdosPrefSettings(db *sql.DB, where string) iter.Seq2[*DeviceDdosPrefSettingsRow, error] {
	return func(yield func(v *DeviceDdosPrefSettingsRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,CPS_AGGR_ALERTS,CONN_FLOOD_AGGR_ALERTS FROM DEVICE_DDOS_PREF_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceDdosPrefSettingsRow
	        err := rows.Scan(&r.DeviceShortID, &r.CpsAggrAlerts, &r.ConnFloodAggrAlerts)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceDiscoverTimestampsRow struct represents rows of the DEVICE_DISCOVER_TIMESTAMPS table.
type DeviceDiscoverTimestampsRow struct {
    DeviceShortID	uint
    FullDiscoverTimestamp	sql.NullInt64
    StateDiscoverTimestamp	sql.NullInt64
}

// IterateDeviceDiscoverTimestamps provide access to all rows of the DEVICE_DISCOVER_TIMESTAMPS matching given criteria.
func IterateDeviceDiscoverTimestamps(db *sql.DB, where string, callback func(v *DeviceDiscoverTimestampsRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,FULL_DISCOVER_TIMESTAMP,STATE_DISCOVER_TIMESTAMP FROM DEVICE_DISCOVER_TIMESTAMPS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceDiscoverTimestampsRow
        err := rows.Scan(&r.DeviceShortID, &r.FullDiscoverTimestamp, &r.StateDiscoverTimestamp)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceDiscoverTimestamps provide iterator to all rows of the DEVICE_DISCOVER_TIMESTAMPS matching given criteria.
func RangeDeviceDiscoverTimestamps(db *sql.DB, where string) iter.Seq2[*DeviceDiscoverTimestampsRow, error] {
	return func(yield func(v *DeviceDiscoverTimestampsRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,FULL_DISCOVER_TIMESTAMP,STATE_DISCOVER_TIMESTAMP FROM DEVICE_DISCOVER_TIMESTAMPS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceDiscoverTimestampsRow
	        err := rows.Scan(&r.DeviceShortID, &r.FullDiscoverTimestamp, &r.StateDiscoverTimestamp)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceDistributionInfoRow struct represents rows of the DEVICE_DISTRIBUTION_INFO table.
type DeviceDistributionInfoRow struct {
    DistributeID	string
    DeviceID	string
    Type	string
    SubType	sql.NullString
    CurrentVersion	sql.NullString
    TargetVersion	sql.NullString
    Status	string
    StatusQualifier	sql.NullString
    AdditionalInfo	sql.NullString
    StartTimestamp	string
    CompleteTimestamp	sql.NullTime
    StartTime	int64
    CompleteTime	sql.NullInt64
    TargetPkgID	sql.NullString
}

// IterateDeviceDistributionInfo provide access to all rows of the DEVICE_DISTRIBUTION_INFO matching given criteria.
func IterateDeviceDistributionInfo(db *sql.DB, where string, callback func(v *DeviceDistributionInfoRow) error) error {
    query := "SELECT DISTRIBUTE_ID,DEVICE_ID,TYPE,SUB_TYPE,CURRENT_VERSION,TARGET_VERSION,STATUS,STATUS_QUALIFIER,ADDITIONAL_INFO,START_TIMESTAMP,COMPLETE_TIMESTAMP,START_TIME,COMPLETE_TIME,TARGET_PKG_ID FROM DEVICE_DISTRIBUTION_INFO"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceDistributionInfoRow
        err := rows.Scan(&r.DistributeID, &r.DeviceID, &r.Type, &r.SubType, &r.CurrentVersion, &r.TargetVersion, &r.Status, &r.StatusQualifier, &r.AdditionalInfo, &r.StartTimestamp, &r.CompleteTimestamp, &r.StartTime, &r.CompleteTime, &r.TargetPkgID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceDistributionInfo provide iterator to all rows of the DEVICE_DISTRIBUTION_INFO matching given criteria.
func RangeDeviceDistributionInfo(db *sql.DB, where string) iter.Seq2[*DeviceDistributionInfoRow, error] {
	return func(yield func(v *DeviceDistributionInfoRow, err error) bool) {
	    query := "SELECT DISTRIBUTE_ID,DEVICE_ID,TYPE,SUB_TYPE,CURRENT_VERSION,TARGET_VERSION,STATUS,STATUS_QUALIFIER,ADDITIONAL_INFO,START_TIMESTAMP,COMPLETE_TIMESTAMP,START_TIME,COMPLETE_TIME,TARGET_PKG_ID FROM DEVICE_DISTRIBUTION_INFO"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceDistributionInfoRow
	        err := rows.Scan(&r.DistributeID, &r.DeviceID, &r.Type, &r.SubType, &r.CurrentVersion, &r.TargetVersion, &r.Status, &r.StatusQualifier, &r.AdditionalInfo, &r.StartTimestamp, &r.CompleteTimestamp, &r.StartTime, &r.CompleteTime, &r.TargetPkgID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceDistributionQMemberRow struct represents rows of the DEVICE_DISTRIBUTION_Q_MEMBER table.
type DeviceDistributionQMemberRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    QueueOrder	sql.NullInt16
    DistributionTryCounts	sql.NullInt16
    DistributeID	sql.NullString
    Type	string
    Status	string
}

// IterateDeviceDistributionQMember provide access to all rows of the DEVICE_DISTRIBUTION_Q_MEMBER matching given criteria.
func IterateDeviceDistributionQMember(db *sql.DB, where string, callback func(v *DeviceDistributionQMemberRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,QUEUE_ORDER,DISTRIBUTION_TRY_COUNTS,DISTRIBUTE_ID,TYPE,STATUS FROM DEVICE_DISTRIBUTION_Q_MEMBER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceDistributionQMemberRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.QueueOrder, &r.DistributionTryCounts, &r.DistributeID, &r.Type, &r.Status)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceDistributionQMember provide iterator to all rows of the DEVICE_DISTRIBUTION_Q_MEMBER matching given criteria.
func RangeDeviceDistributionQMember(db *sql.DB, where string) iter.Seq2[*DeviceDistributionQMemberRow, error] {
	return func(yield func(v *DeviceDistributionQMemberRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,QUEUE_ORDER,DISTRIBUTION_TRY_COUNTS,DISTRIBUTE_ID,TYPE,STATUS FROM DEVICE_DISTRIBUTION_Q_MEMBER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceDistributionQMemberRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.QueueOrder, &r.DistributionTryCounts, &r.DistributeID, &r.Type, &r.Status)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceDistributionQMemberFileRow struct represents rows of the DEVICE_DISTRIBUTION_Q_MEMBER_FILE table.
type DeviceDistributionQMemberFileRow struct {
    ID	uint
    DeviceDistributionQMemberID	sql.NullInt32
    PackageType	string
    FileName	string
    FileTimestamp	int64
}

// IterateDeviceDistributionQMemberFile provide access to all rows of the DEVICE_DISTRIBUTION_Q_MEMBER_FILE matching given criteria.
func IterateDeviceDistributionQMemberFile(db *sql.DB, where string, callback func(v *DeviceDistributionQMemberFileRow) error) error {
    query := "SELECT ID,DEVICE_DISTRIBUTION_Q_MEMBER_ID,PACKAGE_TYPE,FILE_NAME,FILE_TIMESTAMP FROM DEVICE_DISTRIBUTION_Q_MEMBER_FILE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceDistributionQMemberFileRow
        err := rows.Scan(&r.ID, &r.DeviceDistributionQMemberID, &r.PackageType, &r.FileName, &r.FileTimestamp)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceDistributionQMemberFile provide iterator to all rows of the DEVICE_DISTRIBUTION_Q_MEMBER_FILE matching given criteria.
func RangeDeviceDistributionQMemberFile(db *sql.DB, where string) iter.Seq2[*DeviceDistributionQMemberFileRow, error] {
	return func(yield func(v *DeviceDistributionQMemberFileRow, err error) bool) {
	    query := "SELECT ID,DEVICE_DISTRIBUTION_Q_MEMBER_ID,PACKAGE_TYPE,FILE_NAME,FILE_TIMESTAMP FROM DEVICE_DISTRIBUTION_Q_MEMBER_FILE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceDistributionQMemberFileRow
	        err := rows.Scan(&r.ID, &r.DeviceDistributionQMemberID, &r.PackageType, &r.FileName, &r.FileTimestamp)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceDnsServerRow struct represents rows of the DEVICE_DNS_SERVER table.
type DeviceDnsServerRow struct {
    DeviceShortID	uint
    Dns1IP	sql.NullInt32
    Dns2IP	sql.NullInt32
    Dns3IP	sql.NullInt32
    Domain1	sql.NullString
    Domain2	sql.NullString
    Domain3	sql.NullString
    Override	sql.NullByte
}

// IterateDeviceDnsServer provide access to all rows of the DEVICE_DNS_SERVER matching given criteria.
func IterateDeviceDnsServer(db *sql.DB, where string, callback func(v *DeviceDnsServerRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,DNS1_IP,DNS2_IP,DNS3_IP,DOMAIN1,DOMAIN2,DOMAIN3,OVERRIDE FROM DEVICE_DNS_SERVER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceDnsServerRow
        err := rows.Scan(&r.DeviceShortID, &r.Dns1IP, &r.Dns2IP, &r.Dns3IP, &r.Domain1, &r.Domain2, &r.Domain3, &r.Override)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceDnsServer provide iterator to all rows of the DEVICE_DNS_SERVER matching given criteria.
func RangeDeviceDnsServer(db *sql.DB, where string) iter.Seq2[*DeviceDnsServerRow, error] {
	return func(yield func(v *DeviceDnsServerRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,DNS1_IP,DNS2_IP,DNS3_IP,DOMAIN1,DOMAIN2,DOMAIN3,OVERRIDE FROM DEVICE_DNS_SERVER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceDnsServerRow
	        err := rows.Scan(&r.DeviceShortID, &r.Dns1IP, &r.Dns2IP, &r.Dns3IP, &r.Domain1, &r.Domain2, &r.Domain3, &r.Override)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceFilterSettingsRow struct represents rows of the DEVICE_FILTER_SETTINGS table.
type DeviceFilterSettingsRow struct {
    DeviceID	string
    SegmentID	string
    ActionRecommend	sql.NullInt32
    ActionBlock	sql.NullInt32
    ActionReset	sql.NullInt32
    ActionPermit	sql.NullInt32
    ActionRatelimit	sql.NullInt32
    StateEnabled	sql.NullInt32
    StateDisabled	sql.NullInt32
    ContolCat	sql.NullInt32
    ControlFilter	sql.NullInt32
    ExceptionsWith	sql.NullInt32
    ContactsEmail	sql.NullInt32
    ContactsRsyslog	sql.NullInt32
    ContactsSnmp	sql.NullInt32
    ContactsMgmtConsole	sql.NullInt32
    ContactsNone	sql.NullInt32
    AfcOn	sql.NullInt32
    AfcOff	sql.NullInt32
    OverridesTotal	sql.NullInt32
    UpdateTime	int64
}

// IterateDeviceFilterSettings provide access to all rows of the DEVICE_FILTER_SETTINGS matching given criteria.
func IterateDeviceFilterSettings(db *sql.DB, where string, callback func(v *DeviceFilterSettingsRow) error) error {
    query := "SELECT DEVICE_ID,SEGMENT_ID,ACTION_RECOMMEND,ACTION_BLOCK,ACTION_RESET,ACTION_PERMIT,ACTION_RATELIMIT,STATE_ENABLED,STATE_DISABLED,CONTOL_CAT,CONTROL_FILTER,EXCEPTIONS_WITH,CONTACTS_EMAIL,CONTACTS_RSYSLOG,CONTACTS_SNMP,CONTACTS_MGMT_CONSOLE,CONTACTS_NONE,AFC_ON,AFC_OFF,OVERRIDES_TOTAL,UPDATE_TIME FROM DEVICE_FILTER_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceFilterSettingsRow
        err := rows.Scan(&r.DeviceID, &r.SegmentID, &r.ActionRecommend, &r.ActionBlock, &r.ActionReset, &r.ActionPermit, &r.ActionRatelimit, &r.StateEnabled, &r.StateDisabled, &r.ContolCat, &r.ControlFilter, &r.ExceptionsWith, &r.ContactsEmail, &r.ContactsRsyslog, &r.ContactsSnmp, &r.ContactsMgmtConsole, &r.ContactsNone, &r.AfcOn, &r.AfcOff, &r.OverridesTotal, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceFilterSettings provide iterator to all rows of the DEVICE_FILTER_SETTINGS matching given criteria.
func RangeDeviceFilterSettings(db *sql.DB, where string) iter.Seq2[*DeviceFilterSettingsRow, error] {
	return func(yield func(v *DeviceFilterSettingsRow, err error) bool) {
	    query := "SELECT DEVICE_ID,SEGMENT_ID,ACTION_RECOMMEND,ACTION_BLOCK,ACTION_RESET,ACTION_PERMIT,ACTION_RATELIMIT,STATE_ENABLED,STATE_DISABLED,CONTOL_CAT,CONTROL_FILTER,EXCEPTIONS_WITH,CONTACTS_EMAIL,CONTACTS_RSYSLOG,CONTACTS_SNMP,CONTACTS_MGMT_CONSOLE,CONTACTS_NONE,AFC_ON,AFC_OFF,OVERRIDES_TOTAL,UPDATE_TIME FROM DEVICE_FILTER_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceFilterSettingsRow
	        err := rows.Scan(&r.DeviceID, &r.SegmentID, &r.ActionRecommend, &r.ActionBlock, &r.ActionReset, &r.ActionPermit, &r.ActionRatelimit, &r.StateEnabled, &r.StateDisabled, &r.ContolCat, &r.ControlFilter, &r.ExceptionsWith, &r.ContactsEmail, &r.ContactsRsyslog, &r.ContactsSnmp, &r.ContactsMgmtConsole, &r.ContactsNone, &r.AfcOn, &r.AfcOff, &r.OverridesTotal, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceFirewallRuleRow struct represents rows of the DEVICE_FIREWALL_RULE table.
type DeviceFirewallRuleRow struct {
    ID	uint
    FirewallRuleID	sql.NullInt32
    DeviceShortID	sql.NullInt32
    Precedence	sql.NullInt16
    SrcZoneID	sql.NullInt32
    DestZoneID	sql.NullInt32
    ServiceID	sql.NullInt32
    ServiceGroupID	sql.NullInt32
    Enabled	sql.NullByte
    Logging	sql.NullByte
    RemoteLogging	sql.NullByte
    InactiveTimeout	sql.NullInt32
    Action	sql.NullByte
    BandwidthMgmtEnabled	sql.NullByte
    BandwidthMgmtPerRule	sql.NullByte
    BandwidthMgmtGuaranteed	sql.NullInt32
    BandwidthMgmtMaximum	sql.NullInt32
    BandwidthMgmtPriority	sql.NullInt16
    UserAuthEnabled	sql.NullByte
    SingleGroup	sql.NullByte
    PrivilegeGroupID	sql.NullInt32
    ScheduleID	sql.NullInt32
    SrcIPAddrType	sql.NullByte
    SrcNamedIPGroupID	sql.NullInt32
    SrcIPAddr1	sql.NullInt32
    SrcIPAddr2	sql.NullInt32
    DestIPAddrType	sql.NullByte
    DestNamedIPGroupID	sql.NullInt32
    DestIPAddr1	sql.NullInt32
    DestIPAddr2	sql.NullInt32
    Comments	sql.NullString
}

// IterateDeviceFirewallRule provide access to all rows of the DEVICE_FIREWALL_RULE matching given criteria.
func IterateDeviceFirewallRule(db *sql.DB, where string, callback func(v *DeviceFirewallRuleRow) error) error {
    query := "SELECT ID,FIREWALL_RULE_ID,DEVICE_SHORT_ID,PRECEDENCE,SRC_ZONE_ID,DEST_ZONE_ID,SERVICE_ID,SERVICE_GROUP_ID,ENABLED,LOGGING,REMOTE_LOGGING,INACTIVE_TIMEOUT,ACTION,BANDWIDTH_MGMT_ENABLED,BANDWIDTH_MGMT_PER_RULE,BANDWIDTH_MGMT_GUARANTEED,BANDWIDTH_MGMT_MAXIMUM,BANDWIDTH_MGMT_PRIORITY,USER_AUTH_ENABLED,SINGLE_GROUP,PRIVILEGE_GROUP_ID,SCHEDULE_ID,SRC_IP_ADDR_TYPE,SRC_NAMED_IP_GROUP_ID,SRC_IP_ADDR1,SRC_IP_ADDR2,DEST_IP_ADDR_TYPE,DEST_NAMED_IP_GROUP_ID,DEST_IP_ADDR1,DEST_IP_ADDR2,COMMENTS FROM DEVICE_FIREWALL_RULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceFirewallRuleRow
        err := rows.Scan(&r.ID, &r.FirewallRuleID, &r.DeviceShortID, &r.Precedence, &r.SrcZoneID, &r.DestZoneID, &r.ServiceID, &r.ServiceGroupID, &r.Enabled, &r.Logging, &r.RemoteLogging, &r.InactiveTimeout, &r.Action, &r.BandwidthMgmtEnabled, &r.BandwidthMgmtPerRule, &r.BandwidthMgmtGuaranteed, &r.BandwidthMgmtMaximum, &r.BandwidthMgmtPriority, &r.UserAuthEnabled, &r.SingleGroup, &r.PrivilegeGroupID, &r.ScheduleID, &r.SrcIPAddrType, &r.SrcNamedIPGroupID, &r.SrcIPAddr1, &r.SrcIPAddr2, &r.DestIPAddrType, &r.DestNamedIPGroupID, &r.DestIPAddr1, &r.DestIPAddr2, &r.Comments)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceFirewallRule provide iterator to all rows of the DEVICE_FIREWALL_RULE matching given criteria.
func RangeDeviceFirewallRule(db *sql.DB, where string) iter.Seq2[*DeviceFirewallRuleRow, error] {
	return func(yield func(v *DeviceFirewallRuleRow, err error) bool) {
	    query := "SELECT ID,FIREWALL_RULE_ID,DEVICE_SHORT_ID,PRECEDENCE,SRC_ZONE_ID,DEST_ZONE_ID,SERVICE_ID,SERVICE_GROUP_ID,ENABLED,LOGGING,REMOTE_LOGGING,INACTIVE_TIMEOUT,ACTION,BANDWIDTH_MGMT_ENABLED,BANDWIDTH_MGMT_PER_RULE,BANDWIDTH_MGMT_GUARANTEED,BANDWIDTH_MGMT_MAXIMUM,BANDWIDTH_MGMT_PRIORITY,USER_AUTH_ENABLED,SINGLE_GROUP,PRIVILEGE_GROUP_ID,SCHEDULE_ID,SRC_IP_ADDR_TYPE,SRC_NAMED_IP_GROUP_ID,SRC_IP_ADDR1,SRC_IP_ADDR2,DEST_IP_ADDR_TYPE,DEST_NAMED_IP_GROUP_ID,DEST_IP_ADDR1,DEST_IP_ADDR2,COMMENTS FROM DEVICE_FIREWALL_RULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceFirewallRuleRow
	        err := rows.Scan(&r.ID, &r.FirewallRuleID, &r.DeviceShortID, &r.Precedence, &r.SrcZoneID, &r.DestZoneID, &r.ServiceID, &r.ServiceGroupID, &r.Enabled, &r.Logging, &r.RemoteLogging, &r.InactiveTimeout, &r.Action, &r.BandwidthMgmtEnabled, &r.BandwidthMgmtPerRule, &r.BandwidthMgmtGuaranteed, &r.BandwidthMgmtMaximum, &r.BandwidthMgmtPriority, &r.UserAuthEnabled, &r.SingleGroup, &r.PrivilegeGroupID, &r.ScheduleID, &r.SrcIPAddrType, &r.SrcNamedIPGroupID, &r.SrcIPAddr1, &r.SrcIPAddr2, &r.DestIPAddrType, &r.DestNamedIPGroupID, &r.DestIPAddr1, &r.DestIPAddr2, &r.Comments)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceFlowRow struct represents rows of the DEVICE_FLOW table.
type DeviceFlowRow struct {
    DeviceShortID	uint
    Port	uint
    IPNamedObjID	int
}

// IterateDeviceFlow provide access to all rows of the DEVICE_FLOW matching given criteria.
func IterateDeviceFlow(db *sql.DB, where string, callback func(v *DeviceFlowRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,PORT,IP_NAMED_OBJ_ID FROM DEVICE_FLOW"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceFlowRow
        err := rows.Scan(&r.DeviceShortID, &r.Port, &r.IPNamedObjID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceFlow provide iterator to all rows of the DEVICE_FLOW matching given criteria.
func RangeDeviceFlow(db *sql.DB, where string) iter.Seq2[*DeviceFlowRow, error] {
	return func(yield func(v *DeviceFlowRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,PORT,IP_NAMED_OBJ_ID FROM DEVICE_FLOW"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceFlowRow
	        err := rows.Scan(&r.DeviceShortID, &r.Port, &r.IPNamedObjID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceGroupRow struct represents rows of the DEVICE_GROUP table.
type DeviceGroupRow struct {
    ID	uint
    Name	sql.NullString
    ParentGroupID	sql.NullInt32
    DeviceGroupClass	sql.NullString
    SegmentDeviceID	sql.NullInt32
    StackRedundancy	sql.NullInt32
}

// IterateDeviceGroup provide access to all rows of the DEVICE_GROUP matching given criteria.
func IterateDeviceGroup(db *sql.DB, where string, callback func(v *DeviceGroupRow) error) error {
    query := "SELECT ID,NAME,PARENT_GROUP_ID,DEVICE_GROUP_CLASS,SEGMENT_DEVICE_ID,STACK_REDUNDANCY FROM DEVICE_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceGroupRow
        err := rows.Scan(&r.ID, &r.Name, &r.ParentGroupID, &r.DeviceGroupClass, &r.SegmentDeviceID, &r.StackRedundancy)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceGroup provide iterator to all rows of the DEVICE_GROUP matching given criteria.
func RangeDeviceGroup(db *sql.DB, where string) iter.Seq2[*DeviceGroupRow, error] {
	return func(yield func(v *DeviceGroupRow, err error) bool) {
	    query := "SELECT ID,NAME,PARENT_GROUP_ID,DEVICE_GROUP_CLASS,SEGMENT_DEVICE_ID,STACK_REDUNDANCY FROM DEVICE_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceGroupRow
	        err := rows.Scan(&r.ID, &r.Name, &r.ParentGroupID, &r.DeviceGroupClass, &r.SegmentDeviceID, &r.StackRedundancy)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceHaConfigRow struct represents rows of the DEVICE_HA_CONFIG table.
type DeviceHaConfigRow struct {
    DeviceShortID	uint
    HaEnabled	sql.NullByte
    PollInterval	sql.NullInt32
    Timeout	sql.NullInt32
    RetryCount	sql.NullInt32
    HaID	sql.NullString
    Active	sql.NullByte
}

// IterateDeviceHaConfig provide access to all rows of the DEVICE_HA_CONFIG matching given criteria.
func IterateDeviceHaConfig(db *sql.DB, where string, callback func(v *DeviceHaConfigRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,HA_ENABLED,POLL_INTERVAL,TIMEOUT,RETRY_COUNT,HA_ID,ACTIVE FROM DEVICE_HA_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceHaConfigRow
        err := rows.Scan(&r.DeviceShortID, &r.HaEnabled, &r.PollInterval, &r.Timeout, &r.RetryCount, &r.HaID, &r.Active)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceHaConfig provide iterator to all rows of the DEVICE_HA_CONFIG matching given criteria.
func RangeDeviceHaConfig(db *sql.DB, where string) iter.Seq2[*DeviceHaConfigRow, error] {
	return func(yield func(v *DeviceHaConfigRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,HA_ENABLED,POLL_INTERVAL,TIMEOUT,RETRY_COUNT,HA_ID,ACTIVE FROM DEVICE_HA_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceHaConfigRow
	        err := rows.Scan(&r.DeviceShortID, &r.HaEnabled, &r.PollInterval, &r.Timeout, &r.RetryCount, &r.HaID, &r.Active)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceHostIPFilterRow struct represents rows of the DEVICE_HOST_IP_FILTER table.
type DeviceHostIPFilterRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    DeviceFilterNumber	sql.NullInt32
    RuleType	sql.NullInt32
    TargetType	sql.NullInt32
    ProtoType	sql.NullInt32
    FilterNetmask	sql.NullString
    FilterIPNamedObjID	sql.NullInt32
}

// IterateDeviceHostIPFilter provide access to all rows of the DEVICE_HOST_IP_FILTER matching given criteria.
func IterateDeviceHostIPFilter(db *sql.DB, where string, callback func(v *DeviceHostIPFilterRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,DEVICE_FILTER_NUMBER,RULE_TYPE,TARGET_TYPE,PROTO_TYPE,FILTER_NETMASK,FILTER_IP_NAMED_OBJ_ID FROM DEVICE_HOST_IP_FILTER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceHostIPFilterRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.DeviceFilterNumber, &r.RuleType, &r.TargetType, &r.ProtoType, &r.FilterNetmask, &r.FilterIPNamedObjID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceHostIPFilter provide iterator to all rows of the DEVICE_HOST_IP_FILTER matching given criteria.
func RangeDeviceHostIPFilter(db *sql.DB, where string) iter.Seq2[*DeviceHostIPFilterRow, error] {
	return func(yield func(v *DeviceHostIPFilterRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,DEVICE_FILTER_NUMBER,RULE_TYPE,TARGET_TYPE,PROTO_TYPE,FILTER_NETMASK,FILTER_IP_NAMED_OBJ_ID FROM DEVICE_HOST_IP_FILTER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceHostIPFilterRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.DeviceFilterNumber, &r.RuleType, &r.TargetType, &r.ProtoType, &r.FilterNetmask, &r.FilterIPNamedObjID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceIdentityAgentConfigRow struct represents rows of the DEVICE_IDENTITY_AGENT_CONFIG table.
type DeviceIdentityAgentConfigRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    SessionResyncInterval	sql.NullInt32
    SessionUpdateInterval	sql.NullInt32
    SessionTimeout	sql.NullInt32
    GroupTimeout	sql.NullInt32
    GroupResyncInterval	sql.NullInt32
}

// IterateDeviceIdentityAgentConfig provide access to all rows of the DEVICE_IDENTITY_AGENT_CONFIG matching given criteria.
func IterateDeviceIdentityAgentConfig(db *sql.DB, where string, callback func(v *DeviceIdentityAgentConfigRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,SESSION_RESYNC_INTERVAL,SESSION_UPDATE_INTERVAL,SESSION_TIMEOUT,GROUP_TIMEOUT,GROUP_RESYNC_INTERVAL FROM DEVICE_IDENTITY_AGENT_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceIdentityAgentConfigRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.SessionResyncInterval, &r.SessionUpdateInterval, &r.SessionTimeout, &r.GroupTimeout, &r.GroupResyncInterval)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceIdentityAgentConfig provide iterator to all rows of the DEVICE_IDENTITY_AGENT_CONFIG matching given criteria.
func RangeDeviceIdentityAgentConfig(db *sql.DB, where string) iter.Seq2[*DeviceIdentityAgentConfigRow, error] {
	return func(yield func(v *DeviceIdentityAgentConfigRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,SESSION_RESYNC_INTERVAL,SESSION_UPDATE_INTERVAL,SESSION_TIMEOUT,GROUP_TIMEOUT,GROUP_RESYNC_INTERVAL FROM DEVICE_IDENTITY_AGENT_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceIdentityAgentConfigRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.SessionResyncInterval, &r.SessionUpdateInterval, &r.SessionTimeout, &r.GroupTimeout, &r.GroupResyncInterval)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceIdentityAgentGroupRow struct represents rows of the DEVICE_IDENTITY_AGENT_GROUP table.
type DeviceIdentityAgentGroupRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    State	int8
    Uuid	string
    AgentGroup	uint
}

// IterateDeviceIdentityAgentGroup provide access to all rows of the DEVICE_IDENTITY_AGENT_GROUP matching given criteria.
func IterateDeviceIdentityAgentGroup(db *sql.DB, where string, callback func(v *DeviceIdentityAgentGroupRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,STATE,UUID,AGENT_GROUP FROM DEVICE_IDENTITY_AGENT_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceIdentityAgentGroupRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.State, &r.Uuid, &r.AgentGroup)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceIdentityAgentGroup provide iterator to all rows of the DEVICE_IDENTITY_AGENT_GROUP matching given criteria.
func RangeDeviceIdentityAgentGroup(db *sql.DB, where string) iter.Seq2[*DeviceIdentityAgentGroupRow, error] {
	return func(yield func(v *DeviceIdentityAgentGroupRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,STATE,UUID,AGENT_GROUP FROM DEVICE_IDENTITY_AGENT_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceIdentityAgentGroupRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.State, &r.Uuid, &r.AgentGroup)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceImportPackageRow struct represents rows of the DEVICE_IMPORT_PACKAGE table.
type DeviceImportPackageRow struct {
    PkgIndex	int
    DeviceID	string
    ImportType	int
    PkgType	int
    PkgID	string
    PkgVersion	sql.NullString
    ImportTime	sql.NullInt64
}

// IterateDeviceImportPackage provide access to all rows of the DEVICE_IMPORT_PACKAGE matching given criteria.
func IterateDeviceImportPackage(db *sql.DB, where string, callback func(v *DeviceImportPackageRow) error) error {
    query := "SELECT PKG_INDEX,DEVICE_ID,IMPORT_TYPE,PKG_TYPE,PKG_ID,PKG_VERSION,IMPORT_TIME FROM DEVICE_IMPORT_PACKAGE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceImportPackageRow
        err := rows.Scan(&r.PkgIndex, &r.DeviceID, &r.ImportType, &r.PkgType, &r.PkgID, &r.PkgVersion, &r.ImportTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceImportPackage provide iterator to all rows of the DEVICE_IMPORT_PACKAGE matching given criteria.
func RangeDeviceImportPackage(db *sql.DB, where string) iter.Seq2[*DeviceImportPackageRow, error] {
	return func(yield func(v *DeviceImportPackageRow, err error) bool) {
	    query := "SELECT PKG_INDEX,DEVICE_ID,IMPORT_TYPE,PKG_TYPE,PKG_ID,PKG_VERSION,IMPORT_TIME FROM DEVICE_IMPORT_PACKAGE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceImportPackageRow
	        err := rows.Scan(&r.PkgIndex, &r.DeviceID, &r.ImportType, &r.PkgType, &r.PkgID, &r.PkgVersion, &r.ImportTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceImportSecurityPkgRow struct represents rows of the DEVICE_IMPORT_SECURITY_PKG table.
type DeviceImportSecurityPkgRow struct {
    PkgIndex	int
    DeviceID	string
    PkgImportTime	sql.NullInt64
    SigPkgVersion	sql.NullString
    SigPkgFile	sql.NullString
    SecPkgVersion	sql.NullString
    SecPkgFile	sql.NullString
}

// IterateDeviceImportSecurityPkg provide access to all rows of the DEVICE_IMPORT_SECURITY_PKG matching given criteria.
func IterateDeviceImportSecurityPkg(db *sql.DB, where string, callback func(v *DeviceImportSecurityPkgRow) error) error {
    query := "SELECT PKG_INDEX,DEVICE_ID,PKG_IMPORT_TIME,SIG_PKG_VERSION,SIG_PKG_FILE,SEC_PKG_VERSION,SEC_PKG_FILE FROM DEVICE_IMPORT_SECURITY_PKG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceImportSecurityPkgRow
        err := rows.Scan(&r.PkgIndex, &r.DeviceID, &r.PkgImportTime, &r.SigPkgVersion, &r.SigPkgFile, &r.SecPkgVersion, &r.SecPkgFile)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceImportSecurityPkg provide iterator to all rows of the DEVICE_IMPORT_SECURITY_PKG matching given criteria.
func RangeDeviceImportSecurityPkg(db *sql.DB, where string) iter.Seq2[*DeviceImportSecurityPkgRow, error] {
	return func(yield func(v *DeviceImportSecurityPkgRow, err error) bool) {
	    query := "SELECT PKG_INDEX,DEVICE_ID,PKG_IMPORT_TIME,SIG_PKG_VERSION,SIG_PKG_FILE,SEC_PKG_VERSION,SEC_PKG_FILE FROM DEVICE_IMPORT_SECURITY_PKG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceImportSecurityPkgRow
	        err := rows.Scan(&r.PkgIndex, &r.DeviceID, &r.PkgImportTime, &r.SigPkgVersion, &r.SigPkgFile, &r.SecPkgVersion, &r.SecPkgFile)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceInspectionBypassRuleRow struct represents rows of the DEVICE_INSPECTION_BYPASS_RULE table.
type DeviceInspectionBypassRuleRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    RuleName	sql.NullString
    RuleID	sql.NullInt32
    RuleEnabled	sql.NullByte
    RuleStatsTimestamp	sql.NullInt64
    RuleStats	sql.NullInt64
    EthRuleType	sql.NullInt16
    EthValue	sql.NullInt32
    PortsRuleType	sql.NullInt16
    GreRuleType	sql.NullInt16
    Mipv4RuleType	sql.NullInt16
    Ipv6in4RuleType	sql.NullInt16
    VLANRuleType	sql.NullInt16
    VLANNamedObjID	sql.NullInt32
    MplsRuleType	sql.NullInt16
    MplsValue	sql.NullInt32
    MplsRangeMin	sql.NullInt32
    MplsRangeMax	sql.NullInt32
    IPProtoRuleType	sql.NullInt16
    IPProtoValue	sql.NullInt32
    IPSrcRuleType	sql.NullInt16
    IPSrcNamedObjID	sql.NullInt32
    IPDstRuleType	sql.NullInt16
    IPDstNamedObjID	sql.NullInt32
    UdpSrcPortRuleType	sql.NullInt16
    UdpSrcPortValue	sql.NullInt32
    UdpSrcPortRangeMin	sql.NullInt32
    UdpSrcPortRangeMax	sql.NullInt32
    UdpDstPortRuleType	sql.NullInt16
    UdpDstPortValue	sql.NullInt32
    UdpDstPortRangeMin	sql.NullInt32
    UdpDstPortRangeMax	sql.NullInt32
    TcpSrcPortRuleType	sql.NullInt16
    TcpSrcPortValue	sql.NullInt32
    TcpSrcPortRangeMin	sql.NullInt32
    TcpSrcPortRangeMax	sql.NullInt32
    TcpDstPortRuleType	sql.NullInt16
    TcpDstPortValue	sql.NullInt32
    TcpDstPortRangeMin	sql.NullInt32
    TcpDstPortRangeMax	sql.NullInt32
    RuleKey	sql.NullInt32
    RuleAction	sql.NullInt16
    ActionTargetPort	sql.NullInt16
    ActionTargetPortType	sql.NullString
}

// IterateDeviceInspectionBypassRule provide access to all rows of the DEVICE_INSPECTION_BYPASS_RULE matching given criteria.
func IterateDeviceInspectionBypassRule(db *sql.DB, where string, callback func(v *DeviceInspectionBypassRuleRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,RULE_NAME,RULE_ID,RULE_ENABLED,RULE_STATS_TIMESTAMP,RULE_STATS,ETH_RULE_TYPE,ETH_VALUE,PORTS_RULE_TYPE,GRE_RULE_TYPE,MIPV4_RULE_TYPE,IPV6IN4_RULE_TYPE,VLAN_RULE_TYPE,VLAN_NAMED_OBJ_ID,MPLS_RULE_TYPE,MPLS_VALUE,MPLS_RANGE_MIN,MPLS_RANGE_MAX,IP_PROTO_RULE_TYPE,IP_PROTO_VALUE,IP_SRC_RULE_TYPE,IP_SRC_NAMED_OBJ_ID,IP_DST_RULE_TYPE,IP_DST_NAMED_OBJ_ID,UDP_SRC_PORT_RULE_TYPE,UDP_SRC_PORT_VALUE,UDP_SRC_PORT_RANGE_MIN,UDP_SRC_PORT_RANGE_MAX,UDP_DST_PORT_RULE_TYPE,UDP_DST_PORT_VALUE,UDP_DST_PORT_RANGE_MIN,UDP_DST_PORT_RANGE_MAX,TCP_SRC_PORT_RULE_TYPE,TCP_SRC_PORT_VALUE,TCP_SRC_PORT_RANGE_MIN,TCP_SRC_PORT_RANGE_MAX,TCP_DST_PORT_RULE_TYPE,TCP_DST_PORT_VALUE,TCP_DST_PORT_RANGE_MIN,TCP_DST_PORT_RANGE_MAX,RULE_KEY,RULE_ACTION,ACTION_TARGET_PORT,ACTION_TARGET_PORT_TYPE FROM DEVICE_INSPECTION_BYPASS_RULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceInspectionBypassRuleRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.RuleName, &r.RuleID, &r.RuleEnabled, &r.RuleStatsTimestamp, &r.RuleStats, &r.EthRuleType, &r.EthValue, &r.PortsRuleType, &r.GreRuleType, &r.Mipv4RuleType, &r.Ipv6in4RuleType, &r.VLANRuleType, &r.VLANNamedObjID, &r.MplsRuleType, &r.MplsValue, &r.MplsRangeMin, &r.MplsRangeMax, &r.IPProtoRuleType, &r.IPProtoValue, &r.IPSrcRuleType, &r.IPSrcNamedObjID, &r.IPDstRuleType, &r.IPDstNamedObjID, &r.UdpSrcPortRuleType, &r.UdpSrcPortValue, &r.UdpSrcPortRangeMin, &r.UdpSrcPortRangeMax, &r.UdpDstPortRuleType, &r.UdpDstPortValue, &r.UdpDstPortRangeMin, &r.UdpDstPortRangeMax, &r.TcpSrcPortRuleType, &r.TcpSrcPortValue, &r.TcpSrcPortRangeMin, &r.TcpSrcPortRangeMax, &r.TcpDstPortRuleType, &r.TcpDstPortValue, &r.TcpDstPortRangeMin, &r.TcpDstPortRangeMax, &r.RuleKey, &r.RuleAction, &r.ActionTargetPort, &r.ActionTargetPortType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceInspectionBypassRule provide iterator to all rows of the DEVICE_INSPECTION_BYPASS_RULE matching given criteria.
func RangeDeviceInspectionBypassRule(db *sql.DB, where string) iter.Seq2[*DeviceInspectionBypassRuleRow, error] {
	return func(yield func(v *DeviceInspectionBypassRuleRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,RULE_NAME,RULE_ID,RULE_ENABLED,RULE_STATS_TIMESTAMP,RULE_STATS,ETH_RULE_TYPE,ETH_VALUE,PORTS_RULE_TYPE,GRE_RULE_TYPE,MIPV4_RULE_TYPE,IPV6IN4_RULE_TYPE,VLAN_RULE_TYPE,VLAN_NAMED_OBJ_ID,MPLS_RULE_TYPE,MPLS_VALUE,MPLS_RANGE_MIN,MPLS_RANGE_MAX,IP_PROTO_RULE_TYPE,IP_PROTO_VALUE,IP_SRC_RULE_TYPE,IP_SRC_NAMED_OBJ_ID,IP_DST_RULE_TYPE,IP_DST_NAMED_OBJ_ID,UDP_SRC_PORT_RULE_TYPE,UDP_SRC_PORT_VALUE,UDP_SRC_PORT_RANGE_MIN,UDP_SRC_PORT_RANGE_MAX,UDP_DST_PORT_RULE_TYPE,UDP_DST_PORT_VALUE,UDP_DST_PORT_RANGE_MIN,UDP_DST_PORT_RANGE_MAX,TCP_SRC_PORT_RULE_TYPE,TCP_SRC_PORT_VALUE,TCP_SRC_PORT_RANGE_MIN,TCP_SRC_PORT_RANGE_MAX,TCP_DST_PORT_RULE_TYPE,TCP_DST_PORT_VALUE,TCP_DST_PORT_RANGE_MIN,TCP_DST_PORT_RANGE_MAX,RULE_KEY,RULE_ACTION,ACTION_TARGET_PORT,ACTION_TARGET_PORT_TYPE FROM DEVICE_INSPECTION_BYPASS_RULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceInspectionBypassRuleRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.RuleName, &r.RuleID, &r.RuleEnabled, &r.RuleStatsTimestamp, &r.RuleStats, &r.EthRuleType, &r.EthValue, &r.PortsRuleType, &r.GreRuleType, &r.Mipv4RuleType, &r.Ipv6in4RuleType, &r.VLANRuleType, &r.VLANNamedObjID, &r.MplsRuleType, &r.MplsValue, &r.MplsRangeMin, &r.MplsRangeMax, &r.IPProtoRuleType, &r.IPProtoValue, &r.IPSrcRuleType, &r.IPSrcNamedObjID, &r.IPDstRuleType, &r.IPDstNamedObjID, &r.UdpSrcPortRuleType, &r.UdpSrcPortValue, &r.UdpSrcPortRangeMin, &r.UdpSrcPortRangeMax, &r.UdpDstPortRuleType, &r.UdpDstPortValue, &r.UdpDstPortRangeMin, &r.UdpDstPortRangeMax, &r.TcpSrcPortRuleType, &r.TcpSrcPortValue, &r.TcpSrcPortRangeMin, &r.TcpSrcPortRangeMax, &r.TcpDstPortRuleType, &r.TcpDstPortValue, &r.TcpDstPortRangeMin, &r.TcpDstPortRangeMax, &r.RuleKey, &r.RuleAction, &r.ActionTargetPort, &r.ActionTargetPortType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceInspectionBypassRuleTptPortRow struct represents rows of the DEVICE_INSPECTION_BYPASS_RULE_TPT_PORT table.
type DeviceInspectionBypassRuleTptPortRow struct {
    DeviceInspectionBypassRuleID	uint
    TptPortID	string
}

// IterateDeviceInspectionBypassRuleTptPort provide access to all rows of the DEVICE_INSPECTION_BYPASS_RULE_TPT_PORT matching given criteria.
func IterateDeviceInspectionBypassRuleTptPort(db *sql.DB, where string, callback func(v *DeviceInspectionBypassRuleTptPortRow) error) error {
    query := "SELECT DEVICE_INSPECTION_BYPASS_RULE_ID,TPT_PORT_ID FROM DEVICE_INSPECTION_BYPASS_RULE_TPT_PORT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceInspectionBypassRuleTptPortRow
        err := rows.Scan(&r.DeviceInspectionBypassRuleID, &r.TptPortID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceInspectionBypassRuleTptPort provide iterator to all rows of the DEVICE_INSPECTION_BYPASS_RULE_TPT_PORT matching given criteria.
func RangeDeviceInspectionBypassRuleTptPort(db *sql.DB, where string) iter.Seq2[*DeviceInspectionBypassRuleTptPortRow, error] {
	return func(yield func(v *DeviceInspectionBypassRuleTptPortRow, err error) bool) {
	    query := "SELECT DEVICE_INSPECTION_BYPASS_RULE_ID,TPT_PORT_ID FROM DEVICE_INSPECTION_BYPASS_RULE_TPT_PORT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceInspectionBypassRuleTptPortRow
	        err := rows.Scan(&r.DeviceInspectionBypassRuleID, &r.TptPortID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceIpv6ConfigAddressRow struct represents rows of the DEVICE_IPV6_CONFIG_ADDRESS table.
type DeviceIpv6ConfigAddressRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    IPAddress	sql.NullString
    AddressType	sql.NullInt16
}

// IterateDeviceIpv6ConfigAddress provide access to all rows of the DEVICE_IPV6_CONFIG_ADDRESS matching given criteria.
func IterateDeviceIpv6ConfigAddress(db *sql.DB, where string, callback func(v *DeviceIpv6ConfigAddressRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,IP_ADDRESS,ADDRESS_TYPE FROM DEVICE_IPV6_CONFIG_ADDRESS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceIpv6ConfigAddressRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.IPAddress, &r.AddressType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceIpv6ConfigAddress provide iterator to all rows of the DEVICE_IPV6_CONFIG_ADDRESS matching given criteria.
func RangeDeviceIpv6ConfigAddress(db *sql.DB, where string) iter.Seq2[*DeviceIpv6ConfigAddressRow, error] {
	return func(yield func(v *DeviceIpv6ConfigAddressRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,IP_ADDRESS,ADDRESS_TYPE FROM DEVICE_IPV6_CONFIG_ADDRESS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceIpv6ConfigAddressRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.IPAddress, &r.AddressType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceLocalUserRow struct represents rows of the DEVICE_LOCAL_USER table.
type DeviceLocalUserRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    PrivilegeGroupID	sql.NullInt32
    Name	sql.NullString
    Password	sql.NullString
}

// IterateDeviceLocalUser provide access to all rows of the DEVICE_LOCAL_USER matching given criteria.
func IterateDeviceLocalUser(db *sql.DB, where string, callback func(v *DeviceLocalUserRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,PRIVILEGE_GROUP_ID,NAME,PASSWORD FROM DEVICE_LOCAL_USER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceLocalUserRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.PrivilegeGroupID, &r.Name, &r.Password)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceLocalUser provide iterator to all rows of the DEVICE_LOCAL_USER matching given criteria.
func RangeDeviceLocalUser(db *sql.DB, where string) iter.Seq2[*DeviceLocalUserRow, error] {
	return func(yield func(v *DeviceLocalUserRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,PRIVILEGE_GROUP_ID,NAME,PASSWORD FROM DEVICE_LOCAL_USER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceLocalUserRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.PrivilegeGroupID, &r.Name, &r.Password)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceLogRemoteSyslogRow struct represents rows of the DEVICE_LOG_REMOTE_SYSLOG table.
type DeviceLogRemoteSyslogRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    LogType	sql.NullInt16
    Port	sql.NullInt32
    Locale	sql.NullString
    Facility	sql.NullString
    ServerNamedObjID	sql.NullInt32
}

// IterateDeviceLogRemoteSyslog provide access to all rows of the DEVICE_LOG_REMOTE_SYSLOG matching given criteria.
func IterateDeviceLogRemoteSyslog(db *sql.DB, where string, callback func(v *DeviceLogRemoteSyslogRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,LOG_TYPE,PORT,LOCALE,FACILITY,SERVER_NAMED_OBJ_ID FROM DEVICE_LOG_REMOTE_SYSLOG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceLogRemoteSyslogRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.LogType, &r.Port, &r.Locale, &r.Facility, &r.ServerNamedObjID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceLogRemoteSyslog provide iterator to all rows of the DEVICE_LOG_REMOTE_SYSLOG matching given criteria.
func RangeDeviceLogRemoteSyslog(db *sql.DB, where string) iter.Seq2[*DeviceLogRemoteSyslogRow, error] {
	return func(yield func(v *DeviceLogRemoteSyslogRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,LOG_TYPE,PORT,LOCALE,FACILITY,SERVER_NAMED_OBJ_ID FROM DEVICE_LOG_REMOTE_SYSLOG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceLogRemoteSyslogRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.LogType, &r.Port, &r.Locale, &r.Facility, &r.ServerNamedObjID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceNmsTrapDestinationRow struct represents rows of the DEVICE_NMS_TRAP_DESTINATION table.
type DeviceNmsTrapDestinationRow struct {
    DeviceShortID	uint
    IP	string
    Port	int
    IPNamedObjID	sql.NullInt32
    SnmpVersion	int16
    PrivacyProtocol	sql.NullInt16
    SecureUser	sql.NullString
    EngineID	sql.NullString
    HashedPassword	sql.NullString
}

// IterateDeviceNmsTrapDestination provide access to all rows of the DEVICE_NMS_TRAP_DESTINATION matching given criteria.
func IterateDeviceNmsTrapDestination(db *sql.DB, where string, callback func(v *DeviceNmsTrapDestinationRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,IP,PORT,IP_NAMED_OBJ_ID,SNMP_VERSION,PRIVACY_PROTOCOL,SECURE_USER,ENGINE_ID,HASHED_PASSWORD FROM DEVICE_NMS_TRAP_DESTINATION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceNmsTrapDestinationRow
        err := rows.Scan(&r.DeviceShortID, &r.IP, &r.Port, &r.IPNamedObjID, &r.SnmpVersion, &r.PrivacyProtocol, &r.SecureUser, &r.EngineID, &r.HashedPassword)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceNmsTrapDestination provide iterator to all rows of the DEVICE_NMS_TRAP_DESTINATION matching given criteria.
func RangeDeviceNmsTrapDestination(db *sql.DB, where string) iter.Seq2[*DeviceNmsTrapDestinationRow, error] {
	return func(yield func(v *DeviceNmsTrapDestinationRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,IP,PORT,IP_NAMED_OBJ_ID,SNMP_VERSION,PRIVACY_PROTOCOL,SECURE_USER,ENGINE_ID,HASHED_PASSWORD FROM DEVICE_NMS_TRAP_DESTINATION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceNmsTrapDestinationRow
	        err := rows.Scan(&r.DeviceShortID, &r.IP, &r.Port, &r.IPNamedObjID, &r.SnmpVersion, &r.PrivacyProtocol, &r.SecureUser, &r.EngineID, &r.HashedPassword)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DevicePacketCaptureRow struct represents rows of the DEVICE_PACKET_CAPTURE table.
type DevicePacketCaptureRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    Filename	string
    SmsFile	sql.NullString
    VirtualSegementID	sql.NullInt32
    DeviceTime	sql.NullInt64
    MaxSize	sql.NullInt32
    MaxPackets	sql.NullInt32
    Size	sql.NullInt32
    Packets	sql.NullInt32
    StatsTimestamp	sql.NullInt64
    InProgress	sql.NullByte
    CaptureLoc	sql.NullByte
    Expression	sql.NullString
    UseAllSegments	sql.NullByte
    InterfaceName	sql.NullString
}

// IterateDevicePacketCapture provide access to all rows of the DEVICE_PACKET_CAPTURE matching given criteria.
func IterateDevicePacketCapture(db *sql.DB, where string, callback func(v *DevicePacketCaptureRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,FILENAME,SMS_FILE,VIRTUAL_SEGEMENT_ID,DEVICE_TIME,MAX_SIZE,MAX_PACKETS,SIZE,PACKETS,STATS_TIMESTAMP,IN_PROGRESS,CAPTURE_LOC,EXPRESSION,USE_ALL_SEGMENTS,INTERFACE_NAME FROM DEVICE_PACKET_CAPTURE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DevicePacketCaptureRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Filename, &r.SmsFile, &r.VirtualSegementID, &r.DeviceTime, &r.MaxSize, &r.MaxPackets, &r.Size, &r.Packets, &r.StatsTimestamp, &r.InProgress, &r.CaptureLoc, &r.Expression, &r.UseAllSegments, &r.InterfaceName)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDevicePacketCapture provide iterator to all rows of the DEVICE_PACKET_CAPTURE matching given criteria.
func RangeDevicePacketCapture(db *sql.DB, where string) iter.Seq2[*DevicePacketCaptureRow, error] {
	return func(yield func(v *DevicePacketCaptureRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,FILENAME,SMS_FILE,VIRTUAL_SEGEMENT_ID,DEVICE_TIME,MAX_SIZE,MAX_PACKETS,SIZE,PACKETS,STATS_TIMESTAMP,IN_PROGRESS,CAPTURE_LOC,EXPRESSION,USE_ALL_SEGMENTS,INTERFACE_NAME FROM DEVICE_PACKET_CAPTURE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DevicePacketCaptureRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Filename, &r.SmsFile, &r.VirtualSegementID, &r.DeviceTime, &r.MaxSize, &r.MaxPackets, &r.Size, &r.Packets, &r.StatsTimestamp, &r.InProgress, &r.CaptureLoc, &r.Expression, &r.UseAllSegments, &r.InterfaceName)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DevicePkgAuxiliaryDvRow struct represents rows of the DEVICE_PKG_AUXILIARY_DV table.
type DevicePkgAuxiliaryDvRow struct {
    DeviceID	uint
    SubType	string
    Version	sql.NullString
    Distribution	sql.NullInt64
}

// IterateDevicePkgAuxiliaryDv provide access to all rows of the DEVICE_PKG_AUXILIARY_DV matching given criteria.
func IterateDevicePkgAuxiliaryDv(db *sql.DB, where string, callback func(v *DevicePkgAuxiliaryDvRow) error) error {
    query := "SELECT DEVICE_ID,SUB_TYPE,VERSION,DISTRIBUTION FROM DEVICE_PKG_AUXILIARY_DV"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DevicePkgAuxiliaryDvRow
        err := rows.Scan(&r.DeviceID, &r.SubType, &r.Version, &r.Distribution)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDevicePkgAuxiliaryDv provide iterator to all rows of the DEVICE_PKG_AUXILIARY_DV matching given criteria.
func RangeDevicePkgAuxiliaryDv(db *sql.DB, where string) iter.Seq2[*DevicePkgAuxiliaryDvRow, error] {
	return func(yield func(v *DevicePkgAuxiliaryDvRow, err error) bool) {
	    query := "SELECT DEVICE_ID,SUB_TYPE,VERSION,DISTRIBUTION FROM DEVICE_PKG_AUXILIARY_DV"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DevicePkgAuxiliaryDvRow
	        err := rows.Scan(&r.DeviceID, &r.SubType, &r.Version, &r.Distribution)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DevicePkgInstallInventoryRow struct represents rows of the DEVICE_PKG_INSTALL_INVENTORY table.
type DevicePkgInstallInventoryRow struct {
    ID	int
    DeviceUuid	string
    PkgID	string
    PkgVersion	string
    PkgName	sql.NullString
    CompleteTime	int64
}

// IterateDevicePkgInstallInventory provide access to all rows of the DEVICE_PKG_INSTALL_INVENTORY matching given criteria.
func IterateDevicePkgInstallInventory(db *sql.DB, where string, callback func(v *DevicePkgInstallInventoryRow) error) error {
    query := "SELECT ID,DEVICE_UUID,PKG_ID,PKG_VERSION,PKG_NAME,COMPLETE_TIME FROM DEVICE_PKG_INSTALL_INVENTORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DevicePkgInstallInventoryRow
        err := rows.Scan(&r.ID, &r.DeviceUuid, &r.PkgID, &r.PkgVersion, &r.PkgName, &r.CompleteTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDevicePkgInstallInventory provide iterator to all rows of the DEVICE_PKG_INSTALL_INVENTORY matching given criteria.
func RangeDevicePkgInstallInventory(db *sql.DB, where string) iter.Seq2[*DevicePkgInstallInventoryRow, error] {
	return func(yield func(v *DevicePkgInstallInventoryRow, err error) bool) {
	    query := "SELECT ID,DEVICE_UUID,PKG_ID,PKG_VERSION,PKG_NAME,COMPLETE_TIME FROM DEVICE_PKG_INSTALL_INVENTORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DevicePkgInstallInventoryRow
	        err := rows.Scan(&r.ID, &r.DeviceUuid, &r.PkgID, &r.PkgVersion, &r.PkgName, &r.CompleteTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DevicePkgInventoryRow struct represents rows of the DEVICE_PKG_INVENTORY table.
type DevicePkgInventoryRow struct {
    DeviceID	string
    SwVersion	sql.NullString
    SecPkgVersion	sql.NullString
    FilterPkgVersion	sql.NullString
    SwTimestamp	string
    SecPkgTimestamp	string
    FilterPkgTimestamp	string
    SwTime	sql.NullInt64
    SecPkgTime	sql.NullInt64
    FilterPkgTime	sql.NullInt64
    InitSigPkgVersion	sql.NullString
    InitSigPkgFilename	sql.NullString
    InitSecPkgVersion	sql.NullString
    InitSecPkgFilename	sql.NullString
    ProfileIterationID	sql.NullInt32
    DvtPkgID	sql.NullString
    DefaultCaPkgVersion	sql.NullString
    TmufePkgVersion	sql.NullString
}

// IterateDevicePkgInventory provide access to all rows of the DEVICE_PKG_INVENTORY matching given criteria.
func IterateDevicePkgInventory(db *sql.DB, where string, callback func(v *DevicePkgInventoryRow) error) error {
    query := "SELECT DEVICE_ID,SW_VERSION,SEC_PKG_VERSION,FILTER_PKG_VERSION,SW_TIMESTAMP,SEC_PKG_TIMESTAMP,FILTER_PKG_TIMESTAMP,SW_TIME,SEC_PKG_TIME,FILTER_PKG_TIME,INIT_SIG_PKG_VERSION,INIT_SIG_PKG_FILENAME,INIT_SEC_PKG_VERSION,INIT_SEC_PKG_FILENAME,PROFILE_ITERATION_ID,DVT_PKG_ID,DEFAULT_CA_PKG_VERSION,TMUFE_PKG_VERSION FROM DEVICE_PKG_INVENTORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DevicePkgInventoryRow
        err := rows.Scan(&r.DeviceID, &r.SwVersion, &r.SecPkgVersion, &r.FilterPkgVersion, &r.SwTimestamp, &r.SecPkgTimestamp, &r.FilterPkgTimestamp, &r.SwTime, &r.SecPkgTime, &r.FilterPkgTime, &r.InitSigPkgVersion, &r.InitSigPkgFilename, &r.InitSecPkgVersion, &r.InitSecPkgFilename, &r.ProfileIterationID, &r.DvtPkgID, &r.DefaultCaPkgVersion, &r.TmufePkgVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDevicePkgInventory provide iterator to all rows of the DEVICE_PKG_INVENTORY matching given criteria.
func RangeDevicePkgInventory(db *sql.DB, where string) iter.Seq2[*DevicePkgInventoryRow, error] {
	return func(yield func(v *DevicePkgInventoryRow, err error) bool) {
	    query := "SELECT DEVICE_ID,SW_VERSION,SEC_PKG_VERSION,FILTER_PKG_VERSION,SW_TIMESTAMP,SEC_PKG_TIMESTAMP,FILTER_PKG_TIMESTAMP,SW_TIME,SEC_PKG_TIME,FILTER_PKG_TIME,INIT_SIG_PKG_VERSION,INIT_SIG_PKG_FILENAME,INIT_SEC_PKG_VERSION,INIT_SEC_PKG_FILENAME,PROFILE_ITERATION_ID,DVT_PKG_ID,DEFAULT_CA_PKG_VERSION,TMUFE_PKG_VERSION FROM DEVICE_PKG_INVENTORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DevicePkgInventoryRow
	        err := rows.Scan(&r.DeviceID, &r.SwVersion, &r.SecPkgVersion, &r.FilterPkgVersion, &r.SwTimestamp, &r.SecPkgTimestamp, &r.FilterPkgTimestamp, &r.SwTime, &r.SecPkgTime, &r.FilterPkgTime, &r.InitSigPkgVersion, &r.InitSigPkgFilename, &r.InitSecPkgVersion, &r.InitSecPkgFilename, &r.ProfileIterationID, &r.DvtPkgID, &r.DefaultCaPkgVersion, &r.TmufePkgVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DevicePortVLANMappingRow struct represents rows of the DEVICE_PORT_VLAN_MAPPING table.
type DevicePortVLANMappingRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    TptPortID	string
    IncomingVLAN	sql.NullInt32
    OutgoingVLAN	sql.NullInt32
    AutoReverse	sql.NullByte
}

// IterateDevicePortVLANMapping provide access to all rows of the DEVICE_PORT_VLAN_MAPPING matching given criteria.
func IterateDevicePortVLANMapping(db *sql.DB, where string, callback func(v *DevicePortVLANMappingRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,TPT_PORT_ID,INCOMING_VLAN,OUTGOING_VLAN,AUTO_REVERSE FROM DEVICE_PORT_VLAN_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DevicePortVLANMappingRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.TptPortID, &r.IncomingVLAN, &r.OutgoingVLAN, &r.AutoReverse)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDevicePortVLANMapping provide iterator to all rows of the DEVICE_PORT_VLAN_MAPPING matching given criteria.
func RangeDevicePortVLANMapping(db *sql.DB, where string) iter.Seq2[*DevicePortVLANMappingRow, error] {
	return func(yield func(v *DevicePortVLANMappingRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,TPT_PORT_ID,INCOMING_VLAN,OUTGOING_VLAN,AUTO_REVERSE FROM DEVICE_PORT_VLAN_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DevicePortVLANMappingRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.TptPortID, &r.IncomingVLAN, &r.OutgoingVLAN, &r.AutoReverse)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceProvisionConfigRow struct represents rows of the DEVICE_PROVISION_CONFIG table.
type DeviceProvisionConfigRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    SerialNumber	sql.NullString
    FileName	sql.NullString
    FileContents	sql.NullString
}

// IterateDeviceProvisionConfig provide access to all rows of the DEVICE_PROVISION_CONFIG matching given criteria.
func IterateDeviceProvisionConfig(db *sql.DB, where string, callback func(v *DeviceProvisionConfigRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,SERIAL_NUMBER,FILE_NAME,FILE_CONTENTS FROM DEVICE_PROVISION_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceProvisionConfigRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.SerialNumber, &r.FileName, &r.FileContents)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceProvisionConfig provide iterator to all rows of the DEVICE_PROVISION_CONFIG matching given criteria.
func RangeDeviceProvisionConfig(db *sql.DB, where string) iter.Seq2[*DeviceProvisionConfigRow, error] {
	return func(yield func(v *DeviceProvisionConfigRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,SERIAL_NUMBER,FILE_NAME,FILE_CONTENTS FROM DEVICE_PROVISION_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceProvisionConfigRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.SerialNumber, &r.FileName, &r.FileContents)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceRadiusConfigRow struct represents rows of the DEVICE_RADIUS_CONFIG table.
type DeviceRadiusConfigRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    Enabled	sql.NullByte
    AllowAdminLogin	sql.NullByte
    AllowUserAuth	sql.NullByte
    AllowVpnAccessAuth	sql.NullByte
    ServerTimeout	sql.NullInt32
    ServerRetries	sql.NullByte
    PrivilegeGroupID	sql.NullInt32
    Server1Addr	sql.NullInt32
    Server1Port	sql.NullInt32
    Server1SharedSecret	sql.NullString
    Server1AuthProtocol	sql.NullByte
    Server2Addr	sql.NullInt32
    Server2Port	sql.NullInt32
    Server2SharedSecret	sql.NullString
    Server2AuthProtocol	sql.NullByte
}

// IterateDeviceRadiusConfig provide access to all rows of the DEVICE_RADIUS_CONFIG matching given criteria.
func IterateDeviceRadiusConfig(db *sql.DB, where string, callback func(v *DeviceRadiusConfigRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,ENABLED,ALLOW_ADMIN_LOGIN,ALLOW_USER_AUTH,ALLOW_VPN_ACCESS_AUTH,SERVER_TIMEOUT,SERVER_RETRIES,PRIVILEGE_GROUP_ID,SERVER1_ADDR,SERVER1_PORT,SERVER1_SHARED_SECRET,SERVER1_AUTH_PROTOCOL,SERVER2_ADDR,SERVER2_PORT,SERVER2_SHARED_SECRET,SERVER2_AUTH_PROTOCOL FROM DEVICE_RADIUS_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceRadiusConfigRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Enabled, &r.AllowAdminLogin, &r.AllowUserAuth, &r.AllowVpnAccessAuth, &r.ServerTimeout, &r.ServerRetries, &r.PrivilegeGroupID, &r.Server1Addr, &r.Server1Port, &r.Server1SharedSecret, &r.Server1AuthProtocol, &r.Server2Addr, &r.Server2Port, &r.Server2SharedSecret, &r.Server2AuthProtocol)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceRadiusConfig provide iterator to all rows of the DEVICE_RADIUS_CONFIG matching given criteria.
func RangeDeviceRadiusConfig(db *sql.DB, where string) iter.Seq2[*DeviceRadiusConfigRow, error] {
	return func(yield func(v *DeviceRadiusConfigRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,ENABLED,ALLOW_ADMIN_LOGIN,ALLOW_USER_AUTH,ALLOW_VPN_ACCESS_AUTH,SERVER_TIMEOUT,SERVER_RETRIES,PRIVILEGE_GROUP_ID,SERVER1_ADDR,SERVER1_PORT,SERVER1_SHARED_SECRET,SERVER1_AUTH_PROTOCOL,SERVER2_ADDR,SERVER2_PORT,SERVER2_SHARED_SECRET,SERVER2_AUTH_PROTOCOL FROM DEVICE_RADIUS_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceRadiusConfigRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Enabled, &r.AllowAdminLogin, &r.AllowUserAuth, &r.AllowVpnAccessAuth, &r.ServerTimeout, &r.ServerRetries, &r.PrivilegeGroupID, &r.Server1Addr, &r.Server1Port, &r.Server1SharedSecret, &r.Server1AuthProtocol, &r.Server2Addr, &r.Server2Port, &r.Server2SharedSecret, &r.Server2AuthProtocol)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceRegCapabilityRow struct represents rows of the DEVICE_REG_CAPABILITY table.
type DeviceRegCapabilityRow struct {
    DeviceShortID	uint
    Name	string
    Unit	int
    ActivationCode	sql.NullString
}

// IterateDeviceRegCapability provide access to all rows of the DEVICE_REG_CAPABILITY matching given criteria.
func IterateDeviceRegCapability(db *sql.DB, where string, callback func(v *DeviceRegCapabilityRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,NAME,UNIT,ACTIVATION_CODE FROM DEVICE_REG_CAPABILITY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceRegCapabilityRow
        err := rows.Scan(&r.DeviceShortID, &r.Name, &r.Unit, &r.ActivationCode)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceRegCapability provide iterator to all rows of the DEVICE_REG_CAPABILITY matching given criteria.
func RangeDeviceRegCapability(db *sql.DB, where string) iter.Seq2[*DeviceRegCapabilityRow, error] {
	return func(yield func(v *DeviceRegCapabilityRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,NAME,UNIT,ACTIVATION_CODE FROM DEVICE_REG_CAPABILITY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceRegCapabilityRow
	        err := rows.Scan(&r.DeviceShortID, &r.Name, &r.Unit, &r.ActivationCode)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceRegMetadataRow struct represents rows of the DEVICE_REG_METADATA table.
type DeviceRegMetadataRow struct {
    DeviceShortID	uint
    MetadataKey	string
    Value	sql.NullString
    Visible	int8
}

// IterateDeviceRegMetadata provide access to all rows of the DEVICE_REG_METADATA matching given criteria.
func IterateDeviceRegMetadata(db *sql.DB, where string, callback func(v *DeviceRegMetadataRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,METADATA_KEY,VALUE,VISIBLE FROM DEVICE_REG_METADATA"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceRegMetadataRow
        err := rows.Scan(&r.DeviceShortID, &r.MetadataKey, &r.Value, &r.Visible)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceRegMetadata provide iterator to all rows of the DEVICE_REG_METADATA matching given criteria.
func RangeDeviceRegMetadata(db *sql.DB, where string) iter.Seq2[*DeviceRegMetadataRow, error] {
	return func(yield func(v *DeviceRegMetadataRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,METADATA_KEY,VALUE,VISIBLE FROM DEVICE_REG_METADATA"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceRegMetadataRow
	        err := rows.Scan(&r.DeviceShortID, &r.MetadataKey, &r.Value, &r.Visible)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceRemoteRadiusServerRow struct represents rows of the DEVICE_REMOTE_RADIUS_SERVER table.
type DeviceRemoteRadiusServerRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    ServerOrder	sql.NullInt32
    IPAddressNamedObjID	sql.NullInt32
    Port	sql.NullInt32
    AuthMethod	sql.NullString
    SharedSecret	sql.NullString
    Timeout	sql.NullInt32
    Retries	sql.NullInt32
    NamedCertificateID	sql.NullInt32
}

// IterateDeviceRemoteRadiusServer provide access to all rows of the DEVICE_REMOTE_RADIUS_SERVER matching given criteria.
func IterateDeviceRemoteRadiusServer(db *sql.DB, where string, callback func(v *DeviceRemoteRadiusServerRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,SERVER_ORDER,IP_ADDRESS_NAMED_OBJ_ID,PORT,AUTH_METHOD,SHARED_SECRET,TIMEOUT,RETRIES,NAMED_CERTIFICATE_ID FROM DEVICE_REMOTE_RADIUS_SERVER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceRemoteRadiusServerRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.ServerOrder, &r.IPAddressNamedObjID, &r.Port, &r.AuthMethod, &r.SharedSecret, &r.Timeout, &r.Retries, &r.NamedCertificateID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceRemoteRadiusServer provide iterator to all rows of the DEVICE_REMOTE_RADIUS_SERVER matching given criteria.
func RangeDeviceRemoteRadiusServer(db *sql.DB, where string) iter.Seq2[*DeviceRemoteRadiusServerRow, error] {
	return func(yield func(v *DeviceRemoteRadiusServerRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,SERVER_ORDER,IP_ADDRESS_NAMED_OBJ_ID,PORT,AUTH_METHOD,SHARED_SECRET,TIMEOUT,RETRIES,NAMED_CERTIFICATE_ID FROM DEVICE_REMOTE_RADIUS_SERVER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceRemoteRadiusServerRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.ServerOrder, &r.IPAddressNamedObjID, &r.Port, &r.AuthMethod, &r.SharedSecret, &r.Timeout, &r.Retries, &r.NamedCertificateID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceRemoteSyslogRow struct represents rows of the DEVICE_REMOTE_SYSLOG table.
type DeviceRemoteSyslogRow struct {
    DeviceID	string
    IP	string
    Port	int
    Alert	sql.NullInt32
    Block	sql.NullInt32
    P2p	sql.NullInt32
    Delimiter	sql.NullInt32
    IPNamedObjID	sql.NullInt32
}

// IterateDeviceRemoteSyslog provide access to all rows of the DEVICE_REMOTE_SYSLOG matching given criteria.
func IterateDeviceRemoteSyslog(db *sql.DB, where string, callback func(v *DeviceRemoteSyslogRow) error) error {
    query := "SELECT DEVICE_ID,IP,PORT,ALERT,BLOCK,P2P,DELIMITER,IP_NAMED_OBJ_ID FROM DEVICE_REMOTE_SYSLOG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceRemoteSyslogRow
        err := rows.Scan(&r.DeviceID, &r.IP, &r.Port, &r.Alert, &r.Block, &r.P2p, &r.Delimiter, &r.IPNamedObjID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceRemoteSyslog provide iterator to all rows of the DEVICE_REMOTE_SYSLOG matching given criteria.
func RangeDeviceRemoteSyslog(db *sql.DB, where string) iter.Seq2[*DeviceRemoteSyslogRow, error] {
	return func(yield func(v *DeviceRemoteSyslogRow, err error) bool) {
	    query := "SELECT DEVICE_ID,IP,PORT,ALERT,BLOCK,P2P,DELIMITER,IP_NAMED_OBJ_ID FROM DEVICE_REMOTE_SYSLOG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceRemoteSyslogRow
	        err := rows.Scan(&r.DeviceID, &r.IP, &r.Port, &r.Alert, &r.Block, &r.P2p, &r.Delimiter, &r.IPNamedObjID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceResourceCountsRow struct represents rows of the DEVICE_RESOURCE_COUNTS table.
type DeviceResourceCountsRow struct {
    DeviceShortID	uint
    ResourceFirewallRule	sql.NullInt32
    ResourceSecurityZone	sql.NullInt32
    ResourceService	sql.NullInt32
    ResourceServiceGroup	sql.NullInt32
    ResourceSecurityAssociation	sql.NullInt32
    ResourceIpsecTunnel	sql.NullInt32
    ResourceIkeProposal	sql.NullInt32
    ResourceIPGroup	sql.NullInt32
    ResourceVirtualInterface	sql.NullInt32
    ResourceGreVirtualInterface	sql.NullInt32
    ResourceStaticRoute	sql.NullInt32
    ResourceSchedule	sql.NullInt32
    ResourceVirtualServer	sql.NullInt32
    ResourceDhcpStaticMapping	sql.NullInt32
    ResourceDhcpLease	sql.NullInt32
    ResourceLocalUser	sql.NullInt32
    ResourcePrivilegeGroup	sql.NullInt32
    ResourceLocalCert	sql.NullInt32
    ResourceCertRequest	sql.NullInt32
    ResourceCaCert	sql.NullInt32
    ResourceIPRange	sql.NullInt32
    ResourceIPSubnet	sql.NullInt32
    ResourceEmail	sql.NullInt32
    ResourceDomainName	sql.NullInt32
    ResourceIPGateway	sql.NullInt32
    ResourceNatAddress	sql.NullInt32
    ResourceL2tpConfig	sql.NullInt32
    ResourceL2tpSession	sql.NullInt32
    ResourcePptpConfig	sql.NullInt32
    ResourcePptpSession	sql.NullInt32
    ResourceVLAN	sql.NullInt32
    ResourceDhcpConfig	sql.NullInt32
    ResourceCfConfig	sql.NullInt32
    ResourceRadiusConfig	sql.NullInt32
    ResourceCfPatter	sql.NullInt32
    ResourceIPAddr	sql.NullInt32
    ResourceMacAddr	sql.NullInt32
    ResourceNtpConfig	sql.NullInt32
    ResourceIpsecConfig	sql.NullInt32
    ResourceIkeConfig	sql.NullInt32
    ResourceIgmpConfig	sql.NullInt32
    ResourcePimdmConfig	sql.NullInt32
    ResourceRipConfig	sql.NullInt32
    ResourceHa	sql.NullInt32
    ResourceArpEntry	sql.NullInt32
    ResourceFirewallSession	sql.NullInt32
    ResourceCfCacheSize	sql.NullInt32
    ResourceHashtableSize	sql.NullInt32
    ResourceDnsSettings	sql.NullInt32
    ResourceUserCount	sql.NullInt32
}

// IterateDeviceResourceCounts provide access to all rows of the DEVICE_RESOURCE_COUNTS matching given criteria.
func IterateDeviceResourceCounts(db *sql.DB, where string, callback func(v *DeviceResourceCountsRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,RESOURCE_FIREWALL_RULE,RESOURCE_SECURITY_ZONE,RESOURCE_SERVICE,RESOURCE_SERVICE_GROUP,RESOURCE_SECURITY_ASSOCIATION,RESOURCE_IPSEC_TUNNEL,RESOURCE_IKE_PROPOSAL,RESOURCE_IP_GROUP,RESOURCE_VIRTUAL_INTERFACE,RESOURCE_GRE_VIRTUAL_INTERFACE,RESOURCE_STATIC_ROUTE,RESOURCE_SCHEDULE,RESOURCE_VIRTUAL_SERVER,RESOURCE_DHCP_STATIC_MAPPING,RESOURCE_DHCP_LEASE,RESOURCE_LOCAL_USER,RESOURCE_PRIVILEGE_GROUP,RESOURCE_LOCAL_CERT,RESOURCE_CERT_REQUEST,RESOURCE_CA_CERT,RESOURCE_IP_RANGE,RESOURCE_IP_SUBNET,RESOURCE_EMAIL,RESOURCE_DOMAIN_NAME,RESOURCE_IP_GATEWAY,RESOURCE_NAT_ADDRESS,RESOURCE_L2TP_CONFIG,RESOURCE_L2TP_SESSION,RESOURCE_PPTP_CONFIG,RESOURCE_PPTP_SESSION,RESOURCE_VLAN,RESOURCE_DHCP_CONFIG,RESOURCE_CF_CONFIG,RESOURCE_RADIUS_CONFIG,RESOURCE_CF_PATTER,RESOURCE_IP_ADDR,RESOURCE_MAC_ADDR,RESOURCE_NTP_CONFIG,RESOURCE_IPSEC_CONFIG,RESOURCE_IKE_CONFIG,RESOURCE_IGMP_CONFIG,RESOURCE_PIMDM_CONFIG,RESOURCE_RIP_CONFIG,RESOURCE_HA,RESOURCE_ARP_ENTRY,RESOURCE_FIREWALL_SESSION,RESOURCE_CF_CACHE_SIZE,RESOURCE_HASHTABLE_SIZE,RESOURCE_DNS_SETTINGS,RESOURCE_USER_COUNT FROM DEVICE_RESOURCE_COUNTS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceResourceCountsRow
        err := rows.Scan(&r.DeviceShortID, &r.ResourceFirewallRule, &r.ResourceSecurityZone, &r.ResourceService, &r.ResourceServiceGroup, &r.ResourceSecurityAssociation, &r.ResourceIpsecTunnel, &r.ResourceIkeProposal, &r.ResourceIPGroup, &r.ResourceVirtualInterface, &r.ResourceGreVirtualInterface, &r.ResourceStaticRoute, &r.ResourceSchedule, &r.ResourceVirtualServer, &r.ResourceDhcpStaticMapping, &r.ResourceDhcpLease, &r.ResourceLocalUser, &r.ResourcePrivilegeGroup, &r.ResourceLocalCert, &r.ResourceCertRequest, &r.ResourceCaCert, &r.ResourceIPRange, &r.ResourceIPSubnet, &r.ResourceEmail, &r.ResourceDomainName, &r.ResourceIPGateway, &r.ResourceNatAddress, &r.ResourceL2tpConfig, &r.ResourceL2tpSession, &r.ResourcePptpConfig, &r.ResourcePptpSession, &r.ResourceVLAN, &r.ResourceDhcpConfig, &r.ResourceCfConfig, &r.ResourceRadiusConfig, &r.ResourceCfPatter, &r.ResourceIPAddr, &r.ResourceMacAddr, &r.ResourceNtpConfig, &r.ResourceIpsecConfig, &r.ResourceIkeConfig, &r.ResourceIgmpConfig, &r.ResourcePimdmConfig, &r.ResourceRipConfig, &r.ResourceHa, &r.ResourceArpEntry, &r.ResourceFirewallSession, &r.ResourceCfCacheSize, &r.ResourceHashtableSize, &r.ResourceDnsSettings, &r.ResourceUserCount)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceResourceCounts provide iterator to all rows of the DEVICE_RESOURCE_COUNTS matching given criteria.
func RangeDeviceResourceCounts(db *sql.DB, where string) iter.Seq2[*DeviceResourceCountsRow, error] {
	return func(yield func(v *DeviceResourceCountsRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,RESOURCE_FIREWALL_RULE,RESOURCE_SECURITY_ZONE,RESOURCE_SERVICE,RESOURCE_SERVICE_GROUP,RESOURCE_SECURITY_ASSOCIATION,RESOURCE_IPSEC_TUNNEL,RESOURCE_IKE_PROPOSAL,RESOURCE_IP_GROUP,RESOURCE_VIRTUAL_INTERFACE,RESOURCE_GRE_VIRTUAL_INTERFACE,RESOURCE_STATIC_ROUTE,RESOURCE_SCHEDULE,RESOURCE_VIRTUAL_SERVER,RESOURCE_DHCP_STATIC_MAPPING,RESOURCE_DHCP_LEASE,RESOURCE_LOCAL_USER,RESOURCE_PRIVILEGE_GROUP,RESOURCE_LOCAL_CERT,RESOURCE_CERT_REQUEST,RESOURCE_CA_CERT,RESOURCE_IP_RANGE,RESOURCE_IP_SUBNET,RESOURCE_EMAIL,RESOURCE_DOMAIN_NAME,RESOURCE_IP_GATEWAY,RESOURCE_NAT_ADDRESS,RESOURCE_L2TP_CONFIG,RESOURCE_L2TP_SESSION,RESOURCE_PPTP_CONFIG,RESOURCE_PPTP_SESSION,RESOURCE_VLAN,RESOURCE_DHCP_CONFIG,RESOURCE_CF_CONFIG,RESOURCE_RADIUS_CONFIG,RESOURCE_CF_PATTER,RESOURCE_IP_ADDR,RESOURCE_MAC_ADDR,RESOURCE_NTP_CONFIG,RESOURCE_IPSEC_CONFIG,RESOURCE_IKE_CONFIG,RESOURCE_IGMP_CONFIG,RESOURCE_PIMDM_CONFIG,RESOURCE_RIP_CONFIG,RESOURCE_HA,RESOURCE_ARP_ENTRY,RESOURCE_FIREWALL_SESSION,RESOURCE_CF_CACHE_SIZE,RESOURCE_HASHTABLE_SIZE,RESOURCE_DNS_SETTINGS,RESOURCE_USER_COUNT FROM DEVICE_RESOURCE_COUNTS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceResourceCountsRow
	        err := rows.Scan(&r.DeviceShortID, &r.ResourceFirewallRule, &r.ResourceSecurityZone, &r.ResourceService, &r.ResourceServiceGroup, &r.ResourceSecurityAssociation, &r.ResourceIpsecTunnel, &r.ResourceIkeProposal, &r.ResourceIPGroup, &r.ResourceVirtualInterface, &r.ResourceGreVirtualInterface, &r.ResourceStaticRoute, &r.ResourceSchedule, &r.ResourceVirtualServer, &r.ResourceDhcpStaticMapping, &r.ResourceDhcpLease, &r.ResourceLocalUser, &r.ResourcePrivilegeGroup, &r.ResourceLocalCert, &r.ResourceCertRequest, &r.ResourceCaCert, &r.ResourceIPRange, &r.ResourceIPSubnet, &r.ResourceEmail, &r.ResourceDomainName, &r.ResourceIPGateway, &r.ResourceNatAddress, &r.ResourceL2tpConfig, &r.ResourceL2tpSession, &r.ResourcePptpConfig, &r.ResourcePptpSession, &r.ResourceVLAN, &r.ResourceDhcpConfig, &r.ResourceCfConfig, &r.ResourceRadiusConfig, &r.ResourceCfPatter, &r.ResourceIPAddr, &r.ResourceMacAddr, &r.ResourceNtpConfig, &r.ResourceIpsecConfig, &r.ResourceIkeConfig, &r.ResourceIgmpConfig, &r.ResourcePimdmConfig, &r.ResourceRipConfig, &r.ResourceHa, &r.ResourceArpEntry, &r.ResourceFirewallSession, &r.ResourceCfCacheSize, &r.ResourceHashtableSize, &r.ResourceDnsSettings, &r.ResourceUserCount)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceScheduleRow struct represents rows of the DEVICE_SCHEDULE table.
type DeviceScheduleRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    Name	sql.NullString
}

// IterateDeviceSchedule provide access to all rows of the DEVICE_SCHEDULE matching given criteria.
func IterateDeviceSchedule(db *sql.DB, where string, callback func(v *DeviceScheduleRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,NAME FROM DEVICE_SCHEDULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceScheduleRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceSchedule provide iterator to all rows of the DEVICE_SCHEDULE matching given criteria.
func RangeDeviceSchedule(db *sql.DB, where string) iter.Seq2[*DeviceScheduleRow, error] {
	return func(yield func(v *DeviceScheduleRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,NAME FROM DEVICE_SCHEDULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceScheduleRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceScheduleOccurrenceRow struct represents rows of the DEVICE_SCHEDULE_OCCURRENCE table.
type DeviceScheduleOccurrenceRow struct {
    ID	uint
    DeviceScheduleID	uint
    DayOfWeek	sql.NullInt32
    StartHour	sql.NullByte
    StartMinute	sql.NullByte
    EndHour	sql.NullByte
    EndMinute	sql.NullByte
}

// IterateDeviceScheduleOccurrence provide access to all rows of the DEVICE_SCHEDULE_OCCURRENCE matching given criteria.
func IterateDeviceScheduleOccurrence(db *sql.DB, where string, callback func(v *DeviceScheduleOccurrenceRow) error) error {
    query := "SELECT ID,DEVICE_SCHEDULE_ID,DAY_OF_WEEK,START_HOUR,START_MINUTE,END_HOUR,END_MINUTE FROM DEVICE_SCHEDULE_OCCURRENCE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceScheduleOccurrenceRow
        err := rows.Scan(&r.ID, &r.DeviceScheduleID, &r.DayOfWeek, &r.StartHour, &r.StartMinute, &r.EndHour, &r.EndMinute)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceScheduleOccurrence provide iterator to all rows of the DEVICE_SCHEDULE_OCCURRENCE matching given criteria.
func RangeDeviceScheduleOccurrence(db *sql.DB, where string) iter.Seq2[*DeviceScheduleOccurrenceRow, error] {
	return func(yield func(v *DeviceScheduleOccurrenceRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SCHEDULE_ID,DAY_OF_WEEK,START_HOUR,START_MINUTE,END_HOUR,END_MINUTE FROM DEVICE_SCHEDULE_OCCURRENCE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceScheduleOccurrenceRow
	        err := rows.Scan(&r.ID, &r.DeviceScheduleID, &r.DayOfWeek, &r.StartHour, &r.StartMinute, &r.EndHour, &r.EndMinute)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceSnapshotRow struct represents rows of the DEVICE_SNAPSHOT table.
type DeviceSnapshotRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    Name	string
    DeviceFile	sql.NullString
    SmsFile	sql.NullString
    TosVersion	sql.NullString
    DvVersion	sql.NullString
    DeviceDate	sql.NullString
    ExportTime	sql.NullInt64
    CanRestore	sql.NullByte
    SmsStored	sql.NullByte
    DeviceStored	sql.NullByte
}

// IterateDeviceSnapshot provide access to all rows of the DEVICE_SNAPSHOT matching given criteria.
func IterateDeviceSnapshot(db *sql.DB, where string, callback func(v *DeviceSnapshotRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,NAME,DEVICE_FILE,SMS_FILE,TOS_VERSION,DV_VERSION,DEVICE_DATE,EXPORT_TIME,CAN_RESTORE,SMS_STORED,DEVICE_STORED FROM DEVICE_SNAPSHOT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceSnapshotRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Name, &r.DeviceFile, &r.SmsFile, &r.TosVersion, &r.DvVersion, &r.DeviceDate, &r.ExportTime, &r.CanRestore, &r.SmsStored, &r.DeviceStored)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceSnapshot provide iterator to all rows of the DEVICE_SNAPSHOT matching given criteria.
func RangeDeviceSnapshot(db *sql.DB, where string) iter.Seq2[*DeviceSnapshotRow, error] {
	return func(yield func(v *DeviceSnapshotRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,NAME,DEVICE_FILE,SMS_FILE,TOS_VERSION,DV_VERSION,DEVICE_DATE,EXPORT_TIME,CAN_RESTORE,SMS_STORED,DEVICE_STORED FROM DEVICE_SNAPSHOT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceSnapshotRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Name, &r.DeviceFile, &r.SmsFile, &r.TosVersion, &r.DvVersion, &r.DeviceDate, &r.ExportTime, &r.CanRestore, &r.SmsStored, &r.DeviceStored)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceSnmpInfoRow struct represents rows of the DEVICE_SNMP_INFO table.
type DeviceSnmpInfoRow struct {
    ID	uint64
    DeviceShortID	uint
    UseSnmpV3	sql.NullBool
    IPAddr	string
    Community	sql.NullString
    AuthUsername	sql.NullString
    AuthPassword	sql.NullString
    PrivKey	sql.NullString
    AuthProtocol	sql.NullString
    PrivProtocol	sql.NullString
    LastChange	string
}

// IterateDeviceSnmpInfo provide access to all rows of the DEVICE_SNMP_INFO matching given criteria.
func IterateDeviceSnmpInfo(db *sql.DB, where string, callback func(v *DeviceSnmpInfoRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,USE_SNMP_V3,IP_ADDR,COMMUNITY,AUTH_USERNAME,AUTH_PASSWORD,PRIV_KEY,AUTH_PROTOCOL,PRIV_PROTOCOL,LAST_CHANGE FROM DEVICE_SNMP_INFO"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceSnmpInfoRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.UseSnmpV3, &r.IPAddr, &r.Community, &r.AuthUsername, &r.AuthPassword, &r.PrivKey, &r.AuthProtocol, &r.PrivProtocol, &r.LastChange)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceSnmpInfo provide iterator to all rows of the DEVICE_SNMP_INFO matching given criteria.
func RangeDeviceSnmpInfo(db *sql.DB, where string) iter.Seq2[*DeviceSnmpInfoRow, error] {
	return func(yield func(v *DeviceSnmpInfoRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,USE_SNMP_V3,IP_ADDR,COMMUNITY,AUTH_USERNAME,AUTH_PASSWORD,PRIV_KEY,AUTH_PROTOCOL,PRIV_PROTOCOL,LAST_CHANGE FROM DEVICE_SNMP_INFO"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceSnmpInfoRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.UseSnmpV3, &r.IPAddr, &r.Community, &r.AuthUsername, &r.AuthPassword, &r.PrivKey, &r.AuthProtocol, &r.PrivProtocol, &r.LastChange)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceSystemLogRow struct represents rows of the DEVICE_SYSTEM_LOG table.
type DeviceSystemLogRow struct {
    DeviceShortID	sql.NullInt32
    SequenceNum	sql.NullInt64
    Time	sql.NullInt64
    Severity	sql.NullString
    Component	sql.NullString
    MsgCode	sql.NullInt32
    Message	sql.NullString
    Idx	int64
}

// IterateDeviceSystemLog provide access to all rows of the DEVICE_SYSTEM_LOG matching given criteria.
func IterateDeviceSystemLog(db *sql.DB, where string, callback func(v *DeviceSystemLogRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,SEQUENCE_NUM,TIME,SEVERITY,COMPONENT,MSG_CODE,MESSAGE,IDX FROM DEVICE_SYSTEM_LOG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceSystemLogRow
        err := rows.Scan(&r.DeviceShortID, &r.SequenceNum, &r.Time, &r.Severity, &r.Component, &r.MsgCode, &r.Message, &r.Idx)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceSystemLog provide iterator to all rows of the DEVICE_SYSTEM_LOG matching given criteria.
func RangeDeviceSystemLog(db *sql.DB, where string) iter.Seq2[*DeviceSystemLogRow, error] {
	return func(yield func(v *DeviceSystemLogRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,SEQUENCE_NUM,TIME,SEVERITY,COMPONENT,MSG_CODE,MESSAGE,IDX FROM DEVICE_SYSTEM_LOG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceSystemLogRow
	        err := rows.Scan(&r.DeviceShortID, &r.SequenceNum, &r.Time, &r.Severity, &r.Component, &r.MsgCode, &r.Message, &r.Idx)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceThroughputUtilizationThresholdsRow struct represents rows of the DEVICE_THROUGHPUT_UTILIZATION_THRESHOLDS table.
type DeviceThroughputUtilizationThresholdsRow struct {
    ID	int
    Version	int
    DeviceShortID	uint
    CriticalThresholdPercent	uint
    MajorThresholdPercent	uint
}

// IterateDeviceThroughputUtilizationThresholds provide access to all rows of the DEVICE_THROUGHPUT_UTILIZATION_THRESHOLDS matching given criteria.
func IterateDeviceThroughputUtilizationThresholds(db *sql.DB, where string, callback func(v *DeviceThroughputUtilizationThresholdsRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,CRITICAL_THRESHOLD_PERCENT,MAJOR_THRESHOLD_PERCENT FROM DEVICE_THROUGHPUT_UTILIZATION_THRESHOLDS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceThroughputUtilizationThresholdsRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.CriticalThresholdPercent, &r.MajorThresholdPercent)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceThroughputUtilizationThresholds provide iterator to all rows of the DEVICE_THROUGHPUT_UTILIZATION_THRESHOLDS matching given criteria.
func RangeDeviceThroughputUtilizationThresholds(db *sql.DB, where string) iter.Seq2[*DeviceThroughputUtilizationThresholdsRow, error] {
	return func(yield func(v *DeviceThroughputUtilizationThresholdsRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,CRITICAL_THRESHOLD_PERCENT,MAJOR_THRESHOLD_PERCENT FROM DEVICE_THROUGHPUT_UTILIZATION_THRESHOLDS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceThroughputUtilizationThresholdsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.CriticalThresholdPercent, &r.MajorThresholdPercent)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceTlsVersionsRow struct represents rows of the DEVICE_TLS_VERSIONS table.
type DeviceTlsVersionsRow struct {
    ID	int
    Version	int
    DeviceShortID	uint
    Tlsv10	sql.NullByte
    Tlsv11	sql.NullByte
    Tlsv12	sql.NullByte
    Tlsv13	sql.NullByte
}

// IterateDeviceTlsVersions provide access to all rows of the DEVICE_TLS_VERSIONS matching given criteria.
func IterateDeviceTlsVersions(db *sql.DB, where string, callback func(v *DeviceTlsVersionsRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,TLSV10,TLSV11,TLSV12,TLSV13 FROM DEVICE_TLS_VERSIONS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceTlsVersionsRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Tlsv10, &r.Tlsv11, &r.Tlsv12, &r.Tlsv13)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceTlsVersions provide iterator to all rows of the DEVICE_TLS_VERSIONS matching given criteria.
func RangeDeviceTlsVersions(db *sql.DB, where string) iter.Seq2[*DeviceTlsVersionsRow, error] {
	return func(yield func(v *DeviceTlsVersionsRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,TLSV10,TLSV11,TLSV12,TLSV13 FROM DEVICE_TLS_VERSIONS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceTlsVersionsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Tlsv10, &r.Tlsv11, &r.Tlsv12, &r.Tlsv13)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceTosRow struct represents rows of the DEVICE_TOS table.
type DeviceTosRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    Version	sql.NullString
    Installed	sql.NullByte
}

// IterateDeviceTos provide access to all rows of the DEVICE_TOS matching given criteria.
func IterateDeviceTos(db *sql.DB, where string, callback func(v *DeviceTosRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,VERSION,INSTALLED FROM DEVICE_TOS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceTosRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Version, &r.Installed)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceTos provide iterator to all rows of the DEVICE_TOS matching given criteria.
func RangeDeviceTos(db *sql.DB, where string) iter.Seq2[*DeviceTosRow, error] {
	return func(yield func(v *DeviceTosRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,VERSION,INSTALLED FROM DEVICE_TOS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceTosRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Version, &r.Installed)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceUserRow struct represents rows of the DEVICE_USER table.
type DeviceUserRow struct {
    ID	uint64
    DeviceShortID	uint
    Username	string
    Password	sql.NullString
    Role	sql.NullInt32
    State	sql.NullString
    FailedAttempts	uint
    LockoutTime	sql.NullInt64
    LastChange	sql.NullInt64
    DeviceUserType	uint
}

// IterateDeviceUser provide access to all rows of the DEVICE_USER matching given criteria.
func IterateDeviceUser(db *sql.DB, where string, callback func(v *DeviceUserRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,USERNAME,PASSWORD,ROLE,STATE,FAILED_ATTEMPTS,LOCKOUT_TIME,LAST_CHANGE,DEVICE_USER_TYPE FROM DEVICE_USER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceUserRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Username, &r.Password, &r.Role, &r.State, &r.FailedAttempts, &r.LockoutTime, &r.LastChange, &r.DeviceUserType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceUser provide iterator to all rows of the DEVICE_USER matching given criteria.
func RangeDeviceUser(db *sql.DB, where string) iter.Seq2[*DeviceUserRow, error] {
	return func(yield func(v *DeviceUserRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,USERNAME,PASSWORD,ROLE,STATE,FAILED_ATTEMPTS,LOCKOUT_TIME,LAST_CHANGE,DEVICE_USER_TYPE FROM DEVICE_USER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceUserRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Username, &r.Password, &r.Role, &r.State, &r.FailedAttempts, &r.LockoutTime, &r.LastChange, &r.DeviceUserType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceUserPrefsRow struct represents rows of the DEVICE_USER_PREFS table.
type DeviceUserPrefsRow struct {
    DeviceShortID	uint
    MaxAttempts	sql.NullInt32
    ExpirePeriod	sql.NullInt32
    ExpireAction	sql.NullByte
    LockoutPeriod	sql.NullInt32
    AttemptAction	sql.NullByte
    SecurityLevel	sql.NullInt32
}

// IterateDeviceUserPrefs provide access to all rows of the DEVICE_USER_PREFS matching given criteria.
func IterateDeviceUserPrefs(db *sql.DB, where string, callback func(v *DeviceUserPrefsRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,MAX_ATTEMPTS,EXPIRE_PERIOD,EXPIRE_ACTION,LOCKOUT_PERIOD,ATTEMPT_ACTION,SECURITY_LEVEL FROM DEVICE_USER_PREFS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceUserPrefsRow
        err := rows.Scan(&r.DeviceShortID, &r.MaxAttempts, &r.ExpirePeriod, &r.ExpireAction, &r.LockoutPeriod, &r.AttemptAction, &r.SecurityLevel)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceUserPrefs provide iterator to all rows of the DEVICE_USER_PREFS matching given criteria.
func RangeDeviceUserPrefs(db *sql.DB, where string) iter.Seq2[*DeviceUserPrefsRow, error] {
	return func(yield func(v *DeviceUserPrefsRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,MAX_ATTEMPTS,EXPIRE_PERIOD,EXPIRE_ACTION,LOCKOUT_PERIOD,ATTEMPT_ACTION,SECURITY_LEVEL FROM DEVICE_USER_PREFS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceUserPrefsRow
	        err := rows.Scan(&r.DeviceShortID, &r.MaxAttempts, &r.ExpirePeriod, &r.ExpireAction, &r.LockoutPeriod, &r.AttemptAction, &r.SecurityLevel)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DeviceVirtualSegmentVirtualSegmentRow struct represents rows of the DEVICE_VIRTUAL_SEGMENT_VIRTUAL_SEGMENT table.
type DeviceVirtualSegmentVirtualSegmentRow struct {
    DeviceVirtualSegmentID	string
    VirtualSegmentID	uint
}

// IterateDeviceVirtualSegmentVirtualSegment provide access to all rows of the DEVICE_VIRTUAL_SEGMENT_VIRTUAL_SEGMENT matching given criteria.
func IterateDeviceVirtualSegmentVirtualSegment(db *sql.DB, where string, callback func(v *DeviceVirtualSegmentVirtualSegmentRow) error) error {
    query := "SELECT DEVICE_VIRTUAL_SEGMENT_ID,VIRTUAL_SEGMENT_ID FROM DEVICE_VIRTUAL_SEGMENT_VIRTUAL_SEGMENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DeviceVirtualSegmentVirtualSegmentRow
        err := rows.Scan(&r.DeviceVirtualSegmentID, &r.VirtualSegmentID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDeviceVirtualSegmentVirtualSegment provide iterator to all rows of the DEVICE_VIRTUAL_SEGMENT_VIRTUAL_SEGMENT matching given criteria.
func RangeDeviceVirtualSegmentVirtualSegment(db *sql.DB, where string) iter.Seq2[*DeviceVirtualSegmentVirtualSegmentRow, error] {
	return func(yield func(v *DeviceVirtualSegmentVirtualSegmentRow, err error) bool) {
	    query := "SELECT DEVICE_VIRTUAL_SEGMENT_ID,VIRTUAL_SEGMENT_ID FROM DEVICE_VIRTUAL_SEGMENT_VIRTUAL_SEGMENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DeviceVirtualSegmentVirtualSegmentRow
	        err := rows.Scan(&r.DeviceVirtualSegmentID, &r.VirtualSegmentID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DhcpLeaseRow struct represents rows of the DHCP_LEASE table.
type DhcpLeaseRow struct {
    DeviceShortID	sql.NullInt32
    IPAddr	sql.NullInt32
    MacAddr	sql.NullInt64
    HostName	sql.NullString
    LeaseType	sql.NullString
}

// IterateDhcpLease provide access to all rows of the DHCP_LEASE matching given criteria.
func IterateDhcpLease(db *sql.DB, where string, callback func(v *DhcpLeaseRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,IP_ADDR,MAC_ADDR,HOST_NAME,LEASE_TYPE FROM DHCP_LEASE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DhcpLeaseRow
        err := rows.Scan(&r.DeviceShortID, &r.IPAddr, &r.MacAddr, &r.HostName, &r.LeaseType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDhcpLease provide iterator to all rows of the DHCP_LEASE matching given criteria.
func RangeDhcpLease(db *sql.DB, where string) iter.Seq2[*DhcpLeaseRow, error] {
	return func(yield func(v *DhcpLeaseRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,IP_ADDR,MAC_ADDR,HOST_NAME,LEASE_TYPE FROM DHCP_LEASE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DhcpLeaseRow
	        err := rows.Scan(&r.DeviceShortID, &r.IPAddr, &r.MacAddr, &r.HostName, &r.LeaseType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DhcpServerRow struct represents rows of the DHCP_SERVER table.
type DhcpServerRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    Enabled	sql.NullByte
    AllowBootp	sql.NullByte
    DnsProxy	sql.NullByte
    LeaseTime	sql.NullInt32
    DnsDomain	sql.NullString
    DnsServer1Addr	sql.NullInt32
    DnsServer2Addr	sql.NullInt32
    DnsServer3Addr	sql.NullInt32
    WinsServer1Addr	sql.NullInt32
    WinsServer2Addr	sql.NullInt32
    NbxNcpAddr	sql.NullInt32
    NamedIPObjID	sql.NullInt32
    VpnRelay	sql.NullByte
    RelayMode	sql.NullByte
    VpnTunnelName	sql.NullString
    RelayServerAddr	sql.NullInt32
}

// IterateDhcpServer provide access to all rows of the DHCP_SERVER matching given criteria.
func IterateDhcpServer(db *sql.DB, where string, callback func(v *DhcpServerRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,ENABLED,ALLOW_BOOTP,DNS_PROXY,LEASE_TIME,DNS_DOMAIN,DNS_SERVER1_ADDR,DNS_SERVER2_ADDR,DNS_SERVER3_ADDR,WINS_SERVER1_ADDR,WINS_SERVER2_ADDR,NBX_NCP_ADDR,NAMED_IP_OBJ_ID,VPN_RELAY,RELAY_MODE,VPN_TUNNEL_NAME,RELAY_SERVER_ADDR FROM DHCP_SERVER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DhcpServerRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Enabled, &r.AllowBootp, &r.DnsProxy, &r.LeaseTime, &r.DnsDomain, &r.DnsServer1Addr, &r.DnsServer2Addr, &r.DnsServer3Addr, &r.WinsServer1Addr, &r.WinsServer2Addr, &r.NbxNcpAddr, &r.NamedIPObjID, &r.VpnRelay, &r.RelayMode, &r.VpnTunnelName, &r.RelayServerAddr)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDhcpServer provide iterator to all rows of the DHCP_SERVER matching given criteria.
func RangeDhcpServer(db *sql.DB, where string) iter.Seq2[*DhcpServerRow, error] {
	return func(yield func(v *DhcpServerRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,ENABLED,ALLOW_BOOTP,DNS_PROXY,LEASE_TIME,DNS_DOMAIN,DNS_SERVER1_ADDR,DNS_SERVER2_ADDR,DNS_SERVER3_ADDR,WINS_SERVER1_ADDR,WINS_SERVER2_ADDR,NBX_NCP_ADDR,NAMED_IP_OBJ_ID,VPN_RELAY,RELAY_MODE,VPN_TUNNEL_NAME,RELAY_SERVER_ADDR FROM DHCP_SERVER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DhcpServerRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Enabled, &r.AllowBootp, &r.DnsProxy, &r.LeaseTime, &r.DnsDomain, &r.DnsServer1Addr, &r.DnsServer2Addr, &r.DnsServer3Addr, &r.WinsServer1Addr, &r.WinsServer2Addr, &r.NbxNcpAddr, &r.NamedIPObjID, &r.VpnRelay, &r.RelayMode, &r.VpnTunnelName, &r.RelayServerAddr)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DhcpStaticMappingRow struct represents rows of the DHCP_STATIC_MAPPING table.
type DhcpStaticMappingRow struct {
    DeviceShortID	sql.NullInt32
    IPAddr	sql.NullInt32
    MacAddr	sql.NullInt64
}

// IterateDhcpStaticMapping provide access to all rows of the DHCP_STATIC_MAPPING matching given criteria.
func IterateDhcpStaticMapping(db *sql.DB, where string, callback func(v *DhcpStaticMappingRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,IP_ADDR,MAC_ADDR FROM DHCP_STATIC_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DhcpStaticMappingRow
        err := rows.Scan(&r.DeviceShortID, &r.IPAddr, &r.MacAddr)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDhcpStaticMapping provide iterator to all rows of the DHCP_STATIC_MAPPING matching given criteria.
func RangeDhcpStaticMapping(db *sql.DB, where string) iter.Seq2[*DhcpStaticMappingRow, error] {
	return func(yield func(v *DhcpStaticMappingRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,IP_ADDR,MAC_ADDR FROM DHCP_STATIC_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DhcpStaticMappingRow
	        err := rows.Scan(&r.DeviceShortID, &r.IPAddr, &r.MacAddr)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DistributedPackageRow struct represents rows of the DISTRIBUTED_PACKAGE table.
type DistributedPackageRow struct {
    PkgIndex	int
    PkgType	int
    PkgID	string
    PkgVersion	sql.NullString
}

// IterateDistributedPackage provide access to all rows of the DISTRIBUTED_PACKAGE matching given criteria.
func IterateDistributedPackage(db *sql.DB, where string, callback func(v *DistributedPackageRow) error) error {
    query := "SELECT PKG_INDEX,PKG_TYPE,PKG_ID,PKG_VERSION FROM DISTRIBUTED_PACKAGE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DistributedPackageRow
        err := rows.Scan(&r.PkgIndex, &r.PkgType, &r.PkgID, &r.PkgVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDistributedPackage provide iterator to all rows of the DISTRIBUTED_PACKAGE matching given criteria.
func RangeDistributedPackage(db *sql.DB, where string) iter.Seq2[*DistributedPackageRow, error] {
	return func(yield func(v *DistributedPackageRow, err error) bool) {
	    query := "SELECT PKG_INDEX,PKG_TYPE,PKG_ID,PKG_VERSION FROM DISTRIBUTED_PACKAGE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DistributedPackageRow
	        err := rows.Scan(&r.PkgIndex, &r.PkgType, &r.PkgID, &r.PkgVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DistributeInventoryRow struct represents rows of the DISTRIBUTE_INVENTORY table.
type DistributeInventoryRow struct {
    DistributeID	string
    Type	string
    SubType	sql.NullString
    TargetVersion	sql.NullString
    Status	string
    StatusQualifier	sql.NullString
    StartTime	int64
    CompleteTime	sql.NullInt64
    TaskPkgID	sql.NullString
    NgProfileSnapshotID	sql.NullInt32
    NgfwRepTask	int8
    SwPkgType	sql.NullString
    DistributionParamsXml	sql.NullString
    SubmitTimestamp	string
    SubmitUser	sql.NullString
    SubmitHost	sql.NullString
}

// IterateDistributeInventory provide access to all rows of the DISTRIBUTE_INVENTORY matching given criteria.
func IterateDistributeInventory(db *sql.DB, where string, callback func(v *DistributeInventoryRow) error) error {
    query := "SELECT DISTRIBUTE_ID,TYPE,SUB_TYPE,TARGET_VERSION,STATUS,STATUS_QUALIFIER,START_TIME,COMPLETE_TIME,TASK_PKG_ID,NG_PROFILE_SNAPSHOT_ID,NGFW_REP_TASK,SW_PKG_TYPE,DISTRIBUTION_PARAMS_XML,SUBMIT_TIMESTAMP,SUBMIT_USER,SUBMIT_HOST FROM DISTRIBUTE_INVENTORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DistributeInventoryRow
        err := rows.Scan(&r.DistributeID, &r.Type, &r.SubType, &r.TargetVersion, &r.Status, &r.StatusQualifier, &r.StartTime, &r.CompleteTime, &r.TaskPkgID, &r.NgProfileSnapshotID, &r.NgfwRepTask, &r.SwPkgType, &r.DistributionParamsXml, &r.SubmitTimestamp, &r.SubmitUser, &r.SubmitHost)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDistributeInventory provide iterator to all rows of the DISTRIBUTE_INVENTORY matching given criteria.
func RangeDistributeInventory(db *sql.DB, where string) iter.Seq2[*DistributeInventoryRow, error] {
	return func(yield func(v *DistributeInventoryRow, err error) bool) {
	    query := "SELECT DISTRIBUTE_ID,TYPE,SUB_TYPE,TARGET_VERSION,STATUS,STATUS_QUALIFIER,START_TIME,COMPLETE_TIME,TASK_PKG_ID,NG_PROFILE_SNAPSHOT_ID,NGFW_REP_TASK,SW_PKG_TYPE,DISTRIBUTION_PARAMS_XML,SUBMIT_TIMESTAMP,SUBMIT_USER,SUBMIT_HOST FROM DISTRIBUTE_INVENTORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DistributeInventoryRow
	        err := rows.Scan(&r.DistributeID, &r.Type, &r.SubType, &r.TargetVersion, &r.Status, &r.StatusQualifier, &r.StartTime, &r.CompleteTime, &r.TaskPkgID, &r.NgProfileSnapshotID, &r.NgfwRepTask, &r.SwPkgType, &r.DistributionParamsXml, &r.SubmitTimestamp, &r.SubmitUser, &r.SubmitHost)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DistributionJobInfoRow struct represents rows of the DISTRIBUTION_JOB_INFO table.
type DistributionJobInfoRow struct {
    ID	uint
    DistributionType	sql.NullInt32
    PkgID	sql.NullString
    DeviceID	sql.NullString
    DeviceName	sql.NullString
    ProgressPct	sql.NullInt32
    StartTime	string
    EndTime	string
    HiPriority	sql.NullByte
    TaskID	sql.NullString
    Success	sql.NullByte
    Status	sql.NullString
    ExtStatus	sql.NullString
    JobState	sql.NullInt32
}

// IterateDistributionJobInfo provide access to all rows of the DISTRIBUTION_JOB_INFO matching given criteria.
func IterateDistributionJobInfo(db *sql.DB, where string, callback func(v *DistributionJobInfoRow) error) error {
    query := "SELECT ID,DISTRIBUTION_TYPE,PKG_ID,DEVICE_ID,DEVICE_NAME,PROGRESS_PCT,START_TIME,END_TIME,HI_PRIORITY,TASK_ID,SUCCESS,STATUS,EXT_STATUS,JOB_STATE FROM DISTRIBUTION_JOB_INFO"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DistributionJobInfoRow
        err := rows.Scan(&r.ID, &r.DistributionType, &r.PkgID, &r.DeviceID, &r.DeviceName, &r.ProgressPct, &r.StartTime, &r.EndTime, &r.HiPriority, &r.TaskID, &r.Success, &r.Status, &r.ExtStatus, &r.JobState)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDistributionJobInfo provide iterator to all rows of the DISTRIBUTION_JOB_INFO matching given criteria.
func RangeDistributionJobInfo(db *sql.DB, where string) iter.Seq2[*DistributionJobInfoRow, error] {
	return func(yield func(v *DistributionJobInfoRow, err error) bool) {
	    query := "SELECT ID,DISTRIBUTION_TYPE,PKG_ID,DEVICE_ID,DEVICE_NAME,PROGRESS_PCT,START_TIME,END_TIME,HI_PRIORITY,TASK_ID,SUCCESS,STATUS,EXT_STATUS,JOB_STATE FROM DISTRIBUTION_JOB_INFO"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DistributionJobInfoRow
	        err := rows.Scan(&r.ID, &r.DistributionType, &r.PkgID, &r.DeviceID, &r.DeviceName, &r.ProgressPct, &r.StartTime, &r.EndTime, &r.HiPriority, &r.TaskID, &r.Success, &r.Status, &r.ExtStatus, &r.JobState)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DistributionJobInfoDistributionJobInfoRow struct represents rows of the DISTRIBUTION_JOB_INFO_DISTRIBUTION_JOB_INFO table.
type DistributionJobInfoDistributionJobInfoRow struct {
    DistributionJobInfoID	sql.NullInt32
    ChildrenID	sql.NullInt32
}

// IterateDistributionJobInfoDistributionJobInfo provide access to all rows of the DISTRIBUTION_JOB_INFO_DISTRIBUTION_JOB_INFO matching given criteria.
func IterateDistributionJobInfoDistributionJobInfo(db *sql.DB, where string, callback func(v *DistributionJobInfoDistributionJobInfoRow) error) error {
    query := "SELECT DISTRIBUTION_JOB_INFO_ID,CHILDREN_ID FROM DISTRIBUTION_JOB_INFO_DISTRIBUTION_JOB_INFO"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DistributionJobInfoDistributionJobInfoRow
        err := rows.Scan(&r.DistributionJobInfoID, &r.ChildrenID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDistributionJobInfoDistributionJobInfo provide iterator to all rows of the DISTRIBUTION_JOB_INFO_DISTRIBUTION_JOB_INFO matching given criteria.
func RangeDistributionJobInfoDistributionJobInfo(db *sql.DB, where string) iter.Seq2[*DistributionJobInfoDistributionJobInfoRow, error] {
	return func(yield func(v *DistributionJobInfoDistributionJobInfoRow, err error) bool) {
	    query := "SELECT DISTRIBUTION_JOB_INFO_ID,CHILDREN_ID FROM DISTRIBUTION_JOB_INFO_DISTRIBUTION_JOB_INFO"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DistributionJobInfoDistributionJobInfoRow
	        err := rows.Scan(&r.DistributionJobInfoID, &r.ChildrenID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DistributionTargetRow struct represents rows of the DISTRIBUTION_TARGET table.
type DistributionTargetRow struct {
    ID	uint
    DistributeInventoryDistributeID	string
    TargetType	sql.NullInt16
    TargetDeviceShortID	sql.NullInt32
    TargetVirtualSegmentID	sql.NullInt32
    TargetSegmentGroupID	sql.NullString
    HiPriority	sql.NullByte
}

// IterateDistributionTarget provide access to all rows of the DISTRIBUTION_TARGET matching given criteria.
func IterateDistributionTarget(db *sql.DB, where string, callback func(v *DistributionTargetRow) error) error {
    query := "SELECT ID,DISTRIBUTE_INVENTORY_DISTRIBUTE_ID,TARGET_TYPE,TARGET_DEVICE_SHORT_ID,TARGET_VIRTUAL_SEGMENT_ID,TARGET_SEGMENT_GROUP_ID,HI_PRIORITY FROM DISTRIBUTION_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DistributionTargetRow
        err := rows.Scan(&r.ID, &r.DistributeInventoryDistributeID, &r.TargetType, &r.TargetDeviceShortID, &r.TargetVirtualSegmentID, &r.TargetSegmentGroupID, &r.HiPriority)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDistributionTarget provide iterator to all rows of the DISTRIBUTION_TARGET matching given criteria.
func RangeDistributionTarget(db *sql.DB, where string) iter.Seq2[*DistributionTargetRow, error] {
	return func(yield func(v *DistributionTargetRow, err error) bool) {
	    query := "SELECT ID,DISTRIBUTE_INVENTORY_DISTRIBUTE_ID,TARGET_TYPE,TARGET_DEVICE_SHORT_ID,TARGET_VIRTUAL_SEGMENT_ID,TARGET_SEGMENT_GROUP_ID,HI_PRIORITY FROM DISTRIBUTION_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DistributionTargetRow
	        err := rows.Scan(&r.ID, &r.DistributeInventoryDistributeID, &r.TargetType, &r.TargetDeviceShortID, &r.TargetVirtualSegmentID, &r.TargetSegmentGroupID, &r.HiPriority)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DownloadInventoryRow struct represents rows of the DOWNLOAD_INVENTORY table.
type DownloadInventoryRow struct {
    DownloadID	string
    Type	string
    CurrentVersion	sql.NullString
    TargetVersion	sql.NullString
    TargetObject	sql.NullString
    Status	string
    StatusQualifier	sql.NullString
    StartTimestamp	string
    CompleteTimestamp	string
    StartTime	int64
    CompleteTime	int64
    TargetType	sql.NullString
}

// IterateDownloadInventory provide access to all rows of the DOWNLOAD_INVENTORY matching given criteria.
func IterateDownloadInventory(db *sql.DB, where string, callback func(v *DownloadInventoryRow) error) error {
    query := "SELECT DOWNLOAD_ID,TYPE,CURRENT_VERSION,TARGET_VERSION,TARGET_OBJECT,STATUS,STATUS_QUALIFIER,START_TIMESTAMP,COMPLETE_TIMESTAMP,START_TIME,COMPLETE_TIME,TARGET_TYPE FROM DOWNLOAD_INVENTORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DownloadInventoryRow
        err := rows.Scan(&r.DownloadID, &r.Type, &r.CurrentVersion, &r.TargetVersion, &r.TargetObject, &r.Status, &r.StatusQualifier, &r.StartTimestamp, &r.CompleteTimestamp, &r.StartTime, &r.CompleteTime, &r.TargetType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDownloadInventory provide iterator to all rows of the DOWNLOAD_INVENTORY matching given criteria.
func RangeDownloadInventory(db *sql.DB, where string) iter.Seq2[*DownloadInventoryRow, error] {
	return func(yield func(v *DownloadInventoryRow, err error) bool) {
	    query := "SELECT DOWNLOAD_ID,TYPE,CURRENT_VERSION,TARGET_VERSION,TARGET_OBJECT,STATUS,STATUS_QUALIFIER,START_TIMESTAMP,COMPLETE_TIMESTAMP,START_TIME,COMPLETE_TIME,TARGET_TYPE FROM DOWNLOAD_INVENTORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DownloadInventoryRow
	        err := rows.Scan(&r.DownloadID, &r.Type, &r.CurrentVersion, &r.TargetVersion, &r.TargetObject, &r.Status, &r.StatusQualifier, &r.StartTimestamp, &r.CompleteTimestamp, &r.StartTime, &r.CompleteTime, &r.TargetType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// DvtSignatureMappingRow struct represents rows of the DVT_SIGNATURE_MAPPING table.
type DvtSignatureMappingRow struct {
    SmsPkgUuid	string
    DvtSignatureUuid	string
    SignatureUuid	string
}

// IterateDvtSignatureMapping provide access to all rows of the DVT_SIGNATURE_MAPPING matching given criteria.
func IterateDvtSignatureMapping(db *sql.DB, where string, callback func(v *DvtSignatureMappingRow) error) error {
    query := "SELECT SMS_PKG_UUID,DVT_SIGNATURE_UUID,SIGNATURE_UUID FROM DVT_SIGNATURE_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r DvtSignatureMappingRow
        err := rows.Scan(&r.SmsPkgUuid, &r.DvtSignatureUuid, &r.SignatureUuid)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeDvtSignatureMapping provide iterator to all rows of the DVT_SIGNATURE_MAPPING matching given criteria.
func RangeDvtSignatureMapping(db *sql.DB, where string) iter.Seq2[*DvtSignatureMappingRow, error] {
	return func(yield func(v *DvtSignatureMappingRow, err error) bool) {
	    query := "SELECT SMS_PKG_UUID,DVT_SIGNATURE_UUID,SIGNATURE_UUID FROM DVT_SIGNATURE_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r DvtSignatureMappingRow
	        err := rows.Scan(&r.SmsPkgUuid, &r.DvtSignatureUuid, &r.SignatureUuid)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// EntBaseDateRow struct represents rows of the ENT_BASE_DATE table.
type EntBaseDateRow struct {
    ID	uint
    BaseDtStr	string
    UpdateTime	string
}

// IterateEntBaseDate provide access to all rows of the ENT_BASE_DATE matching given criteria.
func IterateEntBaseDate(db *sql.DB, where string, callback func(v *EntBaseDateRow) error) error {
    query := "SELECT ID,BASE_DT_STR,UPDATE_TIME FROM ENT_BASE_DATE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r EntBaseDateRow
        err := rows.Scan(&r.ID, &r.BaseDtStr, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeEntBaseDate provide iterator to all rows of the ENT_BASE_DATE matching given criteria.
func RangeEntBaseDate(db *sql.DB, where string) iter.Seq2[*EntBaseDateRow, error] {
	return func(yield func(v *EntBaseDateRow, err error) bool) {
	    query := "SELECT ID,BASE_DT_STR,UPDATE_TIME FROM ENT_BASE_DATE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r EntBaseDateRow
	        err := rows.Scan(&r.ID, &r.BaseDtStr, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// EtlProcessIntervalRow struct represents rows of the ETL_PROCESS_INTERVAL table.
type EtlProcessIntervalRow struct {
    ID	uint
    ProcessInterval	sql.NullInt32
}

// IterateEtlProcessInterval provide access to all rows of the ETL_PROCESS_INTERVAL matching given criteria.
func IterateEtlProcessInterval(db *sql.DB, where string, callback func(v *EtlProcessIntervalRow) error) error {
    query := "SELECT ID,PROCESS_INTERVAL FROM ETL_PROCESS_INTERVAL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r EtlProcessIntervalRow
        err := rows.Scan(&r.ID, &r.ProcessInterval)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeEtlProcessInterval provide iterator to all rows of the ETL_PROCESS_INTERVAL matching given criteria.
func RangeEtlProcessInterval(db *sql.DB, where string) iter.Seq2[*EtlProcessIntervalRow, error] {
	return func(yield func(v *EtlProcessIntervalRow, err error) bool) {
	    query := "SELECT ID,PROCESS_INTERVAL FROM ETL_PROCESS_INTERVAL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r EtlProcessIntervalRow
	        err := rows.Scan(&r.ID, &r.ProcessInterval)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// EventsNavTreeRow struct represents rows of the EVENTS_NAV_TREE table.
type EventsNavTreeRow struct {
    ID	uint
    ParentID	sql.NullInt32
    NodeType	string
    FrameName	string
    Name	string
    QueryData	[]byte
}

// IterateEventsNavTree provide access to all rows of the EVENTS_NAV_TREE matching given criteria.
func IterateEventsNavTree(db *sql.DB, where string, callback func(v *EventsNavTreeRow) error) error {
    query := "SELECT ID,PARENT_ID,NODE_TYPE,FRAME_NAME,NAME,QUERY_DATA FROM EVENTS_NAV_TREE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r EventsNavTreeRow
        err := rows.Scan(&r.ID, &r.ParentID, &r.NodeType, &r.FrameName, &r.Name, &r.QueryData)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeEventsNavTree provide iterator to all rows of the EVENTS_NAV_TREE matching given criteria.
func RangeEventsNavTree(db *sql.DB, where string) iter.Seq2[*EventsNavTreeRow, error] {
	return func(yield func(v *EventsNavTreeRow, err error) bool) {
	    query := "SELECT ID,PARENT_ID,NODE_TYPE,FRAME_NAME,NAME,QUERY_DATA FROM EVENTS_NAV_TREE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r EventsNavTreeRow
	        err := rows.Scan(&r.ID, &r.ParentID, &r.NodeType, &r.FrameName, &r.Name, &r.QueryData)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// EventCommentRow struct represents rows of the EVENT_COMMENT table.
type EventCommentRow struct {
    Idx	uint64
    Comment	sql.NullString
}

// IterateEventComment provide access to all rows of the EVENT_COMMENT matching given criteria.
func IterateEventComment(db *sql.DB, where string, callback func(v *EventCommentRow) error) error {
    query := "SELECT IDX,COMMENT FROM EVENT_COMMENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r EventCommentRow
        err := rows.Scan(&r.Idx, &r.Comment)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeEventComment provide iterator to all rows of the EVENT_COMMENT matching given criteria.
func RangeEventComment(db *sql.DB, where string) iter.Seq2[*EventCommentRow, error] {
	return func(yield func(v *EventCommentRow, err error) bool) {
	    query := "SELECT IDX,COMMENT FROM EVENT_COMMENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r EventCommentRow
	        err := rows.Scan(&r.Idx, &r.Comment)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ExternalDatabaseRow struct represents rows of the EXTERNAL_DATABASE table.
type ExternalDatabaseRow struct {
    ID	uint8
    ExternalAccess	sql.NullByte
    ExternalReplicate	sql.NullByte
    DbUserNameAccess	sql.NullString
    DbUserNameReplicate	sql.NullString
    RestrictNamedObjID	sql.NullInt32
}

// IterateExternalDatabase provide access to all rows of the EXTERNAL_DATABASE matching given criteria.
func IterateExternalDatabase(db *sql.DB, where string, callback func(v *ExternalDatabaseRow) error) error {
    query := "SELECT ID,EXTERNAL_ACCESS,EXTERNAL_REPLICATE,DB_USER_NAME_ACCESS,DB_USER_NAME_REPLICATE,RESTRICT_NAMED_OBJ_ID FROM EXTERNAL_DATABASE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ExternalDatabaseRow
        err := rows.Scan(&r.ID, &r.ExternalAccess, &r.ExternalReplicate, &r.DbUserNameAccess, &r.DbUserNameReplicate, &r.RestrictNamedObjID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeExternalDatabase provide iterator to all rows of the EXTERNAL_DATABASE matching given criteria.
func RangeExternalDatabase(db *sql.DB, where string) iter.Seq2[*ExternalDatabaseRow, error] {
	return func(yield func(v *ExternalDatabaseRow, err error) bool) {
	    query := "SELECT ID,EXTERNAL_ACCESS,EXTERNAL_REPLICATE,DB_USER_NAME_ACCESS,DB_USER_NAME_REPLICATE,RESTRICT_NAMED_OBJ_ID FROM EXTERNAL_DATABASE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ExternalDatabaseRow
	        err := rows.Scan(&r.ID, &r.ExternalAccess, &r.ExternalReplicate, &r.DbUserNameAccess, &r.DbUserNameReplicate, &r.RestrictNamedObjID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FacilityOperationsRow struct represents rows of the FACILITY_OPERATIONS table.
type FacilityOperationsRow struct {
    FacilityID	string
    OperationID	int
    Descr	string
}

// IterateFacilityOperations provide access to all rows of the FACILITY_OPERATIONS matching given criteria.
func IterateFacilityOperations(db *sql.DB, where string, callback func(v *FacilityOperationsRow) error) error {
    query := "SELECT FACILITY_ID,OPERATION_ID,DESCR FROM FACILITY_OPERATIONS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FacilityOperationsRow
        err := rows.Scan(&r.FacilityID, &r.OperationID, &r.Descr)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFacilityOperations provide iterator to all rows of the FACILITY_OPERATIONS matching given criteria.
func RangeFacilityOperations(db *sql.DB, where string) iter.Seq2[*FacilityOperationsRow, error] {
	return func(yield func(v *FacilityOperationsRow, err error) bool) {
	    query := "SELECT FACILITY_ID,OPERATION_ID,DESCR FROM FACILITY_OPERATIONS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FacilityOperationsRow
	        err := rows.Scan(&r.FacilityID, &r.OperationID, &r.Descr)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FacilityTransactionsRow struct represents rows of the FACILITY_TRANSACTIONS table.
type FacilityTransactionsRow struct {
    FacilityID	string
    TransactionID	int
    Descr	string
}

// IterateFacilityTransactions provide access to all rows of the FACILITY_TRANSACTIONS matching given criteria.
func IterateFacilityTransactions(db *sql.DB, where string, callback func(v *FacilityTransactionsRow) error) error {
    query := "SELECT FACILITY_ID,TRANSACTION_ID,DESCR FROM FACILITY_TRANSACTIONS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FacilityTransactionsRow
        err := rows.Scan(&r.FacilityID, &r.TransactionID, &r.Descr)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFacilityTransactions provide iterator to all rows of the FACILITY_TRANSACTIONS matching given criteria.
func RangeFacilityTransactions(db *sql.DB, where string) iter.Seq2[*FacilityTransactionsRow, error] {
	return func(yield func(v *FacilityTransactionsRow, err error) bool) {
	    query := "SELECT FACILITY_ID,TRANSACTION_ID,DESCR FROM FACILITY_TRANSACTIONS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FacilityTransactionsRow
	        err := rows.Scan(&r.FacilityID, &r.TransactionID, &r.Descr)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FilterFlagRow struct represents rows of the FILTER_FLAG table.
type FilterFlagRow struct {
    ID	uint
    SignatureID	string
    ProfileID	string
    TypeID	uint
    ReviewStatus	string
    Snoozed	sql.NullBool
    WakeTime	sql.NullInt64
}

// IterateFilterFlag provide access to all rows of the FILTER_FLAG matching given criteria.
func IterateFilterFlag(db *sql.DB, where string, callback func(v *FilterFlagRow) error) error {
    query := "SELECT ID,SIGNATURE_ID,PROFILE_ID,TYPE_ID,REVIEW_STATUS,SNOOZED,WAKE_TIME FROM FILTER_FLAG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FilterFlagRow
        err := rows.Scan(&r.ID, &r.SignatureID, &r.ProfileID, &r.TypeID, &r.ReviewStatus, &r.Snoozed, &r.WakeTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFilterFlag provide iterator to all rows of the FILTER_FLAG matching given criteria.
func RangeFilterFlag(db *sql.DB, where string) iter.Seq2[*FilterFlagRow, error] {
	return func(yield func(v *FilterFlagRow, err error) bool) {
	    query := "SELECT ID,SIGNATURE_ID,PROFILE_ID,TYPE_ID,REVIEW_STATUS,SNOOZED,WAKE_TIME FROM FILTER_FLAG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FilterFlagRow
	        err := rows.Scan(&r.ID, &r.SignatureID, &r.ProfileID, &r.TypeID, &r.ReviewStatus, &r.Snoozed, &r.WakeTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FilterFlagContextRow struct represents rows of the FILTER_FLAG_CONTEXT table.
type FilterFlagContextRow struct {
    ID	uint
    TypeID	uint
}

// IterateFilterFlagContext provide access to all rows of the FILTER_FLAG_CONTEXT matching given criteria.
func IterateFilterFlagContext(db *sql.DB, where string, callback func(v *FilterFlagContextRow) error) error {
    query := "SELECT ID,TYPE_ID FROM FILTER_FLAG_CONTEXT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FilterFlagContextRow
        err := rows.Scan(&r.ID, &r.TypeID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFilterFlagContext provide iterator to all rows of the FILTER_FLAG_CONTEXT matching given criteria.
func RangeFilterFlagContext(db *sql.DB, where string) iter.Seq2[*FilterFlagContextRow, error] {
	return func(yield func(v *FilterFlagContextRow, err error) bool) {
	    query := "SELECT ID,TYPE_ID FROM FILTER_FLAG_CONTEXT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FilterFlagContextRow
	        err := rows.Scan(&r.ID, &r.TypeID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FilterFlagContextActiveMalwareRow struct represents rows of the FILTER_FLAG_CONTEXT_ACTIVE_MALWARE table.
type FilterFlagContextActiveMalwareRow struct {
    FlagContextID	uint
    SpnIndex	uint
    MalwareFamily	string
    Reference	string
    Provider	string
    LastSeen	uint64
    LinkTitle	string
    LinkUrl	string
}

// IterateFilterFlagContextActiveMalware provide access to all rows of the FILTER_FLAG_CONTEXT_ACTIVE_MALWARE matching given criteria.
func IterateFilterFlagContextActiveMalware(db *sql.DB, where string, callback func(v *FilterFlagContextActiveMalwareRow) error) error {
    query := "SELECT FLAG_CONTEXT_ID,SPN_INDEX,MALWARE_FAMILY,REFERENCE,PROVIDER,LAST_SEEN,LINK_TITLE,LINK_URL FROM FILTER_FLAG_CONTEXT_ACTIVE_MALWARE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FilterFlagContextActiveMalwareRow
        err := rows.Scan(&r.FlagContextID, &r.SpnIndex, &r.MalwareFamily, &r.Reference, &r.Provider, &r.LastSeen, &r.LinkTitle, &r.LinkUrl)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFilterFlagContextActiveMalware provide iterator to all rows of the FILTER_FLAG_CONTEXT_ACTIVE_MALWARE matching given criteria.
func RangeFilterFlagContextActiveMalware(db *sql.DB, where string) iter.Seq2[*FilterFlagContextActiveMalwareRow, error] {
	return func(yield func(v *FilterFlagContextActiveMalwareRow, err error) bool) {
	    query := "SELECT FLAG_CONTEXT_ID,SPN_INDEX,MALWARE_FAMILY,REFERENCE,PROVIDER,LAST_SEEN,LINK_TITLE,LINK_URL FROM FILTER_FLAG_CONTEXT_ACTIVE_MALWARE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FilterFlagContextActiveMalwareRow
	        err := rows.Scan(&r.FlagContextID, &r.SpnIndex, &r.MalwareFamily, &r.Reference, &r.Provider, &r.LastSeen, &r.LinkTitle, &r.LinkUrl)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FilterFlagContextAfcRow struct represents rows of the FILTER_FLAG_CONTEXT_AFC table.
type FilterFlagContextAfcRow struct {
    FlagContextID	uint
    SmsTime	uint64
    DeviceShortID	uint
}

// IterateFilterFlagContextAfc provide access to all rows of the FILTER_FLAG_CONTEXT_AFC matching given criteria.
func IterateFilterFlagContextAfc(db *sql.DB, where string, callback func(v *FilterFlagContextAfcRow) error) error {
    query := "SELECT FLAG_CONTEXT_ID,SMS_TIME,DEVICE_SHORT_ID FROM FILTER_FLAG_CONTEXT_AFC"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FilterFlagContextAfcRow
        err := rows.Scan(&r.FlagContextID, &r.SmsTime, &r.DeviceShortID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFilterFlagContextAfc provide iterator to all rows of the FILTER_FLAG_CONTEXT_AFC matching given criteria.
func RangeFilterFlagContextAfc(db *sql.DB, where string) iter.Seq2[*FilterFlagContextAfcRow, error] {
	return func(yield func(v *FilterFlagContextAfcRow, err error) bool) {
	    query := "SELECT FLAG_CONTEXT_ID,SMS_TIME,DEVICE_SHORT_ID FROM FILTER_FLAG_CONTEXT_AFC"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FilterFlagContextAfcRow
	        err := rows.Scan(&r.FlagContextID, &r.SmsTime, &r.DeviceShortID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FilterFlagContextModifiedFilterRow struct represents rows of the FILTER_FLAG_CONTEXT_MODIFIED_FILTER table.
type FilterFlagContextModifiedFilterRow struct {
    FlagContextID	uint
    ReleasedVersion	int
    ReleasedDt	string
    ModifiedVersion	sql.NullInt32
    ModifiedDt	sql.NullString
    PkgDir	string
}

// IterateFilterFlagContextModifiedFilter provide access to all rows of the FILTER_FLAG_CONTEXT_MODIFIED_FILTER matching given criteria.
func IterateFilterFlagContextModifiedFilter(db *sql.DB, where string, callback func(v *FilterFlagContextModifiedFilterRow) error) error {
    query := "SELECT FLAG_CONTEXT_ID,RELEASED_VERSION,RELEASED_DT,MODIFIED_VERSION,MODIFIED_DT,PKG_DIR FROM FILTER_FLAG_CONTEXT_MODIFIED_FILTER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FilterFlagContextModifiedFilterRow
        err := rows.Scan(&r.FlagContextID, &r.ReleasedVersion, &r.ReleasedDt, &r.ModifiedVersion, &r.ModifiedDt, &r.PkgDir)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFilterFlagContextModifiedFilter provide iterator to all rows of the FILTER_FLAG_CONTEXT_MODIFIED_FILTER matching given criteria.
func RangeFilterFlagContextModifiedFilter(db *sql.DB, where string) iter.Seq2[*FilterFlagContextModifiedFilterRow, error] {
	return func(yield func(v *FilterFlagContextModifiedFilterRow, err error) bool) {
	    query := "SELECT FLAG_CONTEXT_ID,RELEASED_VERSION,RELEASED_DT,MODIFIED_VERSION,MODIFIED_DT,PKG_DIR FROM FILTER_FLAG_CONTEXT_MODIFIED_FILTER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FilterFlagContextModifiedFilterRow
	        err := rows.Scan(&r.FlagContextID, &r.ReleasedVersion, &r.ReleasedDt, &r.ModifiedVersion, &r.ModifiedDt, &r.PkgDir)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FilterFlagContextNewFilterRow struct represents rows of the FILTER_FLAG_CONTEXT_NEW_FILTER table.
type FilterFlagContextNewFilterRow struct {
    FlagContextID	uint
    ReleasedVersion	int
    ReleasedDt	string
    ModifiedVersion	sql.NullInt32
    ModifiedDt	sql.NullString
    PkgDir	string
}

// IterateFilterFlagContextNewFilter provide access to all rows of the FILTER_FLAG_CONTEXT_NEW_FILTER matching given criteria.
func IterateFilterFlagContextNewFilter(db *sql.DB, where string, callback func(v *FilterFlagContextNewFilterRow) error) error {
    query := "SELECT FLAG_CONTEXT_ID,RELEASED_VERSION,RELEASED_DT,MODIFIED_VERSION,MODIFIED_DT,PKG_DIR FROM FILTER_FLAG_CONTEXT_NEW_FILTER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FilterFlagContextNewFilterRow
        err := rows.Scan(&r.FlagContextID, &r.ReleasedVersion, &r.ReleasedDt, &r.ModifiedVersion, &r.ModifiedDt, &r.PkgDir)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFilterFlagContextNewFilter provide iterator to all rows of the FILTER_FLAG_CONTEXT_NEW_FILTER matching given criteria.
func RangeFilterFlagContextNewFilter(db *sql.DB, where string) iter.Seq2[*FilterFlagContextNewFilterRow, error] {
	return func(yield func(v *FilterFlagContextNewFilterRow, err error) bool) {
	    query := "SELECT FLAG_CONTEXT_ID,RELEASED_VERSION,RELEASED_DT,MODIFIED_VERSION,MODIFIED_DT,PKG_DIR FROM FILTER_FLAG_CONTEXT_NEW_FILTER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FilterFlagContextNewFilterRow
	        err := rows.Scan(&r.FlagContextID, &r.ReleasedVersion, &r.ReleasedDt, &r.ModifiedVersion, &r.ModifiedDt, &r.PkgDir)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FilterFlagJoinRow struct represents rows of the FILTER_FLAG_JOIN table.
type FilterFlagJoinRow struct {
    ID	uint
    FilterFlagID	uint
    FilterFlagContextID	uint
}

// IterateFilterFlagJoin provide access to all rows of the FILTER_FLAG_JOIN matching given criteria.
func IterateFilterFlagJoin(db *sql.DB, where string, callback func(v *FilterFlagJoinRow) error) error {
    query := "SELECT ID,FILTER_FLAG_ID,FILTER_FLAG_CONTEXT_ID FROM FILTER_FLAG_JOIN"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FilterFlagJoinRow
        err := rows.Scan(&r.ID, &r.FilterFlagID, &r.FilterFlagContextID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFilterFlagJoin provide iterator to all rows of the FILTER_FLAG_JOIN matching given criteria.
func RangeFilterFlagJoin(db *sql.DB, where string) iter.Seq2[*FilterFlagJoinRow, error] {
	return func(yield func(v *FilterFlagJoinRow, err error) bool) {
	    query := "SELECT ID,FILTER_FLAG_ID,FILTER_FLAG_CONTEXT_ID FROM FILTER_FLAG_JOIN"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FilterFlagJoinRow
	        err := rows.Scan(&r.ID, &r.FilterFlagID, &r.FilterFlagContextID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FilterFlagTypeRow struct represents rows of the FILTER_FLAG_TYPE table.
type FilterFlagTypeRow struct {
    ID	uint
    Type	string
    AutoFlagging	sql.NullBool
    Custom	sql.NullBool
}

// IterateFilterFlagType provide access to all rows of the FILTER_FLAG_TYPE matching given criteria.
func IterateFilterFlagType(db *sql.DB, where string, callback func(v *FilterFlagTypeRow) error) error {
    query := "SELECT ID,TYPE,AUTO_FLAGGING,CUSTOM FROM FILTER_FLAG_TYPE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FilterFlagTypeRow
        err := rows.Scan(&r.ID, &r.Type, &r.AutoFlagging, &r.Custom)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFilterFlagType provide iterator to all rows of the FILTER_FLAG_TYPE matching given criteria.
func RangeFilterFlagType(db *sql.DB, where string) iter.Seq2[*FilterFlagTypeRow, error] {
	return func(yield func(v *FilterFlagTypeRow, err error) bool) {
	    query := "SELECT ID,TYPE,AUTO_FLAGGING,CUSTOM FROM FILTER_FLAG_TYPE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FilterFlagTypeRow
	        err := rows.Scan(&r.ID, &r.Type, &r.AutoFlagging, &r.Custom)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FilterFlagTypeExcludedProfileRow struct represents rows of the FILTER_FLAG_TYPE_EXCLUDED_PROFILE table.
type FilterFlagTypeExcludedProfileRow struct {
    ID	uint
    TypeID	uint
    ProfileID	string
}

// IterateFilterFlagTypeExcludedProfile provide access to all rows of the FILTER_FLAG_TYPE_EXCLUDED_PROFILE matching given criteria.
func IterateFilterFlagTypeExcludedProfile(db *sql.DB, where string, callback func(v *FilterFlagTypeExcludedProfileRow) error) error {
    query := "SELECT ID,TYPE_ID,PROFILE_ID FROM FILTER_FLAG_TYPE_EXCLUDED_PROFILE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FilterFlagTypeExcludedProfileRow
        err := rows.Scan(&r.ID, &r.TypeID, &r.ProfileID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFilterFlagTypeExcludedProfile provide iterator to all rows of the FILTER_FLAG_TYPE_EXCLUDED_PROFILE matching given criteria.
func RangeFilterFlagTypeExcludedProfile(db *sql.DB, where string) iter.Seq2[*FilterFlagTypeExcludedProfileRow, error] {
	return func(yield func(v *FilterFlagTypeExcludedProfileRow, err error) bool) {
	    query := "SELECT ID,TYPE_ID,PROFILE_ID FROM FILTER_FLAG_TYPE_EXCLUDED_PROFILE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FilterFlagTypeExcludedProfileRow
	        err := rows.Scan(&r.ID, &r.TypeID, &r.ProfileID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FilterServiceRow struct represents rows of the FILTER_SERVICE table.
type FilterServiceRow struct {
    ServiceID	string
    Name	string
    Protocol	string
    Description	sql.NullString
    PortType	sql.NullString
    PortValue	sql.NullString
    UserDefined	string
    Deleted	string
    IterationID	string
    Version	sql.NullString
    PkgDir	string
    UpdateTime	int64
    NgfwVersion	sql.NullString
}

// IterateFilterService provide access to all rows of the FILTER_SERVICE matching given criteria.
func IterateFilterService(db *sql.DB, where string, callback func(v *FilterServiceRow) error) error {
    query := "SELECT SERVICE_ID,NAME,PROTOCOL,DESCRIPTION,PORT_TYPE,PORT_VALUE,USER_DEFINED,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME,NGFW_VERSION FROM FILTER_SERVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FilterServiceRow
        err := rows.Scan(&r.ServiceID, &r.Name, &r.Protocol, &r.Description, &r.PortType, &r.PortValue, &r.UserDefined, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime, &r.NgfwVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFilterService provide iterator to all rows of the FILTER_SERVICE matching given criteria.
func RangeFilterService(db *sql.DB, where string) iter.Seq2[*FilterServiceRow, error] {
	return func(yield func(v *FilterServiceRow, err error) bool) {
	    query := "SELECT SERVICE_ID,NAME,PROTOCOL,DESCRIPTION,PORT_TYPE,PORT_VALUE,USER_DEFINED,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME,NGFW_VERSION FROM FILTER_SERVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FilterServiceRow
	        err := rows.Scan(&r.ServiceID, &r.Name, &r.Protocol, &r.Description, &r.PortType, &r.PortValue, &r.UserDefined, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime, &r.NgfwVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FirewallProfileRow struct represents rows of the FIREWALL_PROFILE table.
type FirewallProfileRow struct {
    ID	uint
    Name	sql.NullString
    LastModified	sql.NullTime
    Version	sql.NullString
    Description	sql.NullString
    Target	sql.NullString
    Hidden	sql.NullByte
}

// IterateFirewallProfile provide access to all rows of the FIREWALL_PROFILE matching given criteria.
func IterateFirewallProfile(db *sql.DB, where string, callback func(v *FirewallProfileRow) error) error {
    query := "SELECT ID,NAME,LAST_MODIFIED,VERSION,DESCRIPTION,TARGET,HIDDEN FROM FIREWALL_PROFILE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FirewallProfileRow
        err := rows.Scan(&r.ID, &r.Name, &r.LastModified, &r.Version, &r.Description, &r.Target, &r.Hidden)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFirewallProfile provide iterator to all rows of the FIREWALL_PROFILE matching given criteria.
func RangeFirewallProfile(db *sql.DB, where string) iter.Seq2[*FirewallProfileRow, error] {
	return func(yield func(v *FirewallProfileRow, err error) bool) {
	    query := "SELECT ID,NAME,LAST_MODIFIED,VERSION,DESCRIPTION,TARGET,HIDDEN FROM FIREWALL_PROFILE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FirewallProfileRow
	        err := rows.Scan(&r.ID, &r.Name, &r.LastModified, &r.Version, &r.Description, &r.Target, &r.Hidden)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FirewallProfileFirewallRuleRow struct represents rows of the FIREWALL_PROFILE_FIREWALL_RULE table.
type FirewallProfileFirewallRuleRow struct {
    FirewallProfileID	sql.NullInt32
    RulesID	sql.NullInt32
}

// IterateFirewallProfileFirewallRule provide access to all rows of the FIREWALL_PROFILE_FIREWALL_RULE matching given criteria.
func IterateFirewallProfileFirewallRule(db *sql.DB, where string, callback func(v *FirewallProfileFirewallRuleRow) error) error {
    query := "SELECT FIREWALL_PROFILE_ID,RULES_ID FROM FIREWALL_PROFILE_FIREWALL_RULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FirewallProfileFirewallRuleRow
        err := rows.Scan(&r.FirewallProfileID, &r.RulesID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFirewallProfileFirewallRule provide iterator to all rows of the FIREWALL_PROFILE_FIREWALL_RULE matching given criteria.
func RangeFirewallProfileFirewallRule(db *sql.DB, where string) iter.Seq2[*FirewallProfileFirewallRuleRow, error] {
	return func(yield func(v *FirewallProfileFirewallRuleRow, err error) bool) {
	    query := "SELECT FIREWALL_PROFILE_ID,RULES_ID FROM FIREWALL_PROFILE_FIREWALL_RULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FirewallProfileFirewallRuleRow
	        err := rows.Scan(&r.FirewallProfileID, &r.RulesID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FirewallRuleRow struct represents rows of the FIREWALL_RULE table.
type FirewallRuleRow struct {
    ID	uint
    RuleOrder	sql.NullInt32
    RuleID	sql.NullString
    Enabled	sql.NullByte
    Action	sql.NullInt32
    InactivityTimeout	sql.NullInt32
    Logging	sql.NullByte
    RemoteLogging	sql.NullByte
    Comment	sql.NullString
    Bwmenabled	sql.NullByte
    Bwmperrule	sql.NullByte
    Bwmguaranteedbw	sql.NullInt32
    Bwmmaximumbandwidth	sql.NullInt32
    Bwmpriority	sql.NullInt32
    Userauthenabled	sql.NullByte
    Userauthsinglegroup	sql.NullByte
    Userauthprivilegegroup	sql.NullString
    SourceZoneName	sql.NullString
    DestZoneName	sql.NullString
    SrcAdrPool	sql.NullInt32
    DestAdrPool	sql.NullInt32
    SrcAdrSmsGroup	sql.NullInt32
    DestAdrSmsGroup	sql.NullInt32
    FirewallServiceID	sql.NullInt32
    FirewallServiceGroupID	sql.NullInt32
    FirewallScheduleID	sql.NullInt32
}

// IterateFirewallRule provide access to all rows of the FIREWALL_RULE matching given criteria.
func IterateFirewallRule(db *sql.DB, where string, callback func(v *FirewallRuleRow) error) error {
    query := "SELECT ID,RULE_ORDER,RULE_ID,ENABLED,ACTION,INACTIVITY_TIMEOUT,LOGGING,REMOTE_LOGGING,COMMENT,bwmEnabled,bwmPerRule,bwmGuaranteedBw,bwmMaximumBandwidth,bwmPriority,userAuthEnabled,userAuthSingleGroup,userAuthPrivilegeGroup,SOURCE_ZONE_NAME,DEST_ZONE_NAME,SRC_ADR_POOL,DEST_ADR_POOL,SRC_ADR_SMS_GROUP,DEST_ADR_SMS_GROUP,FIREWALL_SERVICE_ID,FIREWALL_SERVICE_GROUP_ID,FIREWALL_SCHEDULE_ID FROM FIREWALL_RULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FirewallRuleRow
        err := rows.Scan(&r.ID, &r.RuleOrder, &r.RuleID, &r.Enabled, &r.Action, &r.InactivityTimeout, &r.Logging, &r.RemoteLogging, &r.Comment, &r.Bwmenabled, &r.Bwmperrule, &r.Bwmguaranteedbw, &r.Bwmmaximumbandwidth, &r.Bwmpriority, &r.Userauthenabled, &r.Userauthsinglegroup, &r.Userauthprivilegegroup, &r.SourceZoneName, &r.DestZoneName, &r.SrcAdrPool, &r.DestAdrPool, &r.SrcAdrSmsGroup, &r.DestAdrSmsGroup, &r.FirewallServiceID, &r.FirewallServiceGroupID, &r.FirewallScheduleID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFirewallRule provide iterator to all rows of the FIREWALL_RULE matching given criteria.
func RangeFirewallRule(db *sql.DB, where string) iter.Seq2[*FirewallRuleRow, error] {
	return func(yield func(v *FirewallRuleRow, err error) bool) {
	    query := "SELECT ID,RULE_ORDER,RULE_ID,ENABLED,ACTION,INACTIVITY_TIMEOUT,LOGGING,REMOTE_LOGGING,COMMENT,bwmEnabled,bwmPerRule,bwmGuaranteedBw,bwmMaximumBandwidth,bwmPriority,userAuthEnabled,userAuthSingleGroup,userAuthPrivilegeGroup,SOURCE_ZONE_NAME,DEST_ZONE_NAME,SRC_ADR_POOL,DEST_ADR_POOL,SRC_ADR_SMS_GROUP,DEST_ADR_SMS_GROUP,FIREWALL_SERVICE_ID,FIREWALL_SERVICE_GROUP_ID,FIREWALL_SCHEDULE_ID FROM FIREWALL_RULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FirewallRuleRow
	        err := rows.Scan(&r.ID, &r.RuleOrder, &r.RuleID, &r.Enabled, &r.Action, &r.InactivityTimeout, &r.Logging, &r.RemoteLogging, &r.Comment, &r.Bwmenabled, &r.Bwmperrule, &r.Bwmguaranteedbw, &r.Bwmmaximumbandwidth, &r.Bwmpriority, &r.Userauthenabled, &r.Userauthsinglegroup, &r.Userauthprivilegegroup, &r.SourceZoneName, &r.DestZoneName, &r.SrcAdrPool, &r.DestAdrPool, &r.SrcAdrSmsGroup, &r.DestAdrSmsGroup, &r.FirewallServiceID, &r.FirewallServiceGroupID, &r.FirewallScheduleID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FirewallScheduleRow struct represents rows of the FIREWALL_SCHEDULE table.
type FirewallScheduleRow struct {
    ID	uint
    Name	sql.NullString
    CompositeScheduleID	sql.NullInt32
}

// IterateFirewallSchedule provide access to all rows of the FIREWALL_SCHEDULE matching given criteria.
func IterateFirewallSchedule(db *sql.DB, where string, callback func(v *FirewallScheduleRow) error) error {
    query := "SELECT ID,NAME,COMPOSITE_SCHEDULE_ID FROM FIREWALL_SCHEDULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FirewallScheduleRow
        err := rows.Scan(&r.ID, &r.Name, &r.CompositeScheduleID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFirewallSchedule provide iterator to all rows of the FIREWALL_SCHEDULE matching given criteria.
func RangeFirewallSchedule(db *sql.DB, where string) iter.Seq2[*FirewallScheduleRow, error] {
	return func(yield func(v *FirewallScheduleRow, err error) bool) {
	    query := "SELECT ID,NAME,COMPOSITE_SCHEDULE_ID FROM FIREWALL_SCHEDULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FirewallScheduleRow
	        err := rows.Scan(&r.ID, &r.Name, &r.CompositeScheduleID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FirewallServiceRow struct represents rows of the FIREWALL_SERVICE table.
type FirewallServiceRow struct {
    ID	uint
    Name	sql.NullString
    IPProtocol	sql.NullInt32
    FromPort	sql.NullInt32
    ToPort	sql.NullInt32
    DefaultFlag	sql.NullByte
}

// IterateFirewallService provide access to all rows of the FIREWALL_SERVICE matching given criteria.
func IterateFirewallService(db *sql.DB, where string, callback func(v *FirewallServiceRow) error) error {
    query := "SELECT ID,NAME,IP_PROTOCOL,FROM_PORT,TO_PORT,DEFAULT_FLAG FROM FIREWALL_SERVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FirewallServiceRow
        err := rows.Scan(&r.ID, &r.Name, &r.IPProtocol, &r.FromPort, &r.ToPort, &r.DefaultFlag)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFirewallService provide iterator to all rows of the FIREWALL_SERVICE matching given criteria.
func RangeFirewallService(db *sql.DB, where string) iter.Seq2[*FirewallServiceRow, error] {
	return func(yield func(v *FirewallServiceRow, err error) bool) {
	    query := "SELECT ID,NAME,IP_PROTOCOL,FROM_PORT,TO_PORT,DEFAULT_FLAG FROM FIREWALL_SERVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FirewallServiceRow
	        err := rows.Scan(&r.ID, &r.Name, &r.IPProtocol, &r.FromPort, &r.ToPort, &r.DefaultFlag)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FirewallServiceGroupRow struct represents rows of the FIREWALL_SERVICE_GROUP table.
type FirewallServiceGroupRow struct {
    ID	uint
    Name	sql.NullString
    DefaultFlag	sql.NullByte
}

// IterateFirewallServiceGroup provide access to all rows of the FIREWALL_SERVICE_GROUP matching given criteria.
func IterateFirewallServiceGroup(db *sql.DB, where string, callback func(v *FirewallServiceGroupRow) error) error {
    query := "SELECT ID,NAME,DEFAULT_FLAG FROM FIREWALL_SERVICE_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FirewallServiceGroupRow
        err := rows.Scan(&r.ID, &r.Name, &r.DefaultFlag)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFirewallServiceGroup provide iterator to all rows of the FIREWALL_SERVICE_GROUP matching given criteria.
func RangeFirewallServiceGroup(db *sql.DB, where string) iter.Seq2[*FirewallServiceGroupRow, error] {
	return func(yield func(v *FirewallServiceGroupRow, err error) bool) {
	    query := "SELECT ID,NAME,DEFAULT_FLAG FROM FIREWALL_SERVICE_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FirewallServiceGroupRow
	        err := rows.Scan(&r.ID, &r.Name, &r.DefaultFlag)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FirewallServiceGroupFirewallServiceRow struct represents rows of the FIREWALL_SERVICE_GROUP_FIREWALL_SERVICE table.
type FirewallServiceGroupFirewallServiceRow struct {
    FirewallServiceGroupID	sql.NullInt32
    ServicesID	sql.NullInt32
}

// IterateFirewallServiceGroupFirewallService provide access to all rows of the FIREWALL_SERVICE_GROUP_FIREWALL_SERVICE matching given criteria.
func IterateFirewallServiceGroupFirewallService(db *sql.DB, where string, callback func(v *FirewallServiceGroupFirewallServiceRow) error) error {
    query := "SELECT FIREWALL_SERVICE_GROUP_ID,SERVICES_ID FROM FIREWALL_SERVICE_GROUP_FIREWALL_SERVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FirewallServiceGroupFirewallServiceRow
        err := rows.Scan(&r.FirewallServiceGroupID, &r.ServicesID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFirewallServiceGroupFirewallService provide iterator to all rows of the FIREWALL_SERVICE_GROUP_FIREWALL_SERVICE matching given criteria.
func RangeFirewallServiceGroupFirewallService(db *sql.DB, where string) iter.Seq2[*FirewallServiceGroupFirewallServiceRow, error] {
	return func(yield func(v *FirewallServiceGroupFirewallServiceRow, err error) bool) {
	    query := "SELECT FIREWALL_SERVICE_GROUP_ID,SERVICES_ID FROM FIREWALL_SERVICE_GROUP_FIREWALL_SERVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FirewallServiceGroupFirewallServiceRow
	        err := rows.Scan(&r.FirewallServiceGroupID, &r.ServicesID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FwProfileInventoryRow struct represents rows of the FW_PROFILE_INVENTORY table.
type FwProfileInventoryRow struct {
    ID	uint
    ProfileID	sql.NullInt32
    LastDistribution	sql.NullTime
}

// IterateFwProfileInventory provide access to all rows of the FW_PROFILE_INVENTORY matching given criteria.
func IterateFwProfileInventory(db *sql.DB, where string, callback func(v *FwProfileInventoryRow) error) error {
    query := "SELECT ID,PROFILE_ID,LAST_DISTRIBUTION FROM FW_PROFILE_INVENTORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FwProfileInventoryRow
        err := rows.Scan(&r.ID, &r.ProfileID, &r.LastDistribution)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFwProfileInventory provide iterator to all rows of the FW_PROFILE_INVENTORY matching given criteria.
func RangeFwProfileInventory(db *sql.DB, where string) iter.Seq2[*FwProfileInventoryRow, error] {
	return func(yield func(v *FwProfileInventoryRow, err error) bool) {
	    query := "SELECT ID,PROFILE_ID,LAST_DISTRIBUTION FROM FW_PROFILE_INVENTORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FwProfileInventoryRow
	        err := rows.Scan(&r.ID, &r.ProfileID, &r.LastDistribution)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// FwProfileInventoryDeviceRow struct represents rows of the FW_PROFILE_INVENTORY_DEVICE table.
type FwProfileInventoryDeviceRow struct {
    FwProfileInventoryID	sql.NullInt32
    TargetsID	sql.NullInt32
}

// IterateFwProfileInventoryDevice provide access to all rows of the FW_PROFILE_INVENTORY_DEVICE matching given criteria.
func IterateFwProfileInventoryDevice(db *sql.DB, where string, callback func(v *FwProfileInventoryDeviceRow) error) error {
    query := "SELECT FW_PROFILE_INVENTORY_ID,TARGETS_ID FROM FW_PROFILE_INVENTORY_DEVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r FwProfileInventoryDeviceRow
        err := rows.Scan(&r.FwProfileInventoryID, &r.TargetsID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeFwProfileInventoryDevice provide iterator to all rows of the FW_PROFILE_INVENTORY_DEVICE matching given criteria.
func RangeFwProfileInventoryDevice(db *sql.DB, where string) iter.Seq2[*FwProfileInventoryDeviceRow, error] {
	return func(yield func(v *FwProfileInventoryDeviceRow, err error) bool) {
	    query := "SELECT FW_PROFILE_INVENTORY_ID,TARGETS_ID FROM FW_PROFILE_INVENTORY_DEVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r FwProfileInventoryDeviceRow
	        err := rows.Scan(&r.FwProfileInventoryID, &r.TargetsID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// GlobalVirtualSegmentRow struct represents rows of the GLOBAL_VIRTUAL_SEGMENT table.
type GlobalVirtualSegmentRow struct {
    ID	uint
    Name	sql.NullString
    Description	sql.NullString
    Position	sql.NullInt32
    SrcIPNamedObjID	sql.NullInt32
    DstIPNamedObjID	sql.NullInt32
    VLANNamedObjID	sql.NullInt32
    IterationID	sql.NullInt32
    PortaIpaddrNamedObjID	sql.NullInt32
    PortbIpaddrNamedObjID	sql.NullInt32
}

// IterateGlobalVirtualSegment provide access to all rows of the GLOBAL_VIRTUAL_SEGMENT matching given criteria.
func IterateGlobalVirtualSegment(db *sql.DB, where string, callback func(v *GlobalVirtualSegmentRow) error) error {
    query := "SELECT ID,NAME,DESCRIPTION,POSITION,SRC_IP_NAMED_OBJ_ID,DST_IP_NAMED_OBJ_ID,VLAN_NAMED_OBJ_ID,ITERATION_ID,PORTA_IPADDR_NAMED_OBJ_ID,PORTB_IPADDR_NAMED_OBJ_ID FROM GLOBAL_VIRTUAL_SEGMENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r GlobalVirtualSegmentRow
        err := rows.Scan(&r.ID, &r.Name, &r.Description, &r.Position, &r.SrcIPNamedObjID, &r.DstIPNamedObjID, &r.VLANNamedObjID, &r.IterationID, &r.PortaIpaddrNamedObjID, &r.PortbIpaddrNamedObjID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeGlobalVirtualSegment provide iterator to all rows of the GLOBAL_VIRTUAL_SEGMENT matching given criteria.
func RangeGlobalVirtualSegment(db *sql.DB, where string) iter.Seq2[*GlobalVirtualSegmentRow, error] {
	return func(yield func(v *GlobalVirtualSegmentRow, err error) bool) {
	    query := "SELECT ID,NAME,DESCRIPTION,POSITION,SRC_IP_NAMED_OBJ_ID,DST_IP_NAMED_OBJ_ID,VLAN_NAMED_OBJ_ID,ITERATION_ID,PORTA_IPADDR_NAMED_OBJ_ID,PORTB_IPADDR_NAMED_OBJ_ID FROM GLOBAL_VIRTUAL_SEGMENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r GlobalVirtualSegmentRow
	        err := rows.Scan(&r.ID, &r.Name, &r.Description, &r.Position, &r.SrcIPNamedObjID, &r.DstIPNamedObjID, &r.VLANNamedObjID, &r.IterationID, &r.PortaIpaddrNamedObjID, &r.PortbIpaddrNamedObjID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// GlobalVirtualSegmentVirtualSegmentRow struct represents rows of the GLOBAL_VIRTUAL_SEGMENT_VIRTUAL_SEGMENT table.
type GlobalVirtualSegmentVirtualSegmentRow struct {
    GlobalVirtualSegmentID	uint
    VirtualSegmentID	uint
}

// IterateGlobalVirtualSegmentVirtualSegment provide access to all rows of the GLOBAL_VIRTUAL_SEGMENT_VIRTUAL_SEGMENT matching given criteria.
func IterateGlobalVirtualSegmentVirtualSegment(db *sql.DB, where string, callback func(v *GlobalVirtualSegmentVirtualSegmentRow) error) error {
    query := "SELECT GLOBAL_VIRTUAL_SEGMENT_ID,VIRTUAL_SEGMENT_ID FROM GLOBAL_VIRTUAL_SEGMENT_VIRTUAL_SEGMENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r GlobalVirtualSegmentVirtualSegmentRow
        err := rows.Scan(&r.GlobalVirtualSegmentID, &r.VirtualSegmentID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeGlobalVirtualSegmentVirtualSegment provide iterator to all rows of the GLOBAL_VIRTUAL_SEGMENT_VIRTUAL_SEGMENT matching given criteria.
func RangeGlobalVirtualSegmentVirtualSegment(db *sql.DB, where string) iter.Seq2[*GlobalVirtualSegmentVirtualSegmentRow, error] {
	return func(yield func(v *GlobalVirtualSegmentVirtualSegmentRow, err error) bool) {
	    query := "SELECT GLOBAL_VIRTUAL_SEGMENT_ID,VIRTUAL_SEGMENT_ID FROM GLOBAL_VIRTUAL_SEGMENT_VIRTUAL_SEGMENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r GlobalVirtualSegmentVirtualSegmentRow
	        err := rows.Scan(&r.GlobalVirtualSegmentID, &r.VirtualSegmentID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// GreVirtualInterfaceRow struct represents rows of the GRE_VIRTUAL_INTERFACE table.
type GreVirtualInterfaceRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    IPAddress	sql.NullInt32
    SecurityAssociation	sql.NullString
    RemoteTunnelEndpoint	sql.NullInt32
    PeerIP	sql.NullInt32
    Rip	sql.NullByte
    Igmp	sql.NullByte
    PimDm	sql.NullByte
    IgmpQueryInterval	sql.NullInt32
    IgmpQueryTimeout	sql.NullInt32
    IgmpMaxQueryTime	sql.NullInt32
    RipSplitHorizion	sql.NullByte
    RipPoisonReverse	sql.NullByte
    RipAdvertiseDisabled	sql.NullByte
    RipSendMode	sql.NullByte
    RipRecvMode	sql.NullByte
    RipAuthMode	sql.NullByte
    RipAuthKey	sql.NullString
}

// IterateGreVirtualInterface provide access to all rows of the GRE_VIRTUAL_INTERFACE matching given criteria.
func IterateGreVirtualInterface(db *sql.DB, where string, callback func(v *GreVirtualInterfaceRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,IP_ADDRESS,SECURITY_ASSOCIATION,REMOTE_TUNNEL_ENDPOINT,PEER_IP,RIP,IGMP,PIM_DM,IGMP_QUERY_INTERVAL,IGMP_QUERY_TIMEOUT,IGMP_MAX_QUERY_TIME,RIP_SPLIT_HORIZION,RIP_POISON_REVERSE,RIP_ADVERTISE_DISABLED,RIP_SEND_MODE,RIP_RECV_MODE,RIP_AUTH_MODE,RIP_AUTH_KEY FROM GRE_VIRTUAL_INTERFACE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r GreVirtualInterfaceRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.IPAddress, &r.SecurityAssociation, &r.RemoteTunnelEndpoint, &r.PeerIP, &r.Rip, &r.Igmp, &r.PimDm, &r.IgmpQueryInterval, &r.IgmpQueryTimeout, &r.IgmpMaxQueryTime, &r.RipSplitHorizion, &r.RipPoisonReverse, &r.RipAdvertiseDisabled, &r.RipSendMode, &r.RipRecvMode, &r.RipAuthMode, &r.RipAuthKey)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeGreVirtualInterface provide iterator to all rows of the GRE_VIRTUAL_INTERFACE matching given criteria.
func RangeGreVirtualInterface(db *sql.DB, where string) iter.Seq2[*GreVirtualInterfaceRow, error] {
	return func(yield func(v *GreVirtualInterfaceRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,IP_ADDRESS,SECURITY_ASSOCIATION,REMOTE_TUNNEL_ENDPOINT,PEER_IP,RIP,IGMP,PIM_DM,IGMP_QUERY_INTERVAL,IGMP_QUERY_TIMEOUT,IGMP_MAX_QUERY_TIME,RIP_SPLIT_HORIZION,RIP_POISON_REVERSE,RIP_ADVERTISE_DISABLED,RIP_SEND_MODE,RIP_RECV_MODE,RIP_AUTH_MODE,RIP_AUTH_KEY FROM GRE_VIRTUAL_INTERFACE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r GreVirtualInterfaceRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.IPAddress, &r.SecurityAssociation, &r.RemoteTunnelEndpoint, &r.PeerIP, &r.Rip, &r.Igmp, &r.PimDm, &r.IgmpQueryInterval, &r.IgmpQueryTimeout, &r.IgmpMaxQueryTime, &r.RipSplitHorizion, &r.RipPoisonReverse, &r.RipAdvertiseDisabled, &r.RipSendMode, &r.RipRecvMode, &r.RipAuthMode, &r.RipAuthKey)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// GreVirtualInterfaceSecurityZoneRow struct represents rows of the GRE_VIRTUAL_INTERFACE_SECURITY_ZONE table.
type GreVirtualInterfaceSecurityZoneRow struct {
    GreVirtualInterfaceID	uint
    SecurityZoneID	uint
}

// IterateGreVirtualInterfaceSecurityZone provide access to all rows of the GRE_VIRTUAL_INTERFACE_SECURITY_ZONE matching given criteria.
func IterateGreVirtualInterfaceSecurityZone(db *sql.DB, where string, callback func(v *GreVirtualInterfaceSecurityZoneRow) error) error {
    query := "SELECT GRE_VIRTUAL_INTERFACE_ID,SECURITY_ZONE_ID FROM GRE_VIRTUAL_INTERFACE_SECURITY_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r GreVirtualInterfaceSecurityZoneRow
        err := rows.Scan(&r.GreVirtualInterfaceID, &r.SecurityZoneID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeGreVirtualInterfaceSecurityZone provide iterator to all rows of the GRE_VIRTUAL_INTERFACE_SECURITY_ZONE matching given criteria.
func RangeGreVirtualInterfaceSecurityZone(db *sql.DB, where string) iter.Seq2[*GreVirtualInterfaceSecurityZoneRow, error] {
	return func(yield func(v *GreVirtualInterfaceSecurityZoneRow, err error) bool) {
	    query := "SELECT GRE_VIRTUAL_INTERFACE_ID,SECURITY_ZONE_ID FROM GRE_VIRTUAL_INTERFACE_SECURITY_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r GreVirtualInterfaceSecurityZoneRow
	        err := rows.Scan(&r.GreVirtualInterfaceID, &r.SecurityZoneID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// GroupListRow struct represents rows of the GROUP_LIST table.
type GroupListRow struct {
    GroupID	string
    Type	string
    Displayname	sql.NullString
}

// IterateGroupList provide access to all rows of the GROUP_LIST matching given criteria.
func IterateGroupList(db *sql.DB, where string, callback func(v *GroupListRow) error) error {
    query := "SELECT GROUP_ID,TYPE,DISPLAYNAME FROM GROUP_LIST"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r GroupListRow
        err := rows.Scan(&r.GroupID, &r.Type, &r.Displayname)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeGroupList provide iterator to all rows of the GROUP_LIST matching given criteria.
func RangeGroupList(db *sql.DB, where string) iter.Seq2[*GroupListRow, error] {
	return func(yield func(v *GroupListRow, err error) bool) {
	    query := "SELECT GROUP_ID,TYPE,DISPLAYNAME FROM GROUP_LIST"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r GroupListRow
	        err := rows.Scan(&r.GroupID, &r.Type, &r.Displayname)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// GroupMemberRow struct represents rows of the GROUP_MEMBER table.
type GroupMemberRow struct {
    GroupID	string
    Value	string
    Name	sql.NullString
}

// IterateGroupMember provide access to all rows of the GROUP_MEMBER matching given criteria.
func IterateGroupMember(db *sql.DB, where string, callback func(v *GroupMemberRow) error) error {
    query := "SELECT GROUP_ID,VALUE,NAME FROM GROUP_MEMBER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r GroupMemberRow
        err := rows.Scan(&r.GroupID, &r.Value, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeGroupMember provide iterator to all rows of the GROUP_MEMBER matching given criteria.
func RangeGroupMember(db *sql.DB, where string) iter.Seq2[*GroupMemberRow, error] {
	return func(yield func(v *GroupMemberRow, err error) bool) {
	    query := "SELECT GROUP_ID,VALUE,NAME FROM GROUP_MEMBER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r GroupMemberRow
	        err := rows.Scan(&r.GroupID, &r.Value, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// HilosequencesRow struct represents rows of the HILOSEQUENCES table.
type HilosequencesRow struct {
    Sequencename	string
    Highvalues	int
}

// IterateHilosequences provide access to all rows of the HILOSEQUENCES matching given criteria.
func IterateHilosequences(db *sql.DB, where string, callback func(v *HilosequencesRow) error) error {
    query := "SELECT SEQUENCENAME,HIGHVALUES FROM HILOSEQUENCES"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r HilosequencesRow
        err := rows.Scan(&r.Sequencename, &r.Highvalues)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeHilosequences provide iterator to all rows of the HILOSEQUENCES matching given criteria.
func RangeHilosequences(db *sql.DB, where string) iter.Seq2[*HilosequencesRow, error] {
	return func(yield func(v *HilosequencesRow, err error) bool) {
	    query := "SELECT SEQUENCENAME,HIGHVALUES FROM HILOSEQUENCES"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r HilosequencesRow
	        err := rows.Scan(&r.Sequencename, &r.Highvalues)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IeeCompositeActionRow struct represents rows of the IEE_COMPOSITE_ACTION table.
type IeeCompositeActionRow struct {
    ID	uint
    Name	sql.NullString
}

// IterateIeeCompositeAction provide access to all rows of the IEE_COMPOSITE_ACTION matching given criteria.
func IterateIeeCompositeAction(db *sql.DB, where string, callback func(v *IeeCompositeActionRow) error) error {
    query := "SELECT ID,NAME FROM IEE_COMPOSITE_ACTION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IeeCompositeActionRow
        err := rows.Scan(&r.ID, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIeeCompositeAction provide iterator to all rows of the IEE_COMPOSITE_ACTION matching given criteria.
func RangeIeeCompositeAction(db *sql.DB, where string) iter.Seq2[*IeeCompositeActionRow, error] {
	return func(yield func(v *IeeCompositeActionRow, err error) bool) {
	    query := "SELECT ID,NAME FROM IEE_COMPOSITE_ACTION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IeeCompositeActionRow
	        err := rows.Scan(&r.ID, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IeeCompositeActionItemRow struct represents rows of the IEE_COMPOSITE_ACTION_ITEM table.
type IeeCompositeActionItemRow struct {
    ID	uint
    IeeCompositeActionID	uint
    IeeConfiguredActionID	uint
    Priority	uint16
    ItemDependencyID	sql.NullInt32
    IeeDependencyTypeRef	sql.NullInt32
}

// IterateIeeCompositeActionItem provide access to all rows of the IEE_COMPOSITE_ACTION_ITEM matching given criteria.
func IterateIeeCompositeActionItem(db *sql.DB, where string, callback func(v *IeeCompositeActionItemRow) error) error {
    query := "SELECT ID,IEE_COMPOSITE_ACTION_ID,IEE_CONFIGURED_ACTION_ID,PRIORITY,ITEM_DEPENDENCY_ID,IEE_DEPENDENCY_TYPE_REF FROM IEE_COMPOSITE_ACTION_ITEM"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IeeCompositeActionItemRow
        err := rows.Scan(&r.ID, &r.IeeCompositeActionID, &r.IeeConfiguredActionID, &r.Priority, &r.ItemDependencyID, &r.IeeDependencyTypeRef)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIeeCompositeActionItem provide iterator to all rows of the IEE_COMPOSITE_ACTION_ITEM matching given criteria.
func RangeIeeCompositeActionItem(db *sql.DB, where string) iter.Seq2[*IeeCompositeActionItemRow, error] {
	return func(yield func(v *IeeCompositeActionItemRow, err error) bool) {
	    query := "SELECT ID,IEE_COMPOSITE_ACTION_ID,IEE_CONFIGURED_ACTION_ID,PRIORITY,ITEM_DEPENDENCY_ID,IEE_DEPENDENCY_TYPE_REF FROM IEE_COMPOSITE_ACTION_ITEM"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IeeCompositeActionItemRow
	        err := rows.Scan(&r.ID, &r.IeeCompositeActionID, &r.IeeConfiguredActionID, &r.Priority, &r.ItemDependencyID, &r.IeeDependencyTypeRef)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IeeConfiguredActionRow struct represents rows of the IEE_CONFIGURED_ACTION table.
type IeeConfiguredActionRow struct {
    ID	uint
    Name	string
    ActionTypeID	uint
    LastChange	string
    Properties	sql.NullString
}

// IterateIeeConfiguredAction provide access to all rows of the IEE_CONFIGURED_ACTION matching given criteria.
func IterateIeeConfiguredAction(db *sql.DB, where string, callback func(v *IeeConfiguredActionRow) error) error {
    query := "SELECT ID,NAME,ACTION_TYPE_ID,LAST_CHANGE,PROPERTIES FROM IEE_CONFIGURED_ACTION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IeeConfiguredActionRow
        err := rows.Scan(&r.ID, &r.Name, &r.ActionTypeID, &r.LastChange, &r.Properties)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIeeConfiguredAction provide iterator to all rows of the IEE_CONFIGURED_ACTION matching given criteria.
func RangeIeeConfiguredAction(db *sql.DB, where string) iter.Seq2[*IeeConfiguredActionRow, error] {
	return func(yield func(v *IeeConfiguredActionRow, err error) bool) {
	    query := "SELECT ID,NAME,ACTION_TYPE_ID,LAST_CHANGE,PROPERTIES FROM IEE_CONFIGURED_ACTION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IeeConfiguredActionRow
	        err := rows.Scan(&r.ID, &r.Name, &r.ActionTypeID, &r.LastChange, &r.Properties)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IkeProposalRow struct represents rows of the IKE_PROPOSAL table.
type IkeProposalRow struct {
    ID	uint
    Name	sql.NullString
    DeviceShortID	sql.NullInt32
    Phase1Encryption	sql.NullInt32
    Phase1Integrity	sql.NullInt32
    Phase1DiffieHelman	sql.NullInt32
    Phase1AuthenticationType	sql.NullInt32
    Phase1LocalIDType	sql.NullInt32
    Phase1PeerIDType	sql.NullInt32
    Phase1SignedCert	sql.NullByte
    Phase1AggressiveMode	sql.NullByte
    Phase1Lifetime	sql.NullInt32
    Phase1LocalCertName	sql.NullString
    Phase1CaCertName	sql.NullString
    Phase1NatTraversal	sql.NullByte
    Phase1DeadPeerDetection	sql.NullByte
    Phase1AutoConnectOnStartup	sql.NullByte
    Phase1TightPhase2Control	sql.NullByte
    Phase2Encryption	sql.NullInt32
    Phase2Integrity	sql.NullInt32
    Phase2DiffieHelman	sql.NullInt32
    Phase2Lifetime	sql.NullInt32
    Phase2PerfectForwardSecrecy	sql.NullByte
    Phase2AllowZeroID	sql.NullByte
    Phase2StrictIDCheck	sql.NullByte
    Phase2AutoConnect	sql.NullByte
}

// IterateIkeProposal provide access to all rows of the IKE_PROPOSAL matching given criteria.
func IterateIkeProposal(db *sql.DB, where string, callback func(v *IkeProposalRow) error) error {
    query := "SELECT ID,NAME,DEVICE_SHORT_ID,PHASE1_ENCRYPTION,PHASE1_INTEGRITY,PHASE1_DIFFIE_HELMAN,PHASE1_AUTHENTICATION_TYPE,PHASE1_LOCAL_ID_TYPE,PHASE1_PEER_ID_TYPE,PHASE1_SIGNED_CERT,PHASE1_AGGRESSIVE_MODE,PHASE1_LIFETIME,PHASE1_LOCAL_CERT_NAME,PHASE1_CA_CERT_NAME,PHASE1_NAT_TRAVERSAL,PHASE1_DEAD_PEER_DETECTION,PHASE1_AUTO_CONNECT_ON_STARTUP,PHASE1_TIGHT_PHASE2_CONTROL,PHASE2_ENCRYPTION,PHASE2_INTEGRITY,PHASE2_DIFFIE_HELMAN,PHASE2_LIFETIME,PHASE2_PERFECT_FORWARD_SECRECY,PHASE2_ALLOW_ZERO_ID,PHASE2_STRICT_ID_CHECK,PHASE2_AUTO_CONNECT FROM IKE_PROPOSAL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IkeProposalRow
        err := rows.Scan(&r.ID, &r.Name, &r.DeviceShortID, &r.Phase1Encryption, &r.Phase1Integrity, &r.Phase1DiffieHelman, &r.Phase1AuthenticationType, &r.Phase1LocalIDType, &r.Phase1PeerIDType, &r.Phase1SignedCert, &r.Phase1AggressiveMode, &r.Phase1Lifetime, &r.Phase1LocalCertName, &r.Phase1CaCertName, &r.Phase1NatTraversal, &r.Phase1DeadPeerDetection, &r.Phase1AutoConnectOnStartup, &r.Phase1TightPhase2Control, &r.Phase2Encryption, &r.Phase2Integrity, &r.Phase2DiffieHelman, &r.Phase2Lifetime, &r.Phase2PerfectForwardSecrecy, &r.Phase2AllowZeroID, &r.Phase2StrictIDCheck, &r.Phase2AutoConnect)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIkeProposal provide iterator to all rows of the IKE_PROPOSAL matching given criteria.
func RangeIkeProposal(db *sql.DB, where string) iter.Seq2[*IkeProposalRow, error] {
	return func(yield func(v *IkeProposalRow, err error) bool) {
	    query := "SELECT ID,NAME,DEVICE_SHORT_ID,PHASE1_ENCRYPTION,PHASE1_INTEGRITY,PHASE1_DIFFIE_HELMAN,PHASE1_AUTHENTICATION_TYPE,PHASE1_LOCAL_ID_TYPE,PHASE1_PEER_ID_TYPE,PHASE1_SIGNED_CERT,PHASE1_AGGRESSIVE_MODE,PHASE1_LIFETIME,PHASE1_LOCAL_CERT_NAME,PHASE1_CA_CERT_NAME,PHASE1_NAT_TRAVERSAL,PHASE1_DEAD_PEER_DETECTION,PHASE1_AUTO_CONNECT_ON_STARTUP,PHASE1_TIGHT_PHASE2_CONTROL,PHASE2_ENCRYPTION,PHASE2_INTEGRITY,PHASE2_DIFFIE_HELMAN,PHASE2_LIFETIME,PHASE2_PERFECT_FORWARD_SECRECY,PHASE2_ALLOW_ZERO_ID,PHASE2_STRICT_ID_CHECK,PHASE2_AUTO_CONNECT FROM IKE_PROPOSAL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IkeProposalRow
	        err := rows.Scan(&r.ID, &r.Name, &r.DeviceShortID, &r.Phase1Encryption, &r.Phase1Integrity, &r.Phase1DiffieHelman, &r.Phase1AuthenticationType, &r.Phase1LocalIDType, &r.Phase1PeerIDType, &r.Phase1SignedCert, &r.Phase1AggressiveMode, &r.Phase1Lifetime, &r.Phase1LocalCertName, &r.Phase1CaCertName, &r.Phase1NatTraversal, &r.Phase1DeadPeerDetection, &r.Phase1AutoConnectOnStartup, &r.Phase1TightPhase2Control, &r.Phase2Encryption, &r.Phase2Integrity, &r.Phase2DiffieHelman, &r.Phase2Lifetime, &r.Phase2PerfectForwardSecrecy, &r.Phase2AllowZeroID, &r.Phase2StrictIDCheck, &r.Phase2AutoConnect)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IpcorrDeviceRow struct represents rows of the IPCORR_DEVICE table.
type IpcorrDeviceRow struct {
    ID	int
    IpcorrDevicePkgID	int
    IPAddr1	int64
    IPAddr2	int64
    Name	sql.NullString
    Location	sql.NullString
    LastContact	string
    Properties	sql.NullString
}

// IterateIpcorrDevice provide access to all rows of the IPCORR_DEVICE matching given criteria.
func IterateIpcorrDevice(db *sql.DB, where string, callback func(v *IpcorrDeviceRow) error) error {
    query := "SELECT ID,IPCORR_DEVICE_PKG_ID,IP_ADDR_1,IP_ADDR_2,NAME,LOCATION,LAST_CONTACT,PROPERTIES FROM IPCORR_DEVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IpcorrDeviceRow
        err := rows.Scan(&r.ID, &r.IpcorrDevicePkgID, &r.IPAddr1, &r.IPAddr2, &r.Name, &r.Location, &r.LastContact, &r.Properties)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIpcorrDevice provide iterator to all rows of the IPCORR_DEVICE matching given criteria.
func RangeIpcorrDevice(db *sql.DB, where string) iter.Seq2[*IpcorrDeviceRow, error] {
	return func(yield func(v *IpcorrDeviceRow, err error) bool) {
	    query := "SELECT ID,IPCORR_DEVICE_PKG_ID,IP_ADDR_1,IP_ADDR_2,NAME,LOCATION,LAST_CONTACT,PROPERTIES FROM IPCORR_DEVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IpcorrDeviceRow
	        err := rows.Scan(&r.ID, &r.IpcorrDevicePkgID, &r.IPAddr1, &r.IPAddr2, &r.Name, &r.Location, &r.LastContact, &r.Properties)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IpcorrDevicePkgRow struct represents rows of the IPCORR_DEVICE_PKG table.
type IpcorrDevicePkgRow struct {
    ID	int
    Name	sql.NullString
    NetscriptID	uint
    UsedByIpcorr	int8
    UsedByAccessControl	int8
}

// IterateIpcorrDevicePkg provide access to all rows of the IPCORR_DEVICE_PKG matching given criteria.
func IterateIpcorrDevicePkg(db *sql.DB, where string, callback func(v *IpcorrDevicePkgRow) error) error {
    query := "SELECT ID,NAME,NETSCRIPT_ID,USED_BY_IPCORR,USED_BY_ACCESS_CONTROL FROM IPCORR_DEVICE_PKG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IpcorrDevicePkgRow
        err := rows.Scan(&r.ID, &r.Name, &r.NetscriptID, &r.UsedByIpcorr, &r.UsedByAccessControl)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIpcorrDevicePkg provide iterator to all rows of the IPCORR_DEVICE_PKG matching given criteria.
func RangeIpcorrDevicePkg(db *sql.DB, where string) iter.Seq2[*IpcorrDevicePkgRow, error] {
	return func(yield func(v *IpcorrDevicePkgRow, err error) bool) {
	    query := "SELECT ID,NAME,NETSCRIPT_ID,USED_BY_IPCORR,USED_BY_ACCESS_CONTROL FROM IPCORR_DEVICE_PKG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IpcorrDevicePkgRow
	        err := rows.Scan(&r.ID, &r.Name, &r.NetscriptID, &r.UsedByIpcorr, &r.UsedByAccessControl)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IpcorrDeviceSubnetRow struct represents rows of the IPCORR_DEVICE_SUBNET table.
type IpcorrDeviceSubnetRow struct {
    ID	int
    IpcorrDeviceID	int
    IPAddr1	int64
    IPAddr2	int64
    InterfaceIndex	int
    PrefixLength	uint16
}

// IterateIpcorrDeviceSubnet provide access to all rows of the IPCORR_DEVICE_SUBNET matching given criteria.
func IterateIpcorrDeviceSubnet(db *sql.DB, where string, callback func(v *IpcorrDeviceSubnetRow) error) error {
    query := "SELECT ID,IPCORR_DEVICE_ID,IP_ADDR_1,IP_ADDR_2,INTERFACE_INDEX,PREFIX_LENGTH FROM IPCORR_DEVICE_SUBNET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IpcorrDeviceSubnetRow
        err := rows.Scan(&r.ID, &r.IpcorrDeviceID, &r.IPAddr1, &r.IPAddr2, &r.InterfaceIndex, &r.PrefixLength)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIpcorrDeviceSubnet provide iterator to all rows of the IPCORR_DEVICE_SUBNET matching given criteria.
func RangeIpcorrDeviceSubnet(db *sql.DB, where string) iter.Seq2[*IpcorrDeviceSubnetRow, error] {
	return func(yield func(v *IpcorrDeviceSubnetRow, err error) bool) {
	    query := "SELECT ID,IPCORR_DEVICE_ID,IP_ADDR_1,IP_ADDR_2,INTERFACE_INDEX,PREFIX_LENGTH FROM IPCORR_DEVICE_SUBNET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IpcorrDeviceSubnetRow
	        err := rows.Scan(&r.ID, &r.IpcorrDeviceID, &r.IPAddr1, &r.IPAddr2, &r.InterfaceIndex, &r.PrefixLength)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IpcorrNetworkMappingRow struct represents rows of the IPCORR_NETWORK_MAPPING table.
type IpcorrNetworkMappingRow struct {
    ID	uint
    PcMac	sql.NullInt64
    IPAddr1	int64
    IPAddr2	int64
    SwitchIPAddr1	int64
    SwitchIPAddr2	int64
    SwitchPort	sql.NullString
    PortCount	sql.NullInt32
    LastTouch	string
    IsStatic	sql.NullByte
}

// IterateIpcorrNetworkMapping provide access to all rows of the IPCORR_NETWORK_MAPPING matching given criteria.
func IterateIpcorrNetworkMapping(db *sql.DB, where string, callback func(v *IpcorrNetworkMappingRow) error) error {
    query := "SELECT ID,PC_MAC,IP_ADDR_1,IP_ADDR_2,SWITCH_IP_ADDR_1,SWITCH_IP_ADDR_2,SWITCH_PORT,PORT_COUNT,LAST_TOUCH,IS_STATIC FROM IPCORR_NETWORK_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IpcorrNetworkMappingRow
        err := rows.Scan(&r.ID, &r.PcMac, &r.IPAddr1, &r.IPAddr2, &r.SwitchIPAddr1, &r.SwitchIPAddr2, &r.SwitchPort, &r.PortCount, &r.LastTouch, &r.IsStatic)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIpcorrNetworkMapping provide iterator to all rows of the IPCORR_NETWORK_MAPPING matching given criteria.
func RangeIpcorrNetworkMapping(db *sql.DB, where string) iter.Seq2[*IpcorrNetworkMappingRow, error] {
	return func(yield func(v *IpcorrNetworkMappingRow, err error) bool) {
	    query := "SELECT ID,PC_MAC,IP_ADDR_1,IP_ADDR_2,SWITCH_IP_ADDR_1,SWITCH_IP_ADDR_2,SWITCH_PORT,PORT_COUNT,LAST_TOUCH,IS_STATIC FROM IPCORR_NETWORK_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IpcorrNetworkMappingRow
	        err := rows.Scan(&r.ID, &r.PcMac, &r.IPAddr1, &r.IPAddr2, &r.SwitchIPAddr1, &r.SwitchIPAddr2, &r.SwitchPort, &r.PortCount, &r.LastTouch, &r.IsStatic)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IpcorrWebsvcRow struct represents rows of the IPCORR_WEBSVC table.
type IpcorrWebsvcRow struct {
    ID	uint
    Url	string
    UseBasicAuth	sql.NullBool
    Username	sql.NullString
    Password	sql.NullString
    Rank	sql.NullInt32
}

// IterateIpcorrWebsvc provide access to all rows of the IPCORR_WEBSVC matching given criteria.
func IterateIpcorrWebsvc(db *sql.DB, where string, callback func(v *IpcorrWebsvcRow) error) error {
    query := "SELECT ID,URL,USE_BASIC_AUTH,USERNAME,PASSWORD,RANK FROM IPCORR_WEBSVC"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IpcorrWebsvcRow
        err := rows.Scan(&r.ID, &r.Url, &r.UseBasicAuth, &r.Username, &r.Password, &r.Rank)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIpcorrWebsvc provide iterator to all rows of the IPCORR_WEBSVC matching given criteria.
func RangeIpcorrWebsvc(db *sql.DB, where string) iter.Seq2[*IpcorrWebsvcRow, error] {
	return func(yield func(v *IpcorrWebsvcRow, err error) bool) {
	    query := "SELECT ID,URL,USE_BASIC_AUTH,USERNAME,PASSWORD,RANK FROM IPCORR_WEBSVC"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IpcorrWebsvcRow
	        err := rows.Scan(&r.ID, &r.Url, &r.UseBasicAuth, &r.Username, &r.Password, &r.Rank)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IpsecGlobalConfigRow struct represents rows of the IPSEC_GLOBAL_CONFIG table.
type IpsecGlobalConfigRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    GlobalStatus	sql.NullByte
    LocalDomainName	sql.NullString
    LocalEmailAddress	sql.NullString
}

// IterateIpsecGlobalConfig provide access to all rows of the IPSEC_GLOBAL_CONFIG matching given criteria.
func IterateIpsecGlobalConfig(db *sql.DB, where string, callback func(v *IpsecGlobalConfigRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,GLOBAL_STATUS,LOCAL_DOMAIN_NAME,LOCAL_EMAIL_ADDRESS FROM IPSEC_GLOBAL_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IpsecGlobalConfigRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.GlobalStatus, &r.LocalDomainName, &r.LocalEmailAddress)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIpsecGlobalConfig provide iterator to all rows of the IPSEC_GLOBAL_CONFIG matching given criteria.
func RangeIpsecGlobalConfig(db *sql.DB, where string) iter.Seq2[*IpsecGlobalConfigRow, error] {
	return func(yield func(v *IpsecGlobalConfigRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,GLOBAL_STATUS,LOCAL_DOMAIN_NAME,LOCAL_EMAIL_ADDRESS FROM IPSEC_GLOBAL_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IpsecGlobalConfigRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.GlobalStatus, &r.LocalDomainName, &r.LocalEmailAddress)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IPAddrIDEntryRow struct represents rows of the IP_ADDR_ID_ENTRY table.
type IPAddrIDEntryRow struct {
    ID	uint
    Name	string
    EntryOrder	sql.NullInt32
    IsAllAddresses	sql.NullByte
    IsUsingIcon	sql.NullByte
    IsUsingColor	sql.NullByte
    ColorRgb	sql.NullInt32
    IconPath	sql.NullString
}

// IterateIPAddrIDEntry provide access to all rows of the IP_ADDR_ID_ENTRY matching given criteria.
func IterateIPAddrIDEntry(db *sql.DB, where string, callback func(v *IPAddrIDEntryRow) error) error {
    query := "SELECT ID,NAME,ENTRY_ORDER,IS_ALL_ADDRESSES,IS_USING_ICON,IS_USING_COLOR,COLOR_RGB,ICON_PATH FROM IP_ADDR_ID_ENTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IPAddrIDEntryRow
        err := rows.Scan(&r.ID, &r.Name, &r.EntryOrder, &r.IsAllAddresses, &r.IsUsingIcon, &r.IsUsingColor, &r.ColorRgb, &r.IconPath)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIPAddrIDEntry provide iterator to all rows of the IP_ADDR_ID_ENTRY matching given criteria.
func RangeIPAddrIDEntry(db *sql.DB, where string) iter.Seq2[*IPAddrIDEntryRow, error] {
	return func(yield func(v *IPAddrIDEntryRow, err error) bool) {
	    query := "SELECT ID,NAME,ENTRY_ORDER,IS_ALL_ADDRESSES,IS_USING_ICON,IS_USING_COLOR,COLOR_RGB,ICON_PATH FROM IP_ADDR_ID_ENTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IPAddrIDEntryRow
	        err := rows.Scan(&r.ID, &r.Name, &r.EntryOrder, &r.IsAllAddresses, &r.IsUsingIcon, &r.IsUsingColor, &r.ColorRgb, &r.IconPath)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IPAddrIDEntryMetadataRow struct represents rows of the IP_ADDR_ID_ENTRY_METADATA table.
type IPAddrIDEntryMetadataRow struct {
    IPAddrIDEntryID	uint
    MetadataType	uint
    Metadata	string
}

// IterateIPAddrIDEntryMetadata provide access to all rows of the IP_ADDR_ID_ENTRY_METADATA matching given criteria.
func IterateIPAddrIDEntryMetadata(db *sql.DB, where string, callback func(v *IPAddrIDEntryMetadataRow) error) error {
    query := "SELECT IP_ADDR_ID_ENTRY_ID,METADATA_TYPE,METADATA FROM IP_ADDR_ID_ENTRY_METADATA"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IPAddrIDEntryMetadataRow
        err := rows.Scan(&r.IPAddrIDEntryID, &r.MetadataType, &r.Metadata)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIPAddrIDEntryMetadata provide iterator to all rows of the IP_ADDR_ID_ENTRY_METADATA matching given criteria.
func RangeIPAddrIDEntryMetadata(db *sql.DB, where string) iter.Seq2[*IPAddrIDEntryMetadataRow, error] {
	return func(yield func(v *IPAddrIDEntryMetadataRow, err error) bool) {
	    query := "SELECT IP_ADDR_ID_ENTRY_ID,METADATA_TYPE,METADATA FROM IP_ADDR_ID_ENTRY_METADATA"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IPAddrIDEntryMetadataRow
	        err := rows.Scan(&r.IPAddrIDEntryID, &r.MetadataType, &r.Metadata)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IPAddrIDEntryNamedObjRow struct represents rows of the IP_ADDR_ID_ENTRY_NAMED_OBJ table.
type IPAddrIDEntryNamedObjRow struct {
    IPAddrIDEntryID	uint
    NamedObjID	uint
    NamedObjType	sql.NullInt32
}

// IterateIPAddrIDEntryNamedObj provide access to all rows of the IP_ADDR_ID_ENTRY_NAMED_OBJ matching given criteria.
func IterateIPAddrIDEntryNamedObj(db *sql.DB, where string, callback func(v *IPAddrIDEntryNamedObjRow) error) error {
    query := "SELECT IP_ADDR_ID_ENTRY_ID,NAMED_OBJ_ID,NAMED_OBJ_TYPE FROM IP_ADDR_ID_ENTRY_NAMED_OBJ"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IPAddrIDEntryNamedObjRow
        err := rows.Scan(&r.IPAddrIDEntryID, &r.NamedObjID, &r.NamedObjType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIPAddrIDEntryNamedObj provide iterator to all rows of the IP_ADDR_ID_ENTRY_NAMED_OBJ matching given criteria.
func RangeIPAddrIDEntryNamedObj(db *sql.DB, where string) iter.Seq2[*IPAddrIDEntryNamedObjRow, error] {
	return func(yield func(v *IPAddrIDEntryNamedObjRow, err error) bool) {
	    query := "SELECT IP_ADDR_ID_ENTRY_ID,NAMED_OBJ_ID,NAMED_OBJ_TYPE FROM IP_ADDR_ID_ENTRY_NAMED_OBJ"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IPAddrIDEntryNamedObjRow
	        err := rows.Scan(&r.IPAddrIDEntryID, &r.NamedObjID, &r.NamedObjType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IPAddrIDEntryServiceRow struct represents rows of the IP_ADDR_ID_ENTRY_SERVICE table.
type IPAddrIDEntryServiceRow struct {
    IPAddrIDEntryID	uint
    ServiceType	uint
}

// IterateIPAddrIDEntryService provide access to all rows of the IP_ADDR_ID_ENTRY_SERVICE matching given criteria.
func IterateIPAddrIDEntryService(db *sql.DB, where string, callback func(v *IPAddrIDEntryServiceRow) error) error {
    query := "SELECT IP_ADDR_ID_ENTRY_ID,SERVICE_TYPE FROM IP_ADDR_ID_ENTRY_SERVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IPAddrIDEntryServiceRow
        err := rows.Scan(&r.IPAddrIDEntryID, &r.ServiceType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIPAddrIDEntryService provide iterator to all rows of the IP_ADDR_ID_ENTRY_SERVICE matching given criteria.
func RangeIPAddrIDEntryService(db *sql.DB, where string) iter.Seq2[*IPAddrIDEntryServiceRow, error] {
	return func(yield func(v *IPAddrIDEntryServiceRow, err error) bool) {
	    query := "SELECT IP_ADDR_ID_ENTRY_ID,SERVICE_TYPE FROM IP_ADDR_ID_ENTRY_SERVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IPAddrIDEntryServiceRow
	        err := rows.Scan(&r.IPAddrIDEntryID, &r.ServiceType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IPAddrIDLookupResponseRow struct represents rows of the IP_ADDR_ID_LOOKUP_RESPONSE table.
type IPAddrIDLookupResponseRow struct {
    ID	uint
    ServiceType	string
    LookupState	string
    IPAddress	string
    LookupTime	string
    WhoisResult	sql.NullString
    HostnameResult	sql.NullString
}

// IterateIPAddrIDLookupResponse provide access to all rows of the IP_ADDR_ID_LOOKUP_RESPONSE matching given criteria.
func IterateIPAddrIDLookupResponse(db *sql.DB, where string, callback func(v *IPAddrIDLookupResponseRow) error) error {
    query := "SELECT ID,SERVICE_TYPE,LOOKUP_STATE,IP_ADDRESS,LOOKUP_TIME,WHOIS_RESULT,HOSTNAME_RESULT FROM IP_ADDR_ID_LOOKUP_RESPONSE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IPAddrIDLookupResponseRow
        err := rows.Scan(&r.ID, &r.ServiceType, &r.LookupState, &r.IPAddress, &r.LookupTime, &r.WhoisResult, &r.HostnameResult)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIPAddrIDLookupResponse provide iterator to all rows of the IP_ADDR_ID_LOOKUP_RESPONSE matching given criteria.
func RangeIPAddrIDLookupResponse(db *sql.DB, where string) iter.Seq2[*IPAddrIDLookupResponseRow, error] {
	return func(yield func(v *IPAddrIDLookupResponseRow, err error) bool) {
	    query := "SELECT ID,SERVICE_TYPE,LOOKUP_STATE,IP_ADDRESS,LOOKUP_TIME,WHOIS_RESULT,HOSTNAME_RESULT FROM IP_ADDR_ID_LOOKUP_RESPONSE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IPAddrIDLookupResponseRow
	        err := rows.Scan(&r.ID, &r.ServiceType, &r.LookupState, &r.IPAddress, &r.LookupTime, &r.WhoisResult, &r.HostnameResult)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// IPUserMappingRow struct represents rows of the IP_USER_MAPPING table.
type IPUserMappingRow struct {
    Idx	uint64
    UserIPAddr1	int64
    UserIPAddr2	sql.NullInt64
    UserIPAddr	[]byte
    UserName	sql.NullString
    DomainName	sql.NullString
    MachineName	sql.NullString
    AdUserID	sql.NullInt32
    StartTime	sql.NullInt64
    EndTime	sql.NullInt64
    UpdateTime	string
}

// IterateIPUserMapping provide access to all rows of the IP_USER_MAPPING matching given criteria.
func IterateIPUserMapping(db *sql.DB, where string, callback func(v *IPUserMappingRow) error) error {
    query := "SELECT IDX,USER_IP_ADDR_1,USER_IP_ADDR_2,USER_IP_ADDR,USER_NAME,DOMAIN_NAME,MACHINE_NAME,AD_USER_ID,START_TIME,END_TIME,UPDATE_TIME FROM IP_USER_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r IPUserMappingRow
        err := rows.Scan(&r.Idx, &r.UserIPAddr1, &r.UserIPAddr2, &r.UserIPAddr, &r.UserName, &r.DomainName, &r.MachineName, &r.AdUserID, &r.StartTime, &r.EndTime, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeIPUserMapping provide iterator to all rows of the IP_USER_MAPPING matching given criteria.
func RangeIPUserMapping(db *sql.DB, where string) iter.Seq2[*IPUserMappingRow, error] {
	return func(yield func(v *IPUserMappingRow, err error) bool) {
	    query := "SELECT IDX,USER_IP_ADDR_1,USER_IP_ADDR_2,USER_IP_ADDR,USER_NAME,DOMAIN_NAME,MACHINE_NAME,AD_USER_ID,START_TIME,END_TIME,UPDATE_TIME FROM IP_USER_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r IPUserMappingRow
	        err := rows.Scan(&r.Idx, &r.UserIPAddr1, &r.UserIPAddr2, &r.UserIPAddr, &r.UserName, &r.DomainName, &r.MachineName, &r.AdUserID, &r.StartTime, &r.EndTime, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// JbmCounterRow struct represents rows of the JBM_COUNTER table.
type JbmCounterRow struct {
    Name	string
    NextID	sql.NullInt64
}

// IterateJbmCounter provide access to all rows of the JBM_COUNTER matching given criteria.
func IterateJbmCounter(db *sql.DB, where string, callback func(v *JbmCounterRow) error) error {
    query := "SELECT NAME,NEXT_ID FROM JBM_COUNTER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r JbmCounterRow
        err := rows.Scan(&r.Name, &r.NextID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeJbmCounter provide iterator to all rows of the JBM_COUNTER matching given criteria.
func RangeJbmCounter(db *sql.DB, where string) iter.Seq2[*JbmCounterRow, error] {
	return func(yield func(v *JbmCounterRow, err error) bool) {
	    query := "SELECT NAME,NEXT_ID FROM JBM_COUNTER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r JbmCounterRow
	        err := rows.Scan(&r.Name, &r.NextID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// JbmDualRow struct represents rows of the JBM_DUAL table.
type JbmDualRow struct {
    Dummy	int
}

// IterateJbmDual provide access to all rows of the JBM_DUAL matching given criteria.
func IterateJbmDual(db *sql.DB, where string, callback func(v *JbmDualRow) error) error {
    query := "SELECT DUMMY FROM JBM_DUAL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r JbmDualRow
        err := rows.Scan(&r.Dummy)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeJbmDual provide iterator to all rows of the JBM_DUAL matching given criteria.
func RangeJbmDual(db *sql.DB, where string) iter.Seq2[*JbmDualRow, error] {
	return func(yield func(v *JbmDualRow, err error) bool) {
	    query := "SELECT DUMMY FROM JBM_DUAL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r JbmDualRow
	        err := rows.Scan(&r.Dummy)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// JbmIDCacheRow struct represents rows of the JBM_ID_CACHE table.
type JbmIDCacheRow struct {
    NodeID	int
    Cntr	int
    JbmID	sql.NullString
}

// IterateJbmIDCache provide access to all rows of the JBM_ID_CACHE matching given criteria.
func IterateJbmIDCache(db *sql.DB, where string, callback func(v *JbmIDCacheRow) error) error {
    query := "SELECT NODE_ID,CNTR,JBM_ID FROM JBM_ID_CACHE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r JbmIDCacheRow
        err := rows.Scan(&r.NodeID, &r.Cntr, &r.JbmID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeJbmIDCache provide iterator to all rows of the JBM_ID_CACHE matching given criteria.
func RangeJbmIDCache(db *sql.DB, where string) iter.Seq2[*JbmIDCacheRow, error] {
	return func(yield func(v *JbmIDCacheRow, err error) bool) {
	    query := "SELECT NODE_ID,CNTR,JBM_ID FROM JBM_ID_CACHE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r JbmIDCacheRow
	        err := rows.Scan(&r.NodeID, &r.Cntr, &r.JbmID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// JbmMsgRefRow struct represents rows of the JBM_MSG_REF table.
type JbmMsgRefRow struct {
    MessageID	int64
    ChannelID	int64
    TransactionID	sql.NullInt64
    State	sql.NullString
    Ord	sql.NullInt64
    PageOrd	sql.NullInt64
    DeliveryCount	sql.NullInt32
    SchedDelivery	sql.NullInt64
}

// IterateJbmMsgRef provide access to all rows of the JBM_MSG_REF matching given criteria.
func IterateJbmMsgRef(db *sql.DB, where string, callback func(v *JbmMsgRefRow) error) error {
    query := "SELECT MESSAGE_ID,CHANNEL_ID,TRANSACTION_ID,STATE,ORD,PAGE_ORD,DELIVERY_COUNT,SCHED_DELIVERY FROM JBM_MSG_REF"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r JbmMsgRefRow
        err := rows.Scan(&r.MessageID, &r.ChannelID, &r.TransactionID, &r.State, &r.Ord, &r.PageOrd, &r.DeliveryCount, &r.SchedDelivery)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeJbmMsgRef provide iterator to all rows of the JBM_MSG_REF matching given criteria.
func RangeJbmMsgRef(db *sql.DB, where string) iter.Seq2[*JbmMsgRefRow, error] {
	return func(yield func(v *JbmMsgRefRow, err error) bool) {
	    query := "SELECT MESSAGE_ID,CHANNEL_ID,TRANSACTION_ID,STATE,ORD,PAGE_ORD,DELIVERY_COUNT,SCHED_DELIVERY FROM JBM_MSG_REF"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r JbmMsgRefRow
	        err := rows.Scan(&r.MessageID, &r.ChannelID, &r.TransactionID, &r.State, &r.Ord, &r.PageOrd, &r.DeliveryCount, &r.SchedDelivery)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// JbmPostofficeRow struct represents rows of the JBM_POSTOFFICE table.
type JbmPostofficeRow struct {
    PostofficeName	string
    NodeID	int
    QueueName	string
    Cond	sql.NullString
    Selector	sql.NullString
    ChannelID	sql.NullInt64
    Clustered	sql.NullString
    AllNodes	sql.NullString
}

// IterateJbmPostoffice provide access to all rows of the JBM_POSTOFFICE matching given criteria.
func IterateJbmPostoffice(db *sql.DB, where string, callback func(v *JbmPostofficeRow) error) error {
    query := "SELECT POSTOFFICE_NAME,NODE_ID,QUEUE_NAME,COND,SELECTOR,CHANNEL_ID,CLUSTERED,ALL_NODES FROM JBM_POSTOFFICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r JbmPostofficeRow
        err := rows.Scan(&r.PostofficeName, &r.NodeID, &r.QueueName, &r.Cond, &r.Selector, &r.ChannelID, &r.Clustered, &r.AllNodes)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeJbmPostoffice provide iterator to all rows of the JBM_POSTOFFICE matching given criteria.
func RangeJbmPostoffice(db *sql.DB, where string) iter.Seq2[*JbmPostofficeRow, error] {
	return func(yield func(v *JbmPostofficeRow, err error) bool) {
	    query := "SELECT POSTOFFICE_NAME,NODE_ID,QUEUE_NAME,COND,SELECTOR,CHANNEL_ID,CLUSTERED,ALL_NODES FROM JBM_POSTOFFICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r JbmPostofficeRow
	        err := rows.Scan(&r.PostofficeName, &r.NodeID, &r.QueueName, &r.Cond, &r.Selector, &r.ChannelID, &r.Clustered, &r.AllNodes)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// JbmRoleRow struct represents rows of the JBM_ROLE table.
type JbmRoleRow struct {
    RoleID	string
    UserID	string
}

// IterateJbmRole provide access to all rows of the JBM_ROLE matching given criteria.
func IterateJbmRole(db *sql.DB, where string, callback func(v *JbmRoleRow) error) error {
    query := "SELECT ROLE_ID,USER_ID FROM JBM_ROLE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r JbmRoleRow
        err := rows.Scan(&r.RoleID, &r.UserID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeJbmRole provide iterator to all rows of the JBM_ROLE matching given criteria.
func RangeJbmRole(db *sql.DB, where string) iter.Seq2[*JbmRoleRow, error] {
	return func(yield func(v *JbmRoleRow, err error) bool) {
	    query := "SELECT ROLE_ID,USER_ID FROM JBM_ROLE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r JbmRoleRow
	        err := rows.Scan(&r.RoleID, &r.UserID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// JbmTxRow struct represents rows of the JBM_TX table.
type JbmTxRow struct {
    NodeID	sql.NullInt32
    TransactionID	int64
    BranchQual	[]byte
    FormatID	sql.NullInt32
    GlobalTxid	[]byte
}

// IterateJbmTx provide access to all rows of the JBM_TX matching given criteria.
func IterateJbmTx(db *sql.DB, where string, callback func(v *JbmTxRow) error) error {
    query := "SELECT NODE_ID,TRANSACTION_ID,BRANCH_QUAL,FORMAT_ID,GLOBAL_TXID FROM JBM_TX"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r JbmTxRow
        err := rows.Scan(&r.NodeID, &r.TransactionID, &r.BranchQual, &r.FormatID, &r.GlobalTxid)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeJbmTx provide iterator to all rows of the JBM_TX matching given criteria.
func RangeJbmTx(db *sql.DB, where string) iter.Seq2[*JbmTxRow, error] {
	return func(yield func(v *JbmTxRow, err error) bool) {
	    query := "SELECT NODE_ID,TRANSACTION_ID,BRANCH_QUAL,FORMAT_ID,GLOBAL_TXID FROM JBM_TX"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r JbmTxRow
	        err := rows.Scan(&r.NodeID, &r.TransactionID, &r.BranchQual, &r.FormatID, &r.GlobalTxid)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// JbmUserRow struct represents rows of the JBM_USER table.
type JbmUserRow struct {
    UserID	string
    Passwd	string
    Clientid	sql.NullString
}

// IterateJbmUser provide access to all rows of the JBM_USER matching given criteria.
func IterateJbmUser(db *sql.DB, where string, callback func(v *JbmUserRow) error) error {
    query := "SELECT USER_ID,PASSWD,CLIENTID FROM JBM_USER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r JbmUserRow
        err := rows.Scan(&r.UserID, &r.Passwd, &r.Clientid)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeJbmUser provide iterator to all rows of the JBM_USER matching given criteria.
func RangeJbmUser(db *sql.DB, where string) iter.Seq2[*JbmUserRow, error] {
	return func(yield func(v *JbmUserRow, err error) bool) {
	    query := "SELECT USER_ID,PASSWD,CLIENTID FROM JBM_USER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r JbmUserRow
	        err := rows.Scan(&r.UserID, &r.Passwd, &r.Clientid)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// L2tpConfigRow struct represents rows of the L2TP_CONFIG table.
type L2tpConfigRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    Enable	sql.NullByte
    RequireEncryption	sql.NullByte
    DnsProxy	sql.NullByte
    DnsServer1	sql.NullString
    DnsServer2	sql.NullString
    WinsServer1	sql.NullString
    WinsServer2	sql.NullString
    UseRadius	sql.NullByte
    SecurityZoneID	sql.NullInt32
    NamedIPGroupID	sql.NullInt32
}

// IterateL2tpConfig provide access to all rows of the L2TP_CONFIG matching given criteria.
func IterateL2tpConfig(db *sql.DB, where string, callback func(v *L2tpConfigRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,ENABLE,REQUIRE_ENCRYPTION,DNS_PROXY,DNS_SERVER1,DNS_SERVER2,WINS_SERVER1,WINS_SERVER2,USE_RADIUS,SECURITY_ZONE_ID,NAMED_IP_GROUP_ID FROM L2TP_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r L2tpConfigRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Enable, &r.RequireEncryption, &r.DnsProxy, &r.DnsServer1, &r.DnsServer2, &r.WinsServer1, &r.WinsServer2, &r.UseRadius, &r.SecurityZoneID, &r.NamedIPGroupID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeL2tpConfig provide iterator to all rows of the L2TP_CONFIG matching given criteria.
func RangeL2tpConfig(db *sql.DB, where string) iter.Seq2[*L2tpConfigRow, error] {
	return func(yield func(v *L2tpConfigRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,ENABLE,REQUIRE_ENCRYPTION,DNS_PROXY,DNS_SERVER1,DNS_SERVER2,WINS_SERVER1,WINS_SERVER2,USE_RADIUS,SECURITY_ZONE_ID,NAMED_IP_GROUP_ID FROM L2TP_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r L2tpConfigRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Enable, &r.RequireEncryption, &r.DnsProxy, &r.DnsServer1, &r.DnsServer2, &r.WinsServer1, &r.WinsServer2, &r.UseRadius, &r.SecurityZoneID, &r.NamedIPGroupID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// L3NatRuleRow struct represents rows of the L3_NAT_RULE table.
type L3NatRuleRow struct {
    ID	int
    TptSegmentID	string
    PublicIPNamedObjID	uint
    PrivateIPNamedObjID	uint
}

// IterateL3NatRule provide access to all rows of the L3_NAT_RULE matching given criteria.
func IterateL3NatRule(db *sql.DB, where string, callback func(v *L3NatRuleRow) error) error {
    query := "SELECT ID,TPT_SEGMENT_ID,PUBLIC_IP_NAMED_OBJ_ID,PRIVATE_IP_NAMED_OBJ_ID FROM L3_NAT_RULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r L3NatRuleRow
        err := rows.Scan(&r.ID, &r.TptSegmentID, &r.PublicIPNamedObjID, &r.PrivateIPNamedObjID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeL3NatRule provide iterator to all rows of the L3_NAT_RULE matching given criteria.
func RangeL3NatRule(db *sql.DB, where string) iter.Seq2[*L3NatRuleRow, error] {
	return func(yield func(v *L3NatRuleRow, err error) bool) {
	    query := "SELECT ID,TPT_SEGMENT_ID,PUBLIC_IP_NAMED_OBJ_ID,PRIVATE_IP_NAMED_OBJ_ID FROM L3_NAT_RULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r L3NatRuleRow
	        err := rows.Scan(&r.ID, &r.TptSegmentID, &r.PublicIPNamedObjID, &r.PrivateIPNamedObjID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// L3RoutingTableRow struct represents rows of the L3_ROUTING_TABLE table.
type L3RoutingTableRow struct {
    ID	int
    TptSegmentID	string
    IPSubnetNamedObjID	uint
    NextHopNamedObjID	uint
}

// IterateL3RoutingTable provide access to all rows of the L3_ROUTING_TABLE matching given criteria.
func IterateL3RoutingTable(db *sql.DB, where string, callback func(v *L3RoutingTableRow) error) error {
    query := "SELECT ID,TPT_SEGMENT_ID,IP_SUBNET_NAMED_OBJ_ID,NEXT_HOP_NAMED_OBJ_ID FROM L3_ROUTING_TABLE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r L3RoutingTableRow
        err := rows.Scan(&r.ID, &r.TptSegmentID, &r.IPSubnetNamedObjID, &r.NextHopNamedObjID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeL3RoutingTable provide iterator to all rows of the L3_ROUTING_TABLE matching given criteria.
func RangeL3RoutingTable(db *sql.DB, where string) iter.Seq2[*L3RoutingTableRow, error] {
	return func(yield func(v *L3RoutingTableRow, err error) bool) {
	    query := "SELECT ID,TPT_SEGMENT_ID,IP_SUBNET_NAMED_OBJ_ID,NEXT_HOP_NAMED_OBJ_ID FROM L3_ROUTING_TABLE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r L3RoutingTableRow
	        err := rows.Scan(&r.ID, &r.TptSegmentID, &r.IPSubnetNamedObjID, &r.NextHopNamedObjID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// LdapServerConfigRow struct represents rows of the LDAP_SERVER_CONFIG table.
type LdapServerConfigRow struct {
    ID	uint
    ServerAddress	sql.NullString
    Port	uint16
    Timeout	uint
    AdminUser	sql.NullString
    AdminPassword	sql.NullString
    SearchBase	sql.NullString
    UseSsl	sql.NullByte
    NamedCertificateID	uint
}

// IterateLdapServerConfig provide access to all rows of the LDAP_SERVER_CONFIG matching given criteria.
func IterateLdapServerConfig(db *sql.DB, where string, callback func(v *LdapServerConfigRow) error) error {
    query := "SELECT ID,SERVER_ADDRESS,PORT,TIMEOUT,ADMIN_USER,ADMIN_PASSWORD,SEARCH_BASE,USE_SSL,NAMED_CERTIFICATE_ID FROM LDAP_SERVER_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r LdapServerConfigRow
        err := rows.Scan(&r.ID, &r.ServerAddress, &r.Port, &r.Timeout, &r.AdminUser, &r.AdminPassword, &r.SearchBase, &r.UseSsl, &r.NamedCertificateID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeLdapServerConfig provide iterator to all rows of the LDAP_SERVER_CONFIG matching given criteria.
func RangeLdapServerConfig(db *sql.DB, where string) iter.Seq2[*LdapServerConfigRow, error] {
	return func(yield func(v *LdapServerConfigRow, err error) bool) {
	    query := "SELECT ID,SERVER_ADDRESS,PORT,TIMEOUT,ADMIN_USER,ADMIN_PASSWORD,SEARCH_BASE,USE_SSL,NAMED_CERTIFICATE_ID FROM LDAP_SERVER_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r LdapServerConfigRow
	        err := rows.Scan(&r.ID, &r.ServerAddress, &r.Port, &r.Timeout, &r.AdminUser, &r.AdminPassword, &r.SearchBase, &r.UseSsl, &r.NamedCertificateID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// LicenseStatusSnapshotBaseRow struct represents rows of the LICENSE_STATUS_SNAPSHOT_BASE table.
type LicenseStatusSnapshotBaseRow struct {
    ID	uint
    DeviceID	uint
    Capability	sql.NullByte
    EnforcementType	sql.NullByte
}

// IterateLicenseStatusSnapshotBase provide access to all rows of the LICENSE_STATUS_SNAPSHOT_BASE matching given criteria.
func IterateLicenseStatusSnapshotBase(db *sql.DB, where string, callback func(v *LicenseStatusSnapshotBaseRow) error) error {
    query := "SELECT ID,DEVICE_ID,CAPABILITY,ENFORCEMENT_TYPE FROM LICENSE_STATUS_SNAPSHOT_BASE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r LicenseStatusSnapshotBaseRow
        err := rows.Scan(&r.ID, &r.DeviceID, &r.Capability, &r.EnforcementType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeLicenseStatusSnapshotBase provide iterator to all rows of the LICENSE_STATUS_SNAPSHOT_BASE matching given criteria.
func RangeLicenseStatusSnapshotBase(db *sql.DB, where string) iter.Seq2[*LicenseStatusSnapshotBaseRow, error] {
	return func(yield func(v *LicenseStatusSnapshotBaseRow, err error) bool) {
	    query := "SELECT ID,DEVICE_ID,CAPABILITY,ENFORCEMENT_TYPE FROM LICENSE_STATUS_SNAPSHOT_BASE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r LicenseStatusSnapshotBaseRow
	        err := rows.Scan(&r.ID, &r.DeviceID, &r.Capability, &r.EnforcementType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// LocationRow struct represents rows of the LOCATION table.
type LocationRow struct {
    ID	uint
    LocType	sql.NullByte
    LocServer	sql.NullString
    LocDirectory	sql.NullString
    LocFilename	sql.NullString
    LocUsername	sql.NullString
    LocPassword	sql.NullString
    LocDomain	sql.NullString
}

// IterateLocation provide access to all rows of the LOCATION matching given criteria.
func IterateLocation(db *sql.DB, where string, callback func(v *LocationRow) error) error {
    query := "SELECT ID,LOC_TYPE,LOC_SERVER,LOC_DIRECTORY,LOC_FILENAME,LOC_USERNAME,LOC_PASSWORD,LOC_DOMAIN FROM LOCATION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r LocationRow
        err := rows.Scan(&r.ID, &r.LocType, &r.LocServer, &r.LocDirectory, &r.LocFilename, &r.LocUsername, &r.LocPassword, &r.LocDomain)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeLocation provide iterator to all rows of the LOCATION matching given criteria.
func RangeLocation(db *sql.DB, where string) iter.Seq2[*LocationRow, error] {
	return func(yield func(v *LocationRow, err error) bool) {
	    query := "SELECT ID,LOC_TYPE,LOC_SERVER,LOC_DIRECTORY,LOC_FILENAME,LOC_USERNAME,LOC_PASSWORD,LOC_DOMAIN FROM LOCATION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r LocationRow
	        err := rows.Scan(&r.ID, &r.LocType, &r.LocServer, &r.LocDirectory, &r.LocFilename, &r.LocUsername, &r.LocPassword, &r.LocDomain)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// LoginBannerRow struct represents rows of the LOGIN_BANNER table.
type LoginBannerRow struct {
    DeviceShortID	uint
    Enabled	int8
    Title	sql.NullString
    Text	sql.NullString
}

// IterateLoginBanner provide access to all rows of the LOGIN_BANNER matching given criteria.
func IterateLoginBanner(db *sql.DB, where string, callback func(v *LoginBannerRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,ENABLED,TITLE,TEXT FROM LOGIN_BANNER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r LoginBannerRow
        err := rows.Scan(&r.DeviceShortID, &r.Enabled, &r.Title, &r.Text)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeLoginBanner provide iterator to all rows of the LOGIN_BANNER matching given criteria.
func RangeLoginBanner(db *sql.DB, where string) iter.Seq2[*LoginBannerRow, error] {
	return func(yield func(v *LoginBannerRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,ENABLED,TITLE,TEXT FROM LOGIN_BANNER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r LoginBannerRow
	        err := rows.Scan(&r.DeviceShortID, &r.Enabled, &r.Title, &r.Text)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// MergedTptPackagesRow struct represents rows of the MERGED_TPT_PACKAGES table.
type MergedTptPackagesRow struct {
    MergedTptPkgID	string
    TptPkgID	string
    Version	string
}

// IterateMergedTptPackages provide access to all rows of the MERGED_TPT_PACKAGES matching given criteria.
func IterateMergedTptPackages(db *sql.DB, where string, callback func(v *MergedTptPackagesRow) error) error {
    query := "SELECT MERGED_TPT_PKG_ID,TPT_PKG_ID,VERSION FROM MERGED_TPT_PACKAGES"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r MergedTptPackagesRow
        err := rows.Scan(&r.MergedTptPkgID, &r.TptPkgID, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeMergedTptPackages provide iterator to all rows of the MERGED_TPT_PACKAGES matching given criteria.
func RangeMergedTptPackages(db *sql.DB, where string) iter.Seq2[*MergedTptPackagesRow, error] {
	return func(yield func(v *MergedTptPackagesRow, err error) bool) {
	    query := "SELECT MERGED_TPT_PKG_ID,TPT_PKG_ID,VERSION FROM MERGED_TPT_PACKAGES"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r MergedTptPackagesRow
	        err := rows.Scan(&r.MergedTptPkgID, &r.TptPkgID, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// MigrationFlagRow struct represents rows of the MIGRATION_FLAG table.
type MigrationFlagRow struct {
    Name	string
    TryCount	sql.NullByte
}

// IterateMigrationFlag provide access to all rows of the MIGRATION_FLAG matching given criteria.
func IterateMigrationFlag(db *sql.DB, where string, callback func(v *MigrationFlagRow) error) error {
    query := "SELECT NAME,TRY_COUNT FROM MIGRATION_FLAG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r MigrationFlagRow
        err := rows.Scan(&r.Name, &r.TryCount)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeMigrationFlag provide iterator to all rows of the MIGRATION_FLAG matching given criteria.
func RangeMigrationFlag(db *sql.DB, where string) iter.Seq2[*MigrationFlagRow, error] {
	return func(yield func(v *MigrationFlagRow, err error) bool) {
	    query := "SELECT NAME,TRY_COUNT FROM MIGRATION_FLAG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r MigrationFlagRow
	        err := rows.Scan(&r.Name, &r.TryCount)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedAbstractProtocolServiceRow struct represents rows of the NAMED_ABSTRACT_PROTOCOL_SERVICE table.
type NamedAbstractProtocolServiceRow struct {
    ID	uint
    Name	string
    NamedServiceUuid	string
    NamedServiceObjType	string
    IterationID	uint
    Description	sql.NullString
    Version	uint
    NamedProtocolServiceType	string
    AdditionalSysDefinedServiceEntries	sql.NullByte
    InspectionService	sql.NullByte
    PristineSystemDefinedService	sql.NullByte
    ServiceVersion	sql.NullString
    NgfwServiceVersion	sql.NullString
    ServiceIteration	sql.NullInt64
}

// IterateNamedAbstractProtocolService provide access to all rows of the NAMED_ABSTRACT_PROTOCOL_SERVICE matching given criteria.
func IterateNamedAbstractProtocolService(db *sql.DB, where string, callback func(v *NamedAbstractProtocolServiceRow) error) error {
    query := "SELECT ID,NAME,NAMED_SERVICE_UUID,NAMED_SERVICE_OBJ_TYPE,ITERATION_ID,DESCRIPTION,VERSION,NAMED_PROTOCOL_SERVICE_TYPE,ADDITIONAL_SYS_DEFINED_SERVICE_ENTRIES,INSPECTION_SERVICE,PRISTINE_SYSTEM_DEFINED_SERVICE,SERVICE_VERSION,NGFW_SERVICE_VERSION,SERVICE_ITERATION FROM NAMED_ABSTRACT_PROTOCOL_SERVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedAbstractProtocolServiceRow
        err := rows.Scan(&r.ID, &r.Name, &r.NamedServiceUuid, &r.NamedServiceObjType, &r.IterationID, &r.Description, &r.Version, &r.NamedProtocolServiceType, &r.AdditionalSysDefinedServiceEntries, &r.InspectionService, &r.PristineSystemDefinedService, &r.ServiceVersion, &r.NgfwServiceVersion, &r.ServiceIteration)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedAbstractProtocolService provide iterator to all rows of the NAMED_ABSTRACT_PROTOCOL_SERVICE matching given criteria.
func RangeNamedAbstractProtocolService(db *sql.DB, where string) iter.Seq2[*NamedAbstractProtocolServiceRow, error] {
	return func(yield func(v *NamedAbstractProtocolServiceRow, err error) bool) {
	    query := "SELECT ID,NAME,NAMED_SERVICE_UUID,NAMED_SERVICE_OBJ_TYPE,ITERATION_ID,DESCRIPTION,VERSION,NAMED_PROTOCOL_SERVICE_TYPE,ADDITIONAL_SYS_DEFINED_SERVICE_ENTRIES,INSPECTION_SERVICE,PRISTINE_SYSTEM_DEFINED_SERVICE,SERVICE_VERSION,NGFW_SERVICE_VERSION,SERVICE_ITERATION FROM NAMED_ABSTRACT_PROTOCOL_SERVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedAbstractProtocolServiceRow
	        err := rows.Scan(&r.ID, &r.Name, &r.NamedServiceUuid, &r.NamedServiceObjType, &r.IterationID, &r.Description, &r.Version, &r.NamedProtocolServiceType, &r.AdditionalSysDefinedServiceEntries, &r.InspectionService, &r.PristineSystemDefinedService, &r.ServiceVersion, &r.NgfwServiceVersion, &r.ServiceIteration)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedCertificateRow struct represents rows of the NAMED_CERTIFICATE table.
type NamedCertificateRow struct {
    ID	int
    Uuid	string
    Name	string
    Ca	int8
    Thumbprint	string
    CertBytes	[]byte
    CrlStatus	sql.NullInt64
    CrlLastUpdated	sql.NullInt64
    Exportable	int8
    PrivateKeyExpected	int8
    DefaultCa	int8
    AcmeInfo	sql.NullString
}

// IterateNamedCertificate provide access to all rows of the NAMED_CERTIFICATE matching given criteria.
func IterateNamedCertificate(db *sql.DB, where string, callback func(v *NamedCertificateRow) error) error {
    query := "SELECT ID,UUID,NAME,CA,THUMBPRINT,CERT_BYTES,CRL_STATUS,CRL_LAST_UPDATED,EXPORTABLE,PRIVATE_KEY_EXPECTED,DEFAULT_CA,ACME_INFO FROM NAMED_CERTIFICATE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedCertificateRow
        err := rows.Scan(&r.ID, &r.Uuid, &r.Name, &r.Ca, &r.Thumbprint, &r.CertBytes, &r.CrlStatus, &r.CrlLastUpdated, &r.Exportable, &r.PrivateKeyExpected, &r.DefaultCa, &r.AcmeInfo)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedCertificate provide iterator to all rows of the NAMED_CERTIFICATE matching given criteria.
func RangeNamedCertificate(db *sql.DB, where string) iter.Seq2[*NamedCertificateRow, error] {
	return func(yield func(v *NamedCertificateRow, err error) bool) {
	    query := "SELECT ID,UUID,NAME,CA,THUMBPRINT,CERT_BYTES,CRL_STATUS,CRL_LAST_UPDATED,EXPORTABLE,PRIVATE_KEY_EXPECTED,DEFAULT_CA,ACME_INFO FROM NAMED_CERTIFICATE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedCertificateRow
	        err := rows.Scan(&r.ID, &r.Uuid, &r.Name, &r.Ca, &r.Thumbprint, &r.CertBytes, &r.CrlStatus, &r.CrlLastUpdated, &r.Exportable, &r.PrivateKeyExpected, &r.DefaultCa, &r.AcmeInfo)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedEmailAddressRow struct represents rows of the NAMED_EMAIL_ADDRESS table.
type NamedEmailAddressRow struct {
    NamedObjID	int
    EmailAddress	string
}

// IterateNamedEmailAddress provide access to all rows of the NAMED_EMAIL_ADDRESS matching given criteria.
func IterateNamedEmailAddress(db *sql.DB, where string, callback func(v *NamedEmailAddressRow) error) error {
    query := "SELECT NAMED_OBJ_ID,EMAIL_ADDRESS FROM NAMED_EMAIL_ADDRESS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedEmailAddressRow
        err := rows.Scan(&r.NamedObjID, &r.EmailAddress)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedEmailAddress provide iterator to all rows of the NAMED_EMAIL_ADDRESS matching given criteria.
func RangeNamedEmailAddress(db *sql.DB, where string) iter.Seq2[*NamedEmailAddressRow, error] {
	return func(yield func(v *NamedEmailAddressRow, err error) bool) {
	    query := "SELECT NAMED_OBJ_ID,EMAIL_ADDRESS FROM NAMED_EMAIL_ADDRESS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedEmailAddressRow
	        err := rows.Scan(&r.NamedObjID, &r.EmailAddress)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedIPAddressRow struct represents rows of the NAMED_IP_ADDRESS table.
type NamedIPAddressRow struct {
    NamedObjID	int
    Address	string
}

// IterateNamedIPAddress provide access to all rows of the NAMED_IP_ADDRESS matching given criteria.
func IterateNamedIPAddress(db *sql.DB, where string, callback func(v *NamedIPAddressRow) error) error {
    query := "SELECT NAMED_OBJ_ID,ADDRESS FROM NAMED_IP_ADDRESS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedIPAddressRow
        err := rows.Scan(&r.NamedObjID, &r.Address)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedIPAddress provide iterator to all rows of the NAMED_IP_ADDRESS matching given criteria.
func RangeNamedIPAddress(db *sql.DB, where string) iter.Seq2[*NamedIPAddressRow, error] {
	return func(yield func(v *NamedIPAddressRow, err error) bool) {
	    query := "SELECT NAMED_OBJ_ID,ADDRESS FROM NAMED_IP_ADDRESS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedIPAddressRow
	        err := rows.Scan(&r.NamedObjID, &r.Address)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedIPAddressBlockRow struct represents rows of the NAMED_IP_ADDRESS_BLOCK table.
type NamedIPAddressBlockRow struct {
    NamedObjID	int
    AddressBlock	sql.NullString
}

// IterateNamedIPAddressBlock provide access to all rows of the NAMED_IP_ADDRESS_BLOCK matching given criteria.
func IterateNamedIPAddressBlock(db *sql.DB, where string, callback func(v *NamedIPAddressBlockRow) error) error {
    query := "SELECT NAMED_OBJ_ID,ADDRESS_BLOCK FROM NAMED_IP_ADDRESS_BLOCK"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedIPAddressBlockRow
        err := rows.Scan(&r.NamedObjID, &r.AddressBlock)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedIPAddressBlock provide iterator to all rows of the NAMED_IP_ADDRESS_BLOCK matching given criteria.
func RangeNamedIPAddressBlock(db *sql.DB, where string) iter.Seq2[*NamedIPAddressBlockRow, error] {
	return func(yield func(v *NamedIPAddressBlockRow, err error) bool) {
	    query := "SELECT NAMED_OBJ_ID,ADDRESS_BLOCK FROM NAMED_IP_ADDRESS_BLOCK"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedIPAddressBlockRow
	        err := rows.Scan(&r.NamedObjID, &r.AddressBlock)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedIPAddressGroupRow struct represents rows of the NAMED_IP_ADDRESS_GROUP table.
type NamedIPAddressGroupRow struct {
    NamedObjID	int
}

// IterateNamedIPAddressGroup provide access to all rows of the NAMED_IP_ADDRESS_GROUP matching given criteria.
func IterateNamedIPAddressGroup(db *sql.DB, where string, callback func(v *NamedIPAddressGroupRow) error) error {
    query := "SELECT NAMED_OBJ_ID FROM NAMED_IP_ADDRESS_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedIPAddressGroupRow
        err := rows.Scan(&r.NamedObjID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedIPAddressGroup provide iterator to all rows of the NAMED_IP_ADDRESS_GROUP matching given criteria.
func RangeNamedIPAddressGroup(db *sql.DB, where string) iter.Seq2[*NamedIPAddressGroupRow, error] {
	return func(yield func(v *NamedIPAddressGroupRow, err error) bool) {
	    query := "SELECT NAMED_OBJ_ID FROM NAMED_IP_ADDRESS_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedIPAddressGroupRow
	        err := rows.Scan(&r.NamedObjID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedObjRow struct represents rows of the NAMED_OBJ table.
type NamedObjRow struct {
    ID	int
    Name	sql.NullString
    NamedObjTypeID	string
    OwnerID	string
    OwnerType	string
    Hidden	sql.NullByte
    Mutable	sql.NullByte
    NamedObjUuid	string
    IterationID	uint
    Description	sql.NullString
}

// IterateNamedObj provide access to all rows of the NAMED_OBJ matching given criteria.
func IterateNamedObj(db *sql.DB, where string, callback func(v *NamedObjRow) error) error {
    query := "SELECT ID,NAME,NAMED_OBJ_TYPE_ID,OWNER_ID,OWNER_TYPE,HIDDEN,MUTABLE,NAMED_OBJ_UUID,ITERATION_ID,DESCRIPTION FROM NAMED_OBJ"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedObjRow
        err := rows.Scan(&r.ID, &r.Name, &r.NamedObjTypeID, &r.OwnerID, &r.OwnerType, &r.Hidden, &r.Mutable, &r.NamedObjUuid, &r.IterationID, &r.Description)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedObj provide iterator to all rows of the NAMED_OBJ matching given criteria.
func RangeNamedObj(db *sql.DB, where string) iter.Seq2[*NamedObjRow, error] {
	return func(yield func(v *NamedObjRow, err error) bool) {
	    query := "SELECT ID,NAME,NAMED_OBJ_TYPE_ID,OWNER_ID,OWNER_TYPE,HIDDEN,MUTABLE,NAMED_OBJ_UUID,ITERATION_ID,DESCRIPTION FROM NAMED_OBJ"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedObjRow
	        err := rows.Scan(&r.ID, &r.Name, &r.NamedObjTypeID, &r.OwnerID, &r.OwnerType, &r.Hidden, &r.Mutable, &r.NamedObjUuid, &r.IterationID, &r.Description)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedObjGroupRow struct represents rows of the NAMED_OBJ_GROUP table.
type NamedObjGroupRow struct {
    GroupID	int
    ObjID	int
}

// IterateNamedObjGroup provide access to all rows of the NAMED_OBJ_GROUP matching given criteria.
func IterateNamedObjGroup(db *sql.DB, where string, callback func(v *NamedObjGroupRow) error) error {
    query := "SELECT GROUP_ID,OBJ_ID FROM NAMED_OBJ_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedObjGroupRow
        err := rows.Scan(&r.GroupID, &r.ObjID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedObjGroup provide iterator to all rows of the NAMED_OBJ_GROUP matching given criteria.
func RangeNamedObjGroup(db *sql.DB, where string) iter.Seq2[*NamedObjGroupRow, error] {
	return func(yield func(v *NamedObjGroupRow, err error) bool) {
	    query := "SELECT GROUP_ID,OBJ_ID FROM NAMED_OBJ_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedObjGroupRow
	        err := rows.Scan(&r.GroupID, &r.ObjID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedObjListRow struct represents rows of the NAMED_OBJ_LIST table.
type NamedObjListRow struct {
    NamedObjID	int
    MemberNamedObjTypeID	sql.NullString
}

// IterateNamedObjList provide access to all rows of the NAMED_OBJ_LIST matching given criteria.
func IterateNamedObjList(db *sql.DB, where string, callback func(v *NamedObjListRow) error) error {
    query := "SELECT NAMED_OBJ_ID,MEMBER_NAMED_OBJ_TYPE_ID FROM NAMED_OBJ_LIST"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedObjListRow
        err := rows.Scan(&r.NamedObjID, &r.MemberNamedObjTypeID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedObjList provide iterator to all rows of the NAMED_OBJ_LIST matching given criteria.
func RangeNamedObjList(db *sql.DB, where string) iter.Seq2[*NamedObjListRow, error] {
	return func(yield func(v *NamedObjListRow, err error) bool) {
	    query := "SELECT NAMED_OBJ_ID,MEMBER_NAMED_OBJ_TYPE_ID FROM NAMED_OBJ_LIST"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedObjListRow
	        err := rows.Scan(&r.NamedObjID, &r.MemberNamedObjTypeID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedObjTypesRow struct represents rows of the NAMED_OBJ_TYPES table.
type NamedObjTypesRow struct {
    ID	string
    HandlerClass	string
}

// IterateNamedObjTypes provide access to all rows of the NAMED_OBJ_TYPES matching given criteria.
func IterateNamedObjTypes(db *sql.DB, where string, callback func(v *NamedObjTypesRow) error) error {
    query := "SELECT ID,HANDLER_CLASS FROM NAMED_OBJ_TYPES"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedObjTypesRow
        err := rows.Scan(&r.ID, &r.HandlerClass)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedObjTypes provide iterator to all rows of the NAMED_OBJ_TYPES matching given criteria.
func RangeNamedObjTypes(db *sql.DB, where string) iter.Seq2[*NamedObjTypesRow, error] {
	return func(yield func(v *NamedObjTypesRow, err error) bool) {
	    query := "SELECT ID,HANDLER_CLASS FROM NAMED_OBJ_TYPES"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedObjTypesRow
	        err := rows.Scan(&r.ID, &r.HandlerClass)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedProtocolServiceRow struct represents rows of the NAMED_PROTOCOL_SERVICE table.
type NamedProtocolServiceRow struct {
    NamedServiceID	uint
}

// IterateNamedProtocolService provide access to all rows of the NAMED_PROTOCOL_SERVICE matching given criteria.
func IterateNamedProtocolService(db *sql.DB, where string, callback func(v *NamedProtocolServiceRow) error) error {
    query := "SELECT NAMED_SERVICE_ID FROM NAMED_PROTOCOL_SERVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedProtocolServiceRow
        err := rows.Scan(&r.NamedServiceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedProtocolService provide iterator to all rows of the NAMED_PROTOCOL_SERVICE matching given criteria.
func RangeNamedProtocolService(db *sql.DB, where string) iter.Seq2[*NamedProtocolServiceRow, error] {
	return func(yield func(v *NamedProtocolServiceRow, err error) bool) {
	    query := "SELECT NAMED_SERVICE_ID FROM NAMED_PROTOCOL_SERVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedProtocolServiceRow
	        err := rows.Scan(&r.NamedServiceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedProtocolServiceGroupRow struct represents rows of the NAMED_PROTOCOL_SERVICE_GROUP table.
type NamedProtocolServiceGroupRow struct {
    GroupID	uint
    NamedServiceID	uint
}

// IterateNamedProtocolServiceGroup provide access to all rows of the NAMED_PROTOCOL_SERVICE_GROUP matching given criteria.
func IterateNamedProtocolServiceGroup(db *sql.DB, where string, callback func(v *NamedProtocolServiceGroupRow) error) error {
    query := "SELECT GROUP_ID,NAMED_SERVICE_ID FROM NAMED_PROTOCOL_SERVICE_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedProtocolServiceGroupRow
        err := rows.Scan(&r.GroupID, &r.NamedServiceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedProtocolServiceGroup provide iterator to all rows of the NAMED_PROTOCOL_SERVICE_GROUP matching given criteria.
func RangeNamedProtocolServiceGroup(db *sql.DB, where string) iter.Seq2[*NamedProtocolServiceGroupRow, error] {
	return func(yield func(v *NamedProtocolServiceGroupRow, err error) bool) {
	    query := "SELECT GROUP_ID,NAMED_SERVICE_ID FROM NAMED_PROTOCOL_SERVICE_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedProtocolServiceGroupRow
	        err := rows.Scan(&r.GroupID, &r.NamedServiceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedProtocolServiceListRow struct represents rows of the NAMED_PROTOCOL_SERVICE_LIST table.
type NamedProtocolServiceListRow struct {
    NamedServiceID	uint
    MemberServiceObjType	string
}

// IterateNamedProtocolServiceList provide access to all rows of the NAMED_PROTOCOL_SERVICE_LIST matching given criteria.
func IterateNamedProtocolServiceList(db *sql.DB, where string, callback func(v *NamedProtocolServiceListRow) error) error {
    query := "SELECT NAMED_SERVICE_ID,MEMBER_SERVICE_OBJ_TYPE FROM NAMED_PROTOCOL_SERVICE_LIST"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedProtocolServiceListRow
        err := rows.Scan(&r.NamedServiceID, &r.MemberServiceObjType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedProtocolServiceList provide iterator to all rows of the NAMED_PROTOCOL_SERVICE_LIST matching given criteria.
func RangeNamedProtocolServiceList(db *sql.DB, where string) iter.Seq2[*NamedProtocolServiceListRow, error] {
	return func(yield func(v *NamedProtocolServiceListRow, err error) bool) {
	    query := "SELECT NAMED_SERVICE_ID,MEMBER_SERVICE_OBJ_TYPE FROM NAMED_PROTOCOL_SERVICE_LIST"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedProtocolServiceListRow
	        err := rows.Scan(&r.NamedServiceID, &r.MemberServiceObjType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedSnmpDestinationRow struct represents rows of the NAMED_SNMP_DESTINATION table.
type NamedSnmpDestinationRow struct {
    NamedObjID	int
    Port	int
    Address	string
    TrapCommunity	sql.NullString
}

// IterateNamedSnmpDestination provide access to all rows of the NAMED_SNMP_DESTINATION matching given criteria.
func IterateNamedSnmpDestination(db *sql.DB, where string, callback func(v *NamedSnmpDestinationRow) error) error {
    query := "SELECT NAMED_OBJ_ID,PORT,ADDRESS,TRAP_COMMUNITY FROM NAMED_SNMP_DESTINATION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedSnmpDestinationRow
        err := rows.Scan(&r.NamedObjID, &r.Port, &r.Address, &r.TrapCommunity)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedSnmpDestination provide iterator to all rows of the NAMED_SNMP_DESTINATION matching given criteria.
func RangeNamedSnmpDestination(db *sql.DB, where string) iter.Seq2[*NamedSnmpDestinationRow, error] {
	return func(yield func(v *NamedSnmpDestinationRow, err error) bool) {
	    query := "SELECT NAMED_OBJ_ID,PORT,ADDRESS,TRAP_COMMUNITY FROM NAMED_SNMP_DESTINATION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedSnmpDestinationRow
	        err := rows.Scan(&r.NamedObjID, &r.Port, &r.Address, &r.TrapCommunity)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedSyslogServerRow struct represents rows of the NAMED_SYSLOG_SERVER table.
type NamedSyslogServerRow struct {
    NamedObjID	int
    Port	int
    Protocol	uint16
    Loglevel	int
    Address	string
}

// IterateNamedSyslogServer provide access to all rows of the NAMED_SYSLOG_SERVER matching given criteria.
func IterateNamedSyslogServer(db *sql.DB, where string, callback func(v *NamedSyslogServerRow) error) error {
    query := "SELECT NAMED_OBJ_ID,PORT,PROTOCOL,LOGLEVEL,ADDRESS FROM NAMED_SYSLOG_SERVER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedSyslogServerRow
        err := rows.Scan(&r.NamedObjID, &r.Port, &r.Protocol, &r.Loglevel, &r.Address)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedSyslogServer provide iterator to all rows of the NAMED_SYSLOG_SERVER matching given criteria.
func RangeNamedSyslogServer(db *sql.DB, where string) iter.Seq2[*NamedSyslogServerRow, error] {
	return func(yield func(v *NamedSyslogServerRow, err error) bool) {
	    query := "SELECT NAMED_OBJ_ID,PORT,PROTOCOL,LOGLEVEL,ADDRESS FROM NAMED_SYSLOG_SERVER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedSyslogServerRow
	        err := rows.Scan(&r.NamedObjID, &r.Port, &r.Protocol, &r.Loglevel, &r.Address)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NamedVLANBlockRow struct represents rows of the NAMED_VLAN_BLOCK table.
type NamedVLANBlockRow struct {
    NamedObjID	int
    VLANBlock	sql.NullString
}

// IterateNamedVLANBlock provide access to all rows of the NAMED_VLAN_BLOCK matching given criteria.
func IterateNamedVLANBlock(db *sql.DB, where string, callback func(v *NamedVLANBlockRow) error) error {
    query := "SELECT NAMED_OBJ_ID,VLAN_BLOCK FROM NAMED_VLAN_BLOCK"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NamedVLANBlockRow
        err := rows.Scan(&r.NamedObjID, &r.VLANBlock)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNamedVLANBlock provide iterator to all rows of the NAMED_VLAN_BLOCK matching given criteria.
func RangeNamedVLANBlock(db *sql.DB, where string) iter.Seq2[*NamedVLANBlockRow, error] {
	return func(yield func(v *NamedVLANBlockRow, err error) bool) {
	    query := "SELECT NAMED_OBJ_ID,VLAN_BLOCK FROM NAMED_VLAN_BLOCK"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NamedVLANBlockRow
	        err := rows.Scan(&r.NamedObjID, &r.VLANBlock)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NatAddressRow struct represents rows of the NAT_ADDRESS table.
type NatAddressRow struct {
    ID	uint
    Network	string
    Address	sql.NullString
}

// IterateNatAddress provide access to all rows of the NAT_ADDRESS matching given criteria.
func IterateNatAddress(db *sql.DB, where string, callback func(v *NatAddressRow) error) error {
    query := "SELECT ID,NETWORK,ADDRESS FROM NAT_ADDRESS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NatAddressRow
        err := rows.Scan(&r.ID, &r.Network, &r.Address)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNatAddress provide iterator to all rows of the NAT_ADDRESS matching given criteria.
func RangeNatAddress(db *sql.DB, where string) iter.Seq2[*NatAddressRow, error] {
	return func(yield func(v *NatAddressRow, err error) bool) {
	    query := "SELECT ID,NETWORK,ADDRESS FROM NAT_ADDRESS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NatAddressRow
	        err := rows.Scan(&r.ID, &r.Network, &r.Address)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NatSettingsRow struct represents rows of the NAT_SETTINGS table.
type NatSettingsRow struct {
    ID	uint
    EnableGlobalNat	int8
    GlobalNatAddress	sql.NullString
    EnablePerNetworkNat	int8
}

// IterateNatSettings provide access to all rows of the NAT_SETTINGS matching given criteria.
func IterateNatSettings(db *sql.DB, where string, callback func(v *NatSettingsRow) error) error {
    query := "SELECT ID,ENABLE_GLOBAL_NAT,GLOBAL_NAT_ADDRESS,ENABLE_PER_NETWORK_NAT FROM NAT_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NatSettingsRow
        err := rows.Scan(&r.ID, &r.EnableGlobalNat, &r.GlobalNatAddress, &r.EnablePerNetworkNat)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNatSettings provide iterator to all rows of the NAT_SETTINGS matching given criteria.
func RangeNatSettings(db *sql.DB, where string) iter.Seq2[*NatSettingsRow, error] {
	return func(yield func(v *NatSettingsRow, err error) bool) {
	    query := "SELECT ID,ENABLE_GLOBAL_NAT,GLOBAL_NAT_ADDRESS,ENABLE_PER_NETWORK_NAT FROM NAT_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NatSettingsRow
	        err := rows.Scan(&r.ID, &r.EnableGlobalNat, &r.GlobalNatAddress, &r.EnablePerNetworkNat)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NetscriptRow struct represents rows of the NETSCRIPT table.
type NetscriptRow struct {
    ID	uint
    NetscriptTypeID	string
    Name	string
    Note	sql.NullString
    Version	int
    Singleton	int8
    Restricted	int8
    Description	sql.NullString
    PropertySchema	sql.NullString
}

// IterateNetscript provide access to all rows of the NETSCRIPT matching given criteria.
func IterateNetscript(db *sql.DB, where string, callback func(v *NetscriptRow) error) error {
    query := "SELECT ID,NETSCRIPT_TYPE_ID,NAME,NOTE,VERSION,SINGLETON,RESTRICTED,DESCRIPTION,PROPERTY_SCHEMA FROM NETSCRIPT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NetscriptRow
        err := rows.Scan(&r.ID, &r.NetscriptTypeID, &r.Name, &r.Note, &r.Version, &r.Singleton, &r.Restricted, &r.Description, &r.PropertySchema)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNetscript provide iterator to all rows of the NETSCRIPT matching given criteria.
func RangeNetscript(db *sql.DB, where string) iter.Seq2[*NetscriptRow, error] {
	return func(yield func(v *NetscriptRow, err error) bool) {
	    query := "SELECT ID,NETSCRIPT_TYPE_ID,NAME,NOTE,VERSION,SINGLETON,RESTRICTED,DESCRIPTION,PROPERTY_SCHEMA FROM NETSCRIPT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NetscriptRow
	        err := rows.Scan(&r.ID, &r.NetscriptTypeID, &r.Name, &r.Note, &r.Version, &r.Singleton, &r.Restricted, &r.Description, &r.PropertySchema)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NetscriptMigrateRow struct represents rows of the NETSCRIPT_MIGRATE table.
type NetscriptMigrateRow struct {
    ID	uint
    NetscriptID	sql.NullInt32
    Version	int
    Xsl	sql.NullString
}

// IterateNetscriptMigrate provide access to all rows of the NETSCRIPT_MIGRATE matching given criteria.
func IterateNetscriptMigrate(db *sql.DB, where string, callback func(v *NetscriptMigrateRow) error) error {
    query := "SELECT ID,NETSCRIPT_ID,VERSION,XSL FROM NETSCRIPT_MIGRATE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NetscriptMigrateRow
        err := rows.Scan(&r.ID, &r.NetscriptID, &r.Version, &r.Xsl)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNetscriptMigrate provide iterator to all rows of the NETSCRIPT_MIGRATE matching given criteria.
func RangeNetscriptMigrate(db *sql.DB, where string) iter.Seq2[*NetscriptMigrateRow, error] {
	return func(yield func(v *NetscriptMigrateRow, err error) bool) {
	    query := "SELECT ID,NETSCRIPT_ID,VERSION,XSL FROM NETSCRIPT_MIGRATE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NetscriptMigrateRow
	        err := rows.Scan(&r.ID, &r.NetscriptID, &r.Version, &r.Xsl)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NetscriptScriptletRow struct represents rows of the NETSCRIPT_SCRIPTLET table.
type NetscriptScriptletRow struct {
    ID	uint
    NetscriptID	sql.NullInt32
    Name	string
    Scriptlet	sql.NullString
}

// IterateNetscriptScriptlet provide access to all rows of the NETSCRIPT_SCRIPTLET matching given criteria.
func IterateNetscriptScriptlet(db *sql.DB, where string, callback func(v *NetscriptScriptletRow) error) error {
    query := "SELECT ID,NETSCRIPT_ID,NAME,SCRIPTLET FROM NETSCRIPT_SCRIPTLET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NetscriptScriptletRow
        err := rows.Scan(&r.ID, &r.NetscriptID, &r.Name, &r.Scriptlet)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNetscriptScriptlet provide iterator to all rows of the NETSCRIPT_SCRIPTLET matching given criteria.
func RangeNetscriptScriptlet(db *sql.DB, where string) iter.Seq2[*NetscriptScriptletRow, error] {
	return func(yield func(v *NetscriptScriptletRow, err error) bool) {
	    query := "SELECT ID,NETSCRIPT_ID,NAME,SCRIPTLET FROM NETSCRIPT_SCRIPTLET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NetscriptScriptletRow
	        err := rows.Scan(&r.ID, &r.NetscriptID, &r.Name, &r.Scriptlet)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NetscriptScriptletIncludeRow struct represents rows of the NETSCRIPT_SCRIPTLET_INCLUDE table.
type NetscriptScriptletIncludeRow struct {
    NetscriptScriptletIncludingID	uint
    NetscriptScriptletIncludedID	uint
}

// IterateNetscriptScriptletInclude provide access to all rows of the NETSCRIPT_SCRIPTLET_INCLUDE matching given criteria.
func IterateNetscriptScriptletInclude(db *sql.DB, where string, callback func(v *NetscriptScriptletIncludeRow) error) error {
    query := "SELECT NETSCRIPT_SCRIPTLET_INCLUDING_ID,NETSCRIPT_SCRIPTLET_INCLUDED_ID FROM NETSCRIPT_SCRIPTLET_INCLUDE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NetscriptScriptletIncludeRow
        err := rows.Scan(&r.NetscriptScriptletIncludingID, &r.NetscriptScriptletIncludedID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNetscriptScriptletInclude provide iterator to all rows of the NETSCRIPT_SCRIPTLET_INCLUDE matching given criteria.
func RangeNetscriptScriptletInclude(db *sql.DB, where string) iter.Seq2[*NetscriptScriptletIncludeRow, error] {
	return func(yield func(v *NetscriptScriptletIncludeRow, err error) bool) {
	    query := "SELECT NETSCRIPT_SCRIPTLET_INCLUDING_ID,NETSCRIPT_SCRIPTLET_INCLUDED_ID FROM NETSCRIPT_SCRIPTLET_INCLUDE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NetscriptScriptletIncludeRow
	        err := rows.Scan(&r.NetscriptScriptletIncludingID, &r.NetscriptScriptletIncludedID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NetscriptSystemOidRow struct represents rows of the NETSCRIPT_SYSTEM_OID table.
type NetscriptSystemOidRow struct {
    ID	uint
    NetscriptID	sql.NullInt32
    SystemOid	string
    Description	sql.NullString
}

// IterateNetscriptSystemOid provide access to all rows of the NETSCRIPT_SYSTEM_OID matching given criteria.
func IterateNetscriptSystemOid(db *sql.DB, where string, callback func(v *NetscriptSystemOidRow) error) error {
    query := "SELECT ID,NETSCRIPT_ID,SYSTEM_OID,DESCRIPTION FROM NETSCRIPT_SYSTEM_OID"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NetscriptSystemOidRow
        err := rows.Scan(&r.ID, &r.NetscriptID, &r.SystemOid, &r.Description)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNetscriptSystemOid provide iterator to all rows of the NETSCRIPT_SYSTEM_OID matching given criteria.
func RangeNetscriptSystemOid(db *sql.DB, where string) iter.Seq2[*NetscriptSystemOidRow, error] {
	return func(yield func(v *NetscriptSystemOidRow, err error) bool) {
	    query := "SELECT ID,NETSCRIPT_ID,SYSTEM_OID,DESCRIPTION FROM NETSCRIPT_SYSTEM_OID"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NetscriptSystemOidRow
	        err := rows.Scan(&r.ID, &r.NetscriptID, &r.SystemOid, &r.Description)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NetscriptTypeRefRow struct represents rows of the NETSCRIPT_TYPE_REF table.
type NetscriptTypeRefRow struct {
    ID	string
    Description	sql.NullString
}

// IterateNetscriptTypeRef provide access to all rows of the NETSCRIPT_TYPE_REF matching given criteria.
func IterateNetscriptTypeRef(db *sql.DB, where string, callback func(v *NetscriptTypeRefRow) error) error {
    query := "SELECT ID,DESCRIPTION FROM NETSCRIPT_TYPE_REF"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NetscriptTypeRefRow
        err := rows.Scan(&r.ID, &r.Description)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNetscriptTypeRef provide iterator to all rows of the NETSCRIPT_TYPE_REF matching given criteria.
func RangeNetscriptTypeRef(db *sql.DB, where string) iter.Seq2[*NetscriptTypeRefRow, error] {
	return func(yield func(v *NetscriptTypeRefRow, err error) bool) {
	    query := "SELECT ID,DESCRIPTION FROM NETSCRIPT_TYPE_REF"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NetscriptTypeRefRow
	        err := rows.Scan(&r.ID, &r.Description)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NetworkServiceRow struct represents rows of the NETWORK_SERVICE table.
type NetworkServiceRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    Name	sql.NullString
    DefaultService	sql.NullByte
    IPProtocol	sql.NullInt32
    FromPort	sql.NullInt32
    ToPort	sql.NullInt32
}

// IterateNetworkService provide access to all rows of the NETWORK_SERVICE matching given criteria.
func IterateNetworkService(db *sql.DB, where string, callback func(v *NetworkServiceRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,NAME,DEFAULT_SERVICE,IP_PROTOCOL,FROM_PORT,TO_PORT FROM NETWORK_SERVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NetworkServiceRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Name, &r.DefaultService, &r.IPProtocol, &r.FromPort, &r.ToPort)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNetworkService provide iterator to all rows of the NETWORK_SERVICE matching given criteria.
func RangeNetworkService(db *sql.DB, where string) iter.Seq2[*NetworkServiceRow, error] {
	return func(yield func(v *NetworkServiceRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,NAME,DEFAULT_SERVICE,IP_PROTOCOL,FROM_PORT,TO_PORT FROM NETWORK_SERVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NetworkServiceRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Name, &r.DefaultService, &r.IPProtocol, &r.FromPort, &r.ToPort)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwAccessListRow struct represents rows of the NGFW_ACCESS_LIST table.
type NgfwAccessListRow struct {
    ID	uint
    DeviceShortID	uint
    Version	sql.NullInt32
    AccessListName	sql.NullString
}

// IterateNgfwAccessList provide access to all rows of the NGFW_ACCESS_LIST matching given criteria.
func IterateNgfwAccessList(db *sql.DB, where string, callback func(v *NgfwAccessListRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,VERSION,ACCESS_LIST_NAME FROM NGFW_ACCESS_LIST"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwAccessListRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Version, &r.AccessListName)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwAccessList provide iterator to all rows of the NGFW_ACCESS_LIST matching given criteria.
func RangeNgfwAccessList(db *sql.DB, where string) iter.Seq2[*NgfwAccessListRow, error] {
	return func(yield func(v *NgfwAccessListRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,VERSION,ACCESS_LIST_NAME FROM NGFW_ACCESS_LIST"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwAccessListRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Version, &r.AccessListName)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwAccessListEntryRow struct represents rows of the NGFW_ACCESS_LIST_ENTRY table.
type NgfwAccessListEntryRow struct {
    ID	uint
    AccessListID	sql.NullInt32
    Sequence	sql.NullInt32
    SubnetIpaddr	sql.NullString
    Maskbits	sql.NullInt32
    Action	sql.NullString
}

// IterateNgfwAccessListEntry provide access to all rows of the NGFW_ACCESS_LIST_ENTRY matching given criteria.
func IterateNgfwAccessListEntry(db *sql.DB, where string, callback func(v *NgfwAccessListEntryRow) error) error {
    query := "SELECT ID,ACCESS_LIST_ID,SEQUENCE,SUBNET_IPADDR,MASKBITS,ACTION FROM NGFW_ACCESS_LIST_ENTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwAccessListEntryRow
        err := rows.Scan(&r.ID, &r.AccessListID, &r.Sequence, &r.SubnetIpaddr, &r.Maskbits, &r.Action)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwAccessListEntry provide iterator to all rows of the NGFW_ACCESS_LIST_ENTRY matching given criteria.
func RangeNgfwAccessListEntry(db *sql.DB, where string) iter.Seq2[*NgfwAccessListEntryRow, error] {
	return func(yield func(v *NgfwAccessListEntryRow, err error) bool) {
	    query := "SELECT ID,ACCESS_LIST_ID,SEQUENCE,SUBNET_IPADDR,MASKBITS,ACTION FROM NGFW_ACCESS_LIST_ENTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwAccessListEntryRow
	        err := rows.Scan(&r.ID, &r.AccessListID, &r.Sequence, &r.SubnetIpaddr, &r.Maskbits, &r.Action)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwAggrIfaceMappingRow struct represents rows of the NGFW_AGGR_IFACE_MAPPING table.
type NgfwAggrIfaceMappingRow struct {
    ID	uint
    AggrIfaceID	uint
    InterfaceID	uint
    LinkMode	string
    Priority	sql.NullInt32
}

// IterateNgfwAggrIfaceMapping provide access to all rows of the NGFW_AGGR_IFACE_MAPPING matching given criteria.
func IterateNgfwAggrIfaceMapping(db *sql.DB, where string, callback func(v *NgfwAggrIfaceMappingRow) error) error {
    query := "SELECT ID,AGGR_IFACE_ID,INTERFACE_ID,LINK_MODE,PRIORITY FROM NGFW_AGGR_IFACE_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwAggrIfaceMappingRow
        err := rows.Scan(&r.ID, &r.AggrIfaceID, &r.InterfaceID, &r.LinkMode, &r.Priority)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwAggrIfaceMapping provide iterator to all rows of the NGFW_AGGR_IFACE_MAPPING matching given criteria.
func RangeNgfwAggrIfaceMapping(db *sql.DB, where string) iter.Seq2[*NgfwAggrIfaceMappingRow, error] {
	return func(yield func(v *NgfwAggrIfaceMappingRow, err error) bool) {
	    query := "SELECT ID,AGGR_IFACE_ID,INTERFACE_ID,LINK_MODE,PRIORITY FROM NGFW_AGGR_IFACE_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwAggrIfaceMappingRow
	        err := rows.Scan(&r.ID, &r.AggrIfaceID, &r.InterfaceID, &r.LinkMode, &r.Priority)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwArpEntryRow struct represents rows of the NGFW_ARP_ENTRY table.
type NgfwArpEntryRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    IPV4NamedObjID	int
    IPV4NamedObjAddressBlock	string
    EntryState	sql.NullString
    InterfaceID	uint
    MacAddr	uint64
}

// IterateNgfwArpEntry provide access to all rows of the NGFW_ARP_ENTRY matching given criteria.
func IterateNgfwArpEntry(db *sql.DB, where string, callback func(v *NgfwArpEntryRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,IP_V4_NAMED_OBJ_ID,IP_V4_NAMED_OBJ_ADDRESS_BLOCK,ENTRY_STATE,INTERFACE_ID,MAC_ADDR FROM NGFW_ARP_ENTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwArpEntryRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.IPV4NamedObjID, &r.IPV4NamedObjAddressBlock, &r.EntryState, &r.InterfaceID, &r.MacAddr)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwArpEntry provide iterator to all rows of the NGFW_ARP_ENTRY matching given criteria.
func RangeNgfwArpEntry(db *sql.DB, where string) iter.Seq2[*NgfwArpEntryRow, error] {
	return func(yield func(v *NgfwArpEntryRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,IP_V4_NAMED_OBJ_ID,IP_V4_NAMED_OBJ_ADDRESS_BLOCK,ENTRY_STATE,INTERFACE_ID,MAC_ADDR FROM NGFW_ARP_ENTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwArpEntryRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.IPV4NamedObjID, &r.IPV4NamedObjAddressBlock, &r.EntryState, &r.InterfaceID, &r.MacAddr)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwAuthGeneralSettingsRow struct represents rows of the NGFW_AUTH_GENERAL_SETTINGS table.
type NgfwAuthGeneralSettingsRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    PwQuality	string
    PwExpiry	string
    PwExpiryAction	string
    LoginFailureAction	string
    LoginMaxAttempts	uint16
    LockoutPeriodMins	uint
    RemoteLoginAdminGrp	sql.NullString
    RemoteLoginNetworkGrp	sql.NullString
    AuthenticationSource	string
    WebCertificateThumbprint	sql.NullString
}

// IterateNgfwAuthGeneralSettings provide access to all rows of the NGFW_AUTH_GENERAL_SETTINGS matching given criteria.
func IterateNgfwAuthGeneralSettings(db *sql.DB, where string, callback func(v *NgfwAuthGeneralSettingsRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,PW_QUALITY,PW_EXPIRY,PW_EXPIRY_ACTION,LOGIN_FAILURE_ACTION,LOGIN_MAX_ATTEMPTS,LOCKOUT_PERIOD_MINS,REMOTE_LOGIN_ADMIN_GRP,REMOTE_LOGIN_NETWORK_GRP,AUTHENTICATION_SOURCE,WEB_CERTIFICATE_THUMBPRINT FROM NGFW_AUTH_GENERAL_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwAuthGeneralSettingsRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.PwQuality, &r.PwExpiry, &r.PwExpiryAction, &r.LoginFailureAction, &r.LoginMaxAttempts, &r.LockoutPeriodMins, &r.RemoteLoginAdminGrp, &r.RemoteLoginNetworkGrp, &r.AuthenticationSource, &r.WebCertificateThumbprint)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwAuthGeneralSettings provide iterator to all rows of the NGFW_AUTH_GENERAL_SETTINGS matching given criteria.
func RangeNgfwAuthGeneralSettings(db *sql.DB, where string) iter.Seq2[*NgfwAuthGeneralSettingsRow, error] {
	return func(yield func(v *NgfwAuthGeneralSettingsRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,PW_QUALITY,PW_EXPIRY,PW_EXPIRY_ACTION,LOGIN_FAILURE_ACTION,LOGIN_MAX_ATTEMPTS,LOCKOUT_PERIOD_MINS,REMOTE_LOGIN_ADMIN_GRP,REMOTE_LOGIN_NETWORK_GRP,AUTHENTICATION_SOURCE,WEB_CERTIFICATE_THUMBPRINT FROM NGFW_AUTH_GENERAL_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwAuthGeneralSettingsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.PwQuality, &r.PwExpiry, &r.PwExpiryAction, &r.LoginFailureAction, &r.LoginMaxAttempts, &r.LockoutPeriodMins, &r.RemoteLoginAdminGrp, &r.RemoteLoginNetworkGrp, &r.AuthenticationSource, &r.WebCertificateThumbprint)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwAutoRestartRow struct represents rows of the NGFW_AUTO_RESTART table.
type NgfwAutoRestartRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Enable	int8
}

// IterateNgfwAutoRestart provide access to all rows of the NGFW_AUTO_RESTART matching given criteria.
func IterateNgfwAutoRestart(db *sql.DB, where string, callback func(v *NgfwAutoRestartRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLE FROM NGFW_AUTO_RESTART"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwAutoRestartRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enable)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwAutoRestart provide iterator to all rows of the NGFW_AUTO_RESTART matching given criteria.
func RangeNgfwAutoRestart(db *sql.DB, where string) iter.Seq2[*NgfwAutoRestartRow, error] {
	return func(yield func(v *NgfwAutoRestartRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLE FROM NGFW_AUTO_RESTART"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwAutoRestartRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enable)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwBgpAggregateRow struct represents rows of the NGFW_BGP_AGGREGATE table.
type NgfwBgpAggregateRow struct {
    ID	uint
    SubnetIpaddr	sql.NullString
    Maskbits	sql.NullInt32
    SummaryOnly	sql.NullByte
    AsSet	sql.NullByte
    NgfwBgpGeneralDeviceShortID	sql.NullInt32
}

// IterateNgfwBgpAggregate provide access to all rows of the NGFW_BGP_AGGREGATE matching given criteria.
func IterateNgfwBgpAggregate(db *sql.DB, where string, callback func(v *NgfwBgpAggregateRow) error) error {
    query := "SELECT ID,SUBNET_IPADDR,MASKBITS,SUMMARY_ONLY,AS_SET,NGFW_BGP_GENERAL_DEVICE_SHORT_ID FROM NGFW_BGP_AGGREGATE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwBgpAggregateRow
        err := rows.Scan(&r.ID, &r.SubnetIpaddr, &r.Maskbits, &r.SummaryOnly, &r.AsSet, &r.NgfwBgpGeneralDeviceShortID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwBgpAggregate provide iterator to all rows of the NGFW_BGP_AGGREGATE matching given criteria.
func RangeNgfwBgpAggregate(db *sql.DB, where string) iter.Seq2[*NgfwBgpAggregateRow, error] {
	return func(yield func(v *NgfwBgpAggregateRow, err error) bool) {
	    query := "SELECT ID,SUBNET_IPADDR,MASKBITS,SUMMARY_ONLY,AS_SET,NGFW_BGP_GENERAL_DEVICE_SHORT_ID FROM NGFW_BGP_AGGREGATE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwBgpAggregateRow
	        err := rows.Scan(&r.ID, &r.SubnetIpaddr, &r.Maskbits, &r.SummaryOnly, &r.AsSet, &r.NgfwBgpGeneralDeviceShortID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwBgpAspathFilterListRow struct represents rows of the NGFW_BGP_ASPATH_FILTER_LIST table.
type NgfwBgpAspathFilterListRow struct {
    DbID	uint
    Version	uint
    DeviceShortID	sql.NullInt32
    Name	sql.NullString
}

// IterateNgfwBgpAspathFilterList provide access to all rows of the NGFW_BGP_ASPATH_FILTER_LIST matching given criteria.
func IterateNgfwBgpAspathFilterList(db *sql.DB, where string, callback func(v *NgfwBgpAspathFilterListRow) error) error {
    query := "SELECT DB_ID,VERSION,DEVICE_SHORT_ID,NAME FROM NGFW_BGP_ASPATH_FILTER_LIST"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwBgpAspathFilterListRow
        err := rows.Scan(&r.DbID, &r.Version, &r.DeviceShortID, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwBgpAspathFilterList provide iterator to all rows of the NGFW_BGP_ASPATH_FILTER_LIST matching given criteria.
func RangeNgfwBgpAspathFilterList(db *sql.DB, where string) iter.Seq2[*NgfwBgpAspathFilterListRow, error] {
	return func(yield func(v *NgfwBgpAspathFilterListRow, err error) bool) {
	    query := "SELECT DB_ID,VERSION,DEVICE_SHORT_ID,NAME FROM NGFW_BGP_ASPATH_FILTER_LIST"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwBgpAspathFilterListRow
	        err := rows.Scan(&r.DbID, &r.Version, &r.DeviceShortID, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwBgpAspathFilterListEntryRow struct represents rows of the NGFW_BGP_ASPATH_FILTER_LIST_ENTRY table.
type NgfwBgpAspathFilterListEntryRow struct {
    ID	uint
    Sequence	sql.NullInt32
    Length	sql.NullInt32
    Action	sql.NullString
    AspathFilter	sql.NullString
    NgfwBgpAspathFilterListID	sql.NullInt32
}

// IterateNgfwBgpAspathFilterListEntry provide access to all rows of the NGFW_BGP_ASPATH_FILTER_LIST_ENTRY matching given criteria.
func IterateNgfwBgpAspathFilterListEntry(db *sql.DB, where string, callback func(v *NgfwBgpAspathFilterListEntryRow) error) error {
    query := "SELECT ID,SEQUENCE,LENGTH,ACTION,ASPATH_FILTER,NGFW_BGP_ASPATH_FILTER_LIST_ID FROM NGFW_BGP_ASPATH_FILTER_LIST_ENTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwBgpAspathFilterListEntryRow
        err := rows.Scan(&r.ID, &r.Sequence, &r.Length, &r.Action, &r.AspathFilter, &r.NgfwBgpAspathFilterListID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwBgpAspathFilterListEntry provide iterator to all rows of the NGFW_BGP_ASPATH_FILTER_LIST_ENTRY matching given criteria.
func RangeNgfwBgpAspathFilterListEntry(db *sql.DB, where string) iter.Seq2[*NgfwBgpAspathFilterListEntryRow, error] {
	return func(yield func(v *NgfwBgpAspathFilterListEntryRow, err error) bool) {
	    query := "SELECT ID,SEQUENCE,LENGTH,ACTION,ASPATH_FILTER,NGFW_BGP_ASPATH_FILTER_LIST_ID FROM NGFW_BGP_ASPATH_FILTER_LIST_ENTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwBgpAspathFilterListEntryRow
	        err := rows.Scan(&r.ID, &r.Sequence, &r.Length, &r.Action, &r.AspathFilter, &r.NgfwBgpAspathFilterListID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwBgpCommunityListRow struct represents rows of the NGFW_BGP_COMMUNITY_LIST table.
type NgfwBgpCommunityListRow struct {
    DbID	uint
    Version	uint
    DeviceShortID	sql.NullInt32
    CommunityListName	sql.NullString
}

// IterateNgfwBgpCommunityList provide access to all rows of the NGFW_BGP_COMMUNITY_LIST matching given criteria.
func IterateNgfwBgpCommunityList(db *sql.DB, where string, callback func(v *NgfwBgpCommunityListRow) error) error {
    query := "SELECT DB_ID,VERSION,DEVICE_SHORT_ID,COMMUNITY_LIST_NAME FROM NGFW_BGP_COMMUNITY_LIST"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwBgpCommunityListRow
        err := rows.Scan(&r.DbID, &r.Version, &r.DeviceShortID, &r.CommunityListName)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwBgpCommunityList provide iterator to all rows of the NGFW_BGP_COMMUNITY_LIST matching given criteria.
func RangeNgfwBgpCommunityList(db *sql.DB, where string) iter.Seq2[*NgfwBgpCommunityListRow, error] {
	return func(yield func(v *NgfwBgpCommunityListRow, err error) bool) {
	    query := "SELECT DB_ID,VERSION,DEVICE_SHORT_ID,COMMUNITY_LIST_NAME FROM NGFW_BGP_COMMUNITY_LIST"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwBgpCommunityListRow
	        err := rows.Scan(&r.DbID, &r.Version, &r.DeviceShortID, &r.CommunityListName)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwBgpCommunityListEntryRow struct represents rows of the NGFW_BGP_COMMUNITY_LIST_ENTRY table.
type NgfwBgpCommunityListEntryRow struct {
    ID	uint
    Sequence	sql.NullInt32
    Type	sql.NullString
    Action	sql.NullString
    CommunityNumber	sql.NullInt32
    NgfwBgpCommunityListID	sql.NullInt32
}

// IterateNgfwBgpCommunityListEntry provide access to all rows of the NGFW_BGP_COMMUNITY_LIST_ENTRY matching given criteria.
func IterateNgfwBgpCommunityListEntry(db *sql.DB, where string, callback func(v *NgfwBgpCommunityListEntryRow) error) error {
    query := "SELECT ID,SEQUENCE,TYPE,ACTION,COMMUNITY_NUMBER,NGFW_BGP_COMMUNITY_LIST_ID FROM NGFW_BGP_COMMUNITY_LIST_ENTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwBgpCommunityListEntryRow
        err := rows.Scan(&r.ID, &r.Sequence, &r.Type, &r.Action, &r.CommunityNumber, &r.NgfwBgpCommunityListID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwBgpCommunityListEntry provide iterator to all rows of the NGFW_BGP_COMMUNITY_LIST_ENTRY matching given criteria.
func RangeNgfwBgpCommunityListEntry(db *sql.DB, where string) iter.Seq2[*NgfwBgpCommunityListEntryRow, error] {
	return func(yield func(v *NgfwBgpCommunityListEntryRow, err error) bool) {
	    query := "SELECT ID,SEQUENCE,TYPE,ACTION,COMMUNITY_NUMBER,NGFW_BGP_COMMUNITY_LIST_ID FROM NGFW_BGP_COMMUNITY_LIST_ENTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwBgpCommunityListEntryRow
	        err := rows.Scan(&r.ID, &r.Sequence, &r.Type, &r.Action, &r.CommunityNumber, &r.NgfwBgpCommunityListID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwBgpGeneralRow struct represents rows of the NGFW_BGP_GENERAL table.
type NgfwBgpGeneralRow struct {
    DeviceShortID	uint
    Version	uint
    AsNumber	sql.NullInt64
    Enabled	sql.NullByte
    GracefulRestart	sql.NullByte
    RestartTime	sql.NullInt32
    StalePathTime	sql.NullInt32
    RouterID	sql.NullInt64
    Keepalive	sql.NullInt32
    Holdtime	sql.NullInt32
    EbgpDistance	sql.NullInt32
    IbgpDistance	sql.NullInt32
    LocalDistance	sql.NullInt32
    LocalPreference	sql.NullInt64
    AlwaysCompareMed	sql.NullByte
    DeterministicMed	sql.NullByte
}

// IterateNgfwBgpGeneral provide access to all rows of the NGFW_BGP_GENERAL matching given criteria.
func IterateNgfwBgpGeneral(db *sql.DB, where string, callback func(v *NgfwBgpGeneralRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,VERSION,AS_NUMBER,ENABLED,GRACEFUL_RESTART,RESTART_TIME,STALE_PATH_TIME,ROUTER_ID,KEEPALIVE,HOLDTIME,EBGP_DISTANCE,IBGP_DISTANCE,LOCAL_DISTANCE,LOCAL_PREFERENCE,ALWAYS_COMPARE_MED,DETERMINISTIC_MED FROM NGFW_BGP_GENERAL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwBgpGeneralRow
        err := rows.Scan(&r.DeviceShortID, &r.Version, &r.AsNumber, &r.Enabled, &r.GracefulRestart, &r.RestartTime, &r.StalePathTime, &r.RouterID, &r.Keepalive, &r.Holdtime, &r.EbgpDistance, &r.IbgpDistance, &r.LocalDistance, &r.LocalPreference, &r.AlwaysCompareMed, &r.DeterministicMed)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwBgpGeneral provide iterator to all rows of the NGFW_BGP_GENERAL matching given criteria.
func RangeNgfwBgpGeneral(db *sql.DB, where string) iter.Seq2[*NgfwBgpGeneralRow, error] {
	return func(yield func(v *NgfwBgpGeneralRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,VERSION,AS_NUMBER,ENABLED,GRACEFUL_RESTART,RESTART_TIME,STALE_PATH_TIME,ROUTER_ID,KEEPALIVE,HOLDTIME,EBGP_DISTANCE,IBGP_DISTANCE,LOCAL_DISTANCE,LOCAL_PREFERENCE,ALWAYS_COMPARE_MED,DETERMINISTIC_MED FROM NGFW_BGP_GENERAL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwBgpGeneralRow
	        err := rows.Scan(&r.DeviceShortID, &r.Version, &r.AsNumber, &r.Enabled, &r.GracefulRestart, &r.RestartTime, &r.StalePathTime, &r.RouterID, &r.Keepalive, &r.Holdtime, &r.EbgpDistance, &r.IbgpDistance, &r.LocalDistance, &r.LocalPreference, &r.AlwaysCompareMed, &r.DeterministicMed)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwBgpIpsubnetRow struct represents rows of the NGFW_BGP_IPSUBNET table.
type NgfwBgpIpsubnetRow struct {
    ID	uint
    SubnetIpaddr	sql.NullString
    Maskbits	sql.NullInt32
    NgfwBgpGeneralDeviceShortID	sql.NullInt32
}

// IterateNgfwBgpIpsubnet provide access to all rows of the NGFW_BGP_IPSUBNET matching given criteria.
func IterateNgfwBgpIpsubnet(db *sql.DB, where string, callback func(v *NgfwBgpIpsubnetRow) error) error {
    query := "SELECT ID,SUBNET_IPADDR,MASKBITS,NGFW_BGP_GENERAL_DEVICE_SHORT_ID FROM NGFW_BGP_IPSUBNET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwBgpIpsubnetRow
        err := rows.Scan(&r.ID, &r.SubnetIpaddr, &r.Maskbits, &r.NgfwBgpGeneralDeviceShortID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwBgpIpsubnet provide iterator to all rows of the NGFW_BGP_IPSUBNET matching given criteria.
func RangeNgfwBgpIpsubnet(db *sql.DB, where string) iter.Seq2[*NgfwBgpIpsubnetRow, error] {
	return func(yield func(v *NgfwBgpIpsubnetRow, err error) bool) {
	    query := "SELECT ID,SUBNET_IPADDR,MASKBITS,NGFW_BGP_GENERAL_DEVICE_SHORT_ID FROM NGFW_BGP_IPSUBNET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwBgpIpsubnetRow
	        err := rows.Scan(&r.ID, &r.SubnetIpaddr, &r.Maskbits, &r.NgfwBgpGeneralDeviceShortID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwBgpNeighborRow struct represents rows of the NGFW_BGP_NEIGHBOR table.
type NgfwBgpNeighborRow struct {
    DbID	uint
    Version	uint
    DeviceShortID	sql.NullInt32
    NeighborID	sql.NullString
    AsNumber	sql.NullInt64
    NeighborDescription	sql.NullString
    MultihopEnabled	sql.NullByte
    Multihops	sql.NullInt32
    InboundSoftReconfiguration	sql.NullByte
    InboundDistributeAccessListName	sql.NullString
    OutboundDistributeAccessListName	sql.NullString
    InboundPrefixListName	sql.NullString
    OutboundPrefixListName	sql.NullString
    InboundAspathFilterListName	sql.NullString
    OutboundAspathFilterListName	sql.NullString
    AuthenticationType	sql.NullString
    AuthenticationPasswd	sql.NullString
    RouteReflectorClient	sql.NullByte
    InboundRouteMapName	sql.NullString
    OutboundRouteMapName	sql.NullString
    Passive	sql.NullByte
    Shutdown	sql.NullByte
    NextHopSelf	sql.NullByte
    UpdateSourceAddr	sql.NullString
    Weight	sql.NullInt32
    MaximumPrefix	sql.NullInt64
    RemovePrivateAs	sql.NullByte
    SendCommunity	sql.NullByte
}

// IterateNgfwBgpNeighbor provide access to all rows of the NGFW_BGP_NEIGHBOR matching given criteria.
func IterateNgfwBgpNeighbor(db *sql.DB, where string, callback func(v *NgfwBgpNeighborRow) error) error {
    query := "SELECT DB_ID,VERSION,DEVICE_SHORT_ID,NEIGHBOR_ID,AS_NUMBER,NEIGHBOR_DESCRIPTION,MULTIHOP_ENABLED,MULTIHOPS,INBOUND_SOFT_RECONFIGURATION,INBOUND_DISTRIBUTE_ACCESS_LIST_NAME,OUTBOUND_DISTRIBUTE_ACCESS_LIST_NAME,INBOUND_PREFIX_LIST_NAME,OUTBOUND_PREFIX_LIST_NAME,INBOUND_ASPATH_FILTER_LIST_NAME,OUTBOUND_ASPATH_FILTER_LIST_NAME,AUTHENTICATION_TYPE,AUTHENTICATION_PASSWD,ROUTE_REFLECTOR_CLIENT,INBOUND_ROUTE_MAP_NAME,OUTBOUND_ROUTE_MAP_NAME,PASSIVE,SHUTDOWN,NEXT_HOP_SELF,UPDATE_SOURCE_ADDR,WEIGHT,MAXIMUM_PREFIX,REMOVE_PRIVATE_AS,SEND_COMMUNITY FROM NGFW_BGP_NEIGHBOR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwBgpNeighborRow
        err := rows.Scan(&r.DbID, &r.Version, &r.DeviceShortID, &r.NeighborID, &r.AsNumber, &r.NeighborDescription, &r.MultihopEnabled, &r.Multihops, &r.InboundSoftReconfiguration, &r.InboundDistributeAccessListName, &r.OutboundDistributeAccessListName, &r.InboundPrefixListName, &r.OutboundPrefixListName, &r.InboundAspathFilterListName, &r.OutboundAspathFilterListName, &r.AuthenticationType, &r.AuthenticationPasswd, &r.RouteReflectorClient, &r.InboundRouteMapName, &r.OutboundRouteMapName, &r.Passive, &r.Shutdown, &r.NextHopSelf, &r.UpdateSourceAddr, &r.Weight, &r.MaximumPrefix, &r.RemovePrivateAs, &r.SendCommunity)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwBgpNeighbor provide iterator to all rows of the NGFW_BGP_NEIGHBOR matching given criteria.
func RangeNgfwBgpNeighbor(db *sql.DB, where string) iter.Seq2[*NgfwBgpNeighborRow, error] {
	return func(yield func(v *NgfwBgpNeighborRow, err error) bool) {
	    query := "SELECT DB_ID,VERSION,DEVICE_SHORT_ID,NEIGHBOR_ID,AS_NUMBER,NEIGHBOR_DESCRIPTION,MULTIHOP_ENABLED,MULTIHOPS,INBOUND_SOFT_RECONFIGURATION,INBOUND_DISTRIBUTE_ACCESS_LIST_NAME,OUTBOUND_DISTRIBUTE_ACCESS_LIST_NAME,INBOUND_PREFIX_LIST_NAME,OUTBOUND_PREFIX_LIST_NAME,INBOUND_ASPATH_FILTER_LIST_NAME,OUTBOUND_ASPATH_FILTER_LIST_NAME,AUTHENTICATION_TYPE,AUTHENTICATION_PASSWD,ROUTE_REFLECTOR_CLIENT,INBOUND_ROUTE_MAP_NAME,OUTBOUND_ROUTE_MAP_NAME,PASSIVE,SHUTDOWN,NEXT_HOP_SELF,UPDATE_SOURCE_ADDR,WEIGHT,MAXIMUM_PREFIX,REMOVE_PRIVATE_AS,SEND_COMMUNITY FROM NGFW_BGP_NEIGHBOR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwBgpNeighborRow
	        err := rows.Scan(&r.DbID, &r.Version, &r.DeviceShortID, &r.NeighborID, &r.AsNumber, &r.NeighborDescription, &r.MultihopEnabled, &r.Multihops, &r.InboundSoftReconfiguration, &r.InboundDistributeAccessListName, &r.OutboundDistributeAccessListName, &r.InboundPrefixListName, &r.OutboundPrefixListName, &r.InboundAspathFilterListName, &r.OutboundAspathFilterListName, &r.AuthenticationType, &r.AuthenticationPasswd, &r.RouteReflectorClient, &r.InboundRouteMapName, &r.OutboundRouteMapName, &r.Passive, &r.Shutdown, &r.NextHopSelf, &r.UpdateSourceAddr, &r.Weight, &r.MaximumPrefix, &r.RemovePrivateAs, &r.SendCommunity)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwBgpPeerGroupRow struct represents rows of the NGFW_BGP_PEER_GROUP table.
type NgfwBgpPeerGroupRow struct {
    ID	uint
    Version	uint
    DeviceShortID	sql.NullInt32
    Name	sql.NullString
    AsNumber	sql.NullInt64
    NeighborDescription	sql.NullString
    MultihopEnabled	sql.NullByte
    Multihops	sql.NullInt32
    InboundSoftReconfiguration	sql.NullByte
    InboundDistributeAccessListName	sql.NullString
    OutboundDistributeAccessListName	sql.NullString
    InboundPrefixListName	sql.NullString
    OutboundPrefixListName	sql.NullString
    InboundAspathFilterListName	sql.NullString
    OutboundAspathFilterListName	sql.NullString
    AuthenticationType	sql.NullString
    AuthenticationPasswd	sql.NullString
    RouteReflectorClient	sql.NullByte
    InboundRouteMapName	sql.NullString
    OutboundRouteMapName	sql.NullString
    Passive	sql.NullByte
    Shutdown	sql.NullByte
    NextHopSelf	sql.NullByte
    UpdateSourceAddr	sql.NullString
    Weight	sql.NullInt32
    MaximumPrefix	sql.NullInt64
    RemovePrivateAs	sql.NullByte
    SendCommunity	sql.NullByte
}

// IterateNgfwBgpPeerGroup provide access to all rows of the NGFW_BGP_PEER_GROUP matching given criteria.
func IterateNgfwBgpPeerGroup(db *sql.DB, where string, callback func(v *NgfwBgpPeerGroupRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME,AS_NUMBER,NEIGHBOR_DESCRIPTION,MULTIHOP_ENABLED,MULTIHOPS,INBOUND_SOFT_RECONFIGURATION,INBOUND_DISTRIBUTE_ACCESS_LIST_NAME,OUTBOUND_DISTRIBUTE_ACCESS_LIST_NAME,INBOUND_PREFIX_LIST_NAME,OUTBOUND_PREFIX_LIST_NAME,INBOUND_ASPATH_FILTER_LIST_NAME,OUTBOUND_ASPATH_FILTER_LIST_NAME,AUTHENTICATION_TYPE,AUTHENTICATION_PASSWD,ROUTE_REFLECTOR_CLIENT,INBOUND_ROUTE_MAP_NAME,OUTBOUND_ROUTE_MAP_NAME,PASSIVE,SHUTDOWN,NEXT_HOP_SELF,UPDATE_SOURCE_ADDR,WEIGHT,MAXIMUM_PREFIX,REMOVE_PRIVATE_AS,SEND_COMMUNITY FROM NGFW_BGP_PEER_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwBgpPeerGroupRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Name, &r.AsNumber, &r.NeighborDescription, &r.MultihopEnabled, &r.Multihops, &r.InboundSoftReconfiguration, &r.InboundDistributeAccessListName, &r.OutboundDistributeAccessListName, &r.InboundPrefixListName, &r.OutboundPrefixListName, &r.InboundAspathFilterListName, &r.OutboundAspathFilterListName, &r.AuthenticationType, &r.AuthenticationPasswd, &r.RouteReflectorClient, &r.InboundRouteMapName, &r.OutboundRouteMapName, &r.Passive, &r.Shutdown, &r.NextHopSelf, &r.UpdateSourceAddr, &r.Weight, &r.MaximumPrefix, &r.RemovePrivateAs, &r.SendCommunity)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwBgpPeerGroup provide iterator to all rows of the NGFW_BGP_PEER_GROUP matching given criteria.
func RangeNgfwBgpPeerGroup(db *sql.DB, where string) iter.Seq2[*NgfwBgpPeerGroupRow, error] {
	return func(yield func(v *NgfwBgpPeerGroupRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME,AS_NUMBER,NEIGHBOR_DESCRIPTION,MULTIHOP_ENABLED,MULTIHOPS,INBOUND_SOFT_RECONFIGURATION,INBOUND_DISTRIBUTE_ACCESS_LIST_NAME,OUTBOUND_DISTRIBUTE_ACCESS_LIST_NAME,INBOUND_PREFIX_LIST_NAME,OUTBOUND_PREFIX_LIST_NAME,INBOUND_ASPATH_FILTER_LIST_NAME,OUTBOUND_ASPATH_FILTER_LIST_NAME,AUTHENTICATION_TYPE,AUTHENTICATION_PASSWD,ROUTE_REFLECTOR_CLIENT,INBOUND_ROUTE_MAP_NAME,OUTBOUND_ROUTE_MAP_NAME,PASSIVE,SHUTDOWN,NEXT_HOP_SELF,UPDATE_SOURCE_ADDR,WEIGHT,MAXIMUM_PREFIX,REMOVE_PRIVATE_AS,SEND_COMMUNITY FROM NGFW_BGP_PEER_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwBgpPeerGroupRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Name, &r.AsNumber, &r.NeighborDescription, &r.MultihopEnabled, &r.Multihops, &r.InboundSoftReconfiguration, &r.InboundDistributeAccessListName, &r.OutboundDistributeAccessListName, &r.InboundPrefixListName, &r.OutboundPrefixListName, &r.InboundAspathFilterListName, &r.OutboundAspathFilterListName, &r.AuthenticationType, &r.AuthenticationPasswd, &r.RouteReflectorClient, &r.InboundRouteMapName, &r.OutboundRouteMapName, &r.Passive, &r.Shutdown, &r.NextHopSelf, &r.UpdateSourceAddr, &r.Weight, &r.MaximumPrefix, &r.RemovePrivateAs, &r.SendCommunity)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwBgpPeerGroupNeighborRow struct represents rows of the NGFW_BGP_PEER_GROUP_NEIGHBOR table.
type NgfwBgpPeerGroupNeighborRow struct {
    NgfwBgpPeerGroupID	sql.NullInt32
    NgfwBgpNeighborID	sql.NullInt32
}

// IterateNgfwBgpPeerGroupNeighbor provide access to all rows of the NGFW_BGP_PEER_GROUP_NEIGHBOR matching given criteria.
func IterateNgfwBgpPeerGroupNeighbor(db *sql.DB, where string, callback func(v *NgfwBgpPeerGroupNeighborRow) error) error {
    query := "SELECT NGFW_BGP_PEER_GROUP_ID,NGFW_BGP_NEIGHBOR_ID FROM NGFW_BGP_PEER_GROUP_NEIGHBOR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwBgpPeerGroupNeighborRow
        err := rows.Scan(&r.NgfwBgpPeerGroupID, &r.NgfwBgpNeighborID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwBgpPeerGroupNeighbor provide iterator to all rows of the NGFW_BGP_PEER_GROUP_NEIGHBOR matching given criteria.
func RangeNgfwBgpPeerGroupNeighbor(db *sql.DB, where string) iter.Seq2[*NgfwBgpPeerGroupNeighborRow, error] {
	return func(yield func(v *NgfwBgpPeerGroupNeighborRow, err error) bool) {
	    query := "SELECT NGFW_BGP_PEER_GROUP_ID,NGFW_BGP_NEIGHBOR_ID FROM NGFW_BGP_PEER_GROUP_NEIGHBOR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwBgpPeerGroupNeighborRow
	        err := rows.Scan(&r.NgfwBgpPeerGroupID, &r.NgfwBgpNeighborID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwBgpPrefixListRow struct represents rows of the NGFW_BGP_PREFIX_LIST table.
type NgfwBgpPrefixListRow struct {
    DbID	uint
    Version	uint
    DeviceShortID	sql.NullInt32
    Name	sql.NullString
}

// IterateNgfwBgpPrefixList provide access to all rows of the NGFW_BGP_PREFIX_LIST matching given criteria.
func IterateNgfwBgpPrefixList(db *sql.DB, where string, callback func(v *NgfwBgpPrefixListRow) error) error {
    query := "SELECT DB_ID,VERSION,DEVICE_SHORT_ID,NAME FROM NGFW_BGP_PREFIX_LIST"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwBgpPrefixListRow
        err := rows.Scan(&r.DbID, &r.Version, &r.DeviceShortID, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwBgpPrefixList provide iterator to all rows of the NGFW_BGP_PREFIX_LIST matching given criteria.
func RangeNgfwBgpPrefixList(db *sql.DB, where string) iter.Seq2[*NgfwBgpPrefixListRow, error] {
	return func(yield func(v *NgfwBgpPrefixListRow, err error) bool) {
	    query := "SELECT DB_ID,VERSION,DEVICE_SHORT_ID,NAME FROM NGFW_BGP_PREFIX_LIST"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwBgpPrefixListRow
	        err := rows.Scan(&r.DbID, &r.Version, &r.DeviceShortID, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwBgpPrefixListEntryRow struct represents rows of the NGFW_BGP_PREFIX_LIST_ENTRY table.
type NgfwBgpPrefixListEntryRow struct {
    ID	uint
    Sequence	sql.NullInt32
    Action	sql.NullString
    SubnetIpaddr	sql.NullString
    Maskbits	sql.NullInt32
    MinLength	sql.NullInt32
    MaxLength	sql.NullInt32
    NgfwBgpPrefixListID	sql.NullInt32
}

// IterateNgfwBgpPrefixListEntry provide access to all rows of the NGFW_BGP_PREFIX_LIST_ENTRY matching given criteria.
func IterateNgfwBgpPrefixListEntry(db *sql.DB, where string, callback func(v *NgfwBgpPrefixListEntryRow) error) error {
    query := "SELECT ID,SEQUENCE,ACTION,SUBNET_IPADDR,MASKBITS,MIN_LENGTH,MAX_LENGTH,NGFW_BGP_PREFIX_LIST_ID FROM NGFW_BGP_PREFIX_LIST_ENTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwBgpPrefixListEntryRow
        err := rows.Scan(&r.ID, &r.Sequence, &r.Action, &r.SubnetIpaddr, &r.Maskbits, &r.MinLength, &r.MaxLength, &r.NgfwBgpPrefixListID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwBgpPrefixListEntry provide iterator to all rows of the NGFW_BGP_PREFIX_LIST_ENTRY matching given criteria.
func RangeNgfwBgpPrefixListEntry(db *sql.DB, where string) iter.Seq2[*NgfwBgpPrefixListEntryRow, error] {
	return func(yield func(v *NgfwBgpPrefixListEntryRow, err error) bool) {
	    query := "SELECT ID,SEQUENCE,ACTION,SUBNET_IPADDR,MASKBITS,MIN_LENGTH,MAX_LENGTH,NGFW_BGP_PREFIX_LIST_ID FROM NGFW_BGP_PREFIX_LIST_ENTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwBgpPrefixListEntryRow
	        err := rows.Scan(&r.ID, &r.Sequence, &r.Action, &r.SubnetIpaddr, &r.Maskbits, &r.MinLength, &r.MaxLength, &r.NgfwBgpPrefixListID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwBgpRedistributesRow struct represents rows of the NGFW_BGP_REDISTRIBUTES table.
type NgfwBgpRedistributesRow struct {
    NgfwBgpGeneralDeviceShortID	uint
    RedistributeID	uint
}

// IterateNgfwBgpRedistributes provide access to all rows of the NGFW_BGP_REDISTRIBUTES matching given criteria.
func IterateNgfwBgpRedistributes(db *sql.DB, where string, callback func(v *NgfwBgpRedistributesRow) error) error {
    query := "SELECT NGFW_BGP_GENERAL_DEVICE_SHORT_ID,REDISTRIBUTE_ID FROM NGFW_BGP_REDISTRIBUTES"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwBgpRedistributesRow
        err := rows.Scan(&r.NgfwBgpGeneralDeviceShortID, &r.RedistributeID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwBgpRedistributes provide iterator to all rows of the NGFW_BGP_REDISTRIBUTES matching given criteria.
func RangeNgfwBgpRedistributes(db *sql.DB, where string) iter.Seq2[*NgfwBgpRedistributesRow, error] {
	return func(yield func(v *NgfwBgpRedistributesRow, err error) bool) {
	    query := "SELECT NGFW_BGP_GENERAL_DEVICE_SHORT_ID,REDISTRIBUTE_ID FROM NGFW_BGP_REDISTRIBUTES"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwBgpRedistributesRow
	        err := rows.Scan(&r.NgfwBgpGeneralDeviceShortID, &r.RedistributeID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwBridgeIfaceMappingRow struct represents rows of the NGFW_BRIDGE_IFACE_MAPPING table.
type NgfwBridgeIfaceMappingRow struct {
    BridgeIfaceID	uint
    InterfaceID	uint
}

// IterateNgfwBridgeIfaceMapping provide access to all rows of the NGFW_BRIDGE_IFACE_MAPPING matching given criteria.
func IterateNgfwBridgeIfaceMapping(db *sql.DB, where string, callback func(v *NgfwBridgeIfaceMappingRow) error) error {
    query := "SELECT BRIDGE_IFACE_ID,INTERFACE_ID FROM NGFW_BRIDGE_IFACE_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwBridgeIfaceMappingRow
        err := rows.Scan(&r.BridgeIfaceID, &r.InterfaceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwBridgeIfaceMapping provide iterator to all rows of the NGFW_BRIDGE_IFACE_MAPPING matching given criteria.
func RangeNgfwBridgeIfaceMapping(db *sql.DB, where string) iter.Seq2[*NgfwBridgeIfaceMappingRow, error] {
	return func(yield func(v *NgfwBridgeIfaceMappingRow, err error) bool) {
	    query := "SELECT BRIDGE_IFACE_ID,INTERFACE_ID FROM NGFW_BRIDGE_IFACE_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwBridgeIfaceMappingRow
	        err := rows.Scan(&r.BridgeIfaceID, &r.InterfaceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwCaptivePortalSettingsRow struct represents rows of the NGFW_CAPTIVE_PORTAL_SETTINGS table.
type NgfwCaptivePortalSettingsRow struct {
    DbID	uint
    Version	uint
    DeviceShortID	uint
    ID	sql.NullString
    Port	sql.NullInt64
    CertificateID	sql.NullInt32
    MaxSessionTime	sql.NullInt64
    InactiveTime	sql.NullInt64
    LoginFgColor	sql.NullString
    LoginBgColor	sql.NullString
    LoginHeaderHtml	sql.NullString
    LoginFooterHtml	sql.NullString
    LoginFailedHtml	sql.NullString
    StatusFgColor	sql.NullString
    StatusBgColor	sql.NullString
    StatusMainHtml	sql.NullString
}

// IterateNgfwCaptivePortalSettings provide access to all rows of the NGFW_CAPTIVE_PORTAL_SETTINGS matching given criteria.
func IterateNgfwCaptivePortalSettings(db *sql.DB, where string, callback func(v *NgfwCaptivePortalSettingsRow) error) error {
    query := "SELECT DB_ID,VERSION,DEVICE_SHORT_ID,ID,PORT,CERTIFICATE_ID,MAX_SESSION_TIME,INACTIVE_TIME,LOGIN_FG_COLOR,LOGIN_BG_COLOR,LOGIN_HEADER_HTML,LOGIN_FOOTER_HTML,LOGIN_FAILED_HTML,STATUS_FG_COLOR,STATUS_BG_COLOR,STATUS_MAIN_HTML FROM NGFW_CAPTIVE_PORTAL_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwCaptivePortalSettingsRow
        err := rows.Scan(&r.DbID, &r.Version, &r.DeviceShortID, &r.ID, &r.Port, &r.CertificateID, &r.MaxSessionTime, &r.InactiveTime, &r.LoginFgColor, &r.LoginBgColor, &r.LoginHeaderHtml, &r.LoginFooterHtml, &r.LoginFailedHtml, &r.StatusFgColor, &r.StatusBgColor, &r.StatusMainHtml)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwCaptivePortalSettings provide iterator to all rows of the NGFW_CAPTIVE_PORTAL_SETTINGS matching given criteria.
func RangeNgfwCaptivePortalSettings(db *sql.DB, where string) iter.Seq2[*NgfwCaptivePortalSettingsRow, error] {
	return func(yield func(v *NgfwCaptivePortalSettingsRow, err error) bool) {
	    query := "SELECT DB_ID,VERSION,DEVICE_SHORT_ID,ID,PORT,CERTIFICATE_ID,MAX_SESSION_TIME,INACTIVE_TIME,LOGIN_FG_COLOR,LOGIN_BG_COLOR,LOGIN_HEADER_HTML,LOGIN_FOOTER_HTML,LOGIN_FAILED_HTML,STATUS_FG_COLOR,STATUS_BG_COLOR,STATUS_MAIN_HTML FROM NGFW_CAPTIVE_PORTAL_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwCaptivePortalSettingsRow
	        err := rows.Scan(&r.DbID, &r.Version, &r.DeviceShortID, &r.ID, &r.Port, &r.CertificateID, &r.MaxSessionTime, &r.InactiveTime, &r.LoginFgColor, &r.LoginBgColor, &r.LoginHeaderHtml, &r.LoginFooterHtml, &r.LoginFailedHtml, &r.StatusFgColor, &r.StatusBgColor, &r.StatusMainHtml)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwClusterMemberStatusRow struct represents rows of the NGFW_CLUSTER_MEMBER_STATUS table.
type NgfwClusterMemberStatusRow struct {
    ID	uint
    DeviceShortID	uint
    State	sql.NullString
    IsMaster	sql.NullByte
    MemberID	sql.NullString
    MemberName	sql.NullString
    SerialNumber	sql.NullString
    HwModel	sql.NullString
    SwVersion	sql.NullString
    ConfigHash	sql.NullString
    UpTimeScalar	sql.NullInt32
    JoinTimeScalar	sql.NullInt32
    IsSmsManaged	sql.NullByte
    SyncStatus	sql.NullString
    CfgCtrl	sql.NullString
    Health	sql.NullString
    HealthPercentage	sql.NullInt32
    Reason	sql.NullString
    UpdateTime	string
}

// IterateNgfwClusterMemberStatus provide access to all rows of the NGFW_CLUSTER_MEMBER_STATUS matching given criteria.
func IterateNgfwClusterMemberStatus(db *sql.DB, where string, callback func(v *NgfwClusterMemberStatusRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,STATE,IS_MASTER,MEMBER_ID,MEMBER_NAME,SERIAL_NUMBER,HW_MODEL,SW_VERSION,CONFIG_HASH,UP_TIME_SCALAR,JOIN_TIME_SCALAR,IS_SMS_MANAGED,SYNC_STATUS,CFG_CTRL,HEALTH,HEALTH_PERCENTAGE,REASON,UPDATE_TIME FROM NGFW_CLUSTER_MEMBER_STATUS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwClusterMemberStatusRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.State, &r.IsMaster, &r.MemberID, &r.MemberName, &r.SerialNumber, &r.HwModel, &r.SwVersion, &r.ConfigHash, &r.UpTimeScalar, &r.JoinTimeScalar, &r.IsSmsManaged, &r.SyncStatus, &r.CfgCtrl, &r.Health, &r.HealthPercentage, &r.Reason, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwClusterMemberStatus provide iterator to all rows of the NGFW_CLUSTER_MEMBER_STATUS matching given criteria.
func RangeNgfwClusterMemberStatus(db *sql.DB, where string) iter.Seq2[*NgfwClusterMemberStatusRow, error] {
	return func(yield func(v *NgfwClusterMemberStatusRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,STATE,IS_MASTER,MEMBER_ID,MEMBER_NAME,SERIAL_NUMBER,HW_MODEL,SW_VERSION,CONFIG_HASH,UP_TIME_SCALAR,JOIN_TIME_SCALAR,IS_SMS_MANAGED,SYNC_STATUS,CFG_CTRL,HEALTH,HEALTH_PERCENTAGE,REASON,UPDATE_TIME FROM NGFW_CLUSTER_MEMBER_STATUS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwClusterMemberStatusRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.State, &r.IsMaster, &r.MemberID, &r.MemberName, &r.SerialNumber, &r.HwModel, &r.SwVersion, &r.ConfigHash, &r.UpTimeScalar, &r.JoinTimeScalar, &r.IsSmsManaged, &r.SyncStatus, &r.CfgCtrl, &r.Health, &r.HealthPercentage, &r.Reason, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwDhcp6SlaRow struct represents rows of the NGFW_DHCP6_SLA table.
type NgfwDhcp6SlaRow struct {
    ID	uint
    Version	uint
    IfaceDhcp6ID	uint
    SlaIfaceID	uint
    SlaID	sql.NullInt32
}

// IterateNgfwDhcp6Sla provide access to all rows of the NGFW_DHCP6_SLA matching given criteria.
func IterateNgfwDhcp6Sla(db *sql.DB, where string, callback func(v *NgfwDhcp6SlaRow) error) error {
    query := "SELECT ID,VERSION,IFACE_DHCP6_ID,SLA_IFACE_ID,SLA_ID FROM NGFW_DHCP6_SLA"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwDhcp6SlaRow
        err := rows.Scan(&r.ID, &r.Version, &r.IfaceDhcp6ID, &r.SlaIfaceID, &r.SlaID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwDhcp6Sla provide iterator to all rows of the NGFW_DHCP6_SLA matching given criteria.
func RangeNgfwDhcp6Sla(db *sql.DB, where string) iter.Seq2[*NgfwDhcp6SlaRow, error] {
	return func(yield func(v *NgfwDhcp6SlaRow, err error) bool) {
	    query := "SELECT ID,VERSION,IFACE_DHCP6_ID,SLA_IFACE_ID,SLA_ID FROM NGFW_DHCP6_SLA"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwDhcp6SlaRow
	        err := rows.Scan(&r.ID, &r.Version, &r.IfaceDhcp6ID, &r.SlaIfaceID, &r.SlaID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwDhcpAddressRangeArrayRow struct represents rows of the NGFW_DHCP_ADDRESS_RANGE_ARRAY table.
type NgfwDhcpAddressRangeArrayRow struct {
    ID	uint
    AddrRangeNamedObjID	int
    NgfwDhcpServerArrayID	sql.NullInt32
}

// IterateNgfwDhcpAddressRangeArray provide access to all rows of the NGFW_DHCP_ADDRESS_RANGE_ARRAY matching given criteria.
func IterateNgfwDhcpAddressRangeArray(db *sql.DB, where string, callback func(v *NgfwDhcpAddressRangeArrayRow) error) error {
    query := "SELECT ID,ADDR_RANGE_NAMED_OBJ_ID,NGFW_DHCP_SERVER_ARRAY_ID FROM NGFW_DHCP_ADDRESS_RANGE_ARRAY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwDhcpAddressRangeArrayRow
        err := rows.Scan(&r.ID, &r.AddrRangeNamedObjID, &r.NgfwDhcpServerArrayID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwDhcpAddressRangeArray provide iterator to all rows of the NGFW_DHCP_ADDRESS_RANGE_ARRAY matching given criteria.
func RangeNgfwDhcpAddressRangeArray(db *sql.DB, where string) iter.Seq2[*NgfwDhcpAddressRangeArrayRow, error] {
	return func(yield func(v *NgfwDhcpAddressRangeArrayRow, err error) bool) {
	    query := "SELECT ID,ADDR_RANGE_NAMED_OBJ_ID,NGFW_DHCP_SERVER_ARRAY_ID FROM NGFW_DHCP_ADDRESS_RANGE_ARRAY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwDhcpAddressRangeArrayRow
	        err := rows.Scan(&r.ID, &r.AddrRangeNamedObjID, &r.NgfwDhcpServerArrayID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwDhcpHostArrayRow struct represents rows of the NGFW_DHCP_HOST_ARRAY table.
type NgfwDhcpHostArrayRow struct {
    ID	uint
    Address	sql.NullString
    HostName	string
    MacAddr	uint64
    NgfwDhcpServerArrayID	sql.NullInt32
}

// IterateNgfwDhcpHostArray provide access to all rows of the NGFW_DHCP_HOST_ARRAY matching given criteria.
func IterateNgfwDhcpHostArray(db *sql.DB, where string, callback func(v *NgfwDhcpHostArrayRow) error) error {
    query := "SELECT ID,ADDRESS,HOST_NAME,MAC_ADDR,NGFW_DHCP_SERVER_ARRAY_ID FROM NGFW_DHCP_HOST_ARRAY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwDhcpHostArrayRow
        err := rows.Scan(&r.ID, &r.Address, &r.HostName, &r.MacAddr, &r.NgfwDhcpServerArrayID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwDhcpHostArray provide iterator to all rows of the NGFW_DHCP_HOST_ARRAY matching given criteria.
func RangeNgfwDhcpHostArray(db *sql.DB, where string) iter.Seq2[*NgfwDhcpHostArrayRow, error] {
	return func(yield func(v *NgfwDhcpHostArrayRow, err error) bool) {
	    query := "SELECT ID,ADDRESS,HOST_NAME,MAC_ADDR,NGFW_DHCP_SERVER_ARRAY_ID FROM NGFW_DHCP_HOST_ARRAY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwDhcpHostArrayRow
	        err := rows.Scan(&r.ID, &r.Address, &r.HostName, &r.MacAddr, &r.NgfwDhcpServerArrayID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwDhcpOptionsEntryRow struct represents rows of the NGFW_DHCP_OPTIONS_ENTRY table.
type NgfwDhcpOptionsEntryRow struct {
    ID	uint
    OptionName	sql.NullString
    OptionNumber	sql.NullInt32
    OptType	sql.NullString
    OptionValue1	sql.NullString
    OptionValue2	sql.NullString
    OptionValue3	sql.NullString
    NgfwDhcpServerArrayID	sql.NullInt32
}

// IterateNgfwDhcpOptionsEntry provide access to all rows of the NGFW_DHCP_OPTIONS_ENTRY matching given criteria.
func IterateNgfwDhcpOptionsEntry(db *sql.DB, where string, callback func(v *NgfwDhcpOptionsEntryRow) error) error {
    query := "SELECT ID,OPTION_NAME,OPTION_NUMBER,OPT_TYPE,OPTION_VALUE1,OPTION_VALUE2,OPTION_VALUE3,NGFW_DHCP_SERVER_ARRAY_ID FROM NGFW_DHCP_OPTIONS_ENTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwDhcpOptionsEntryRow
        err := rows.Scan(&r.ID, &r.OptionName, &r.OptionNumber, &r.OptType, &r.OptionValue1, &r.OptionValue2, &r.OptionValue3, &r.NgfwDhcpServerArrayID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwDhcpOptionsEntry provide iterator to all rows of the NGFW_DHCP_OPTIONS_ENTRY matching given criteria.
func RangeNgfwDhcpOptionsEntry(db *sql.DB, where string) iter.Seq2[*NgfwDhcpOptionsEntryRow, error] {
	return func(yield func(v *NgfwDhcpOptionsEntryRow, err error) bool) {
	    query := "SELECT ID,OPTION_NAME,OPTION_NUMBER,OPT_TYPE,OPTION_VALUE1,OPTION_VALUE2,OPTION_VALUE3,NGFW_DHCP_SERVER_ARRAY_ID FROM NGFW_DHCP_OPTIONS_ENTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwDhcpOptionsEntryRow
	        err := rows.Scan(&r.ID, &r.OptionName, &r.OptionNumber, &r.OptType, &r.OptionValue1, &r.OptionValue2, &r.OptionValue3, &r.NgfwDhcpServerArrayID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwDhcpOptionsNamedValueRow struct represents rows of the NGFW_DHCP_OPTIONS_NAMED_VALUE table.
type NgfwDhcpOptionsNamedValueRow struct {
    ID	uint
    NamedValue	sql.NullString
    NgfwDhcpOptionsEntryID	sql.NullInt32
}

// IterateNgfwDhcpOptionsNamedValue provide access to all rows of the NGFW_DHCP_OPTIONS_NAMED_VALUE matching given criteria.
func IterateNgfwDhcpOptionsNamedValue(db *sql.DB, where string, callback func(v *NgfwDhcpOptionsNamedValueRow) error) error {
    query := "SELECT ID,NAMED_VALUE,NGFW_DHCP_OPTIONS_ENTRY_ID FROM NGFW_DHCP_OPTIONS_NAMED_VALUE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwDhcpOptionsNamedValueRow
        err := rows.Scan(&r.ID, &r.NamedValue, &r.NgfwDhcpOptionsEntryID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwDhcpOptionsNamedValue provide iterator to all rows of the NGFW_DHCP_OPTIONS_NAMED_VALUE matching given criteria.
func RangeNgfwDhcpOptionsNamedValue(db *sql.DB, where string) iter.Seq2[*NgfwDhcpOptionsNamedValueRow, error] {
	return func(yield func(v *NgfwDhcpOptionsNamedValueRow, err error) bool) {
	    query := "SELECT ID,NAMED_VALUE,NGFW_DHCP_OPTIONS_ENTRY_ID FROM NGFW_DHCP_OPTIONS_NAMED_VALUE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwDhcpOptionsNamedValueRow
	        err := rows.Scan(&r.ID, &r.NamedValue, &r.NgfwDhcpOptionsEntryID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwDhcpRelayRow struct represents rows of the NGFW_DHCP_RELAY table.
type NgfwDhcpRelayRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Enable	int8
    ServerAddr1NamedObjID	sql.NullInt32
    ServerAddr2NamedObjID	sql.NullInt32
    ServerAddr3NamedObjID	sql.NullInt32
    ServerAddr4NamedObjID	sql.NullInt32
    ClientInterfaceOnAll	int8
}

// IterateNgfwDhcpRelay provide access to all rows of the NGFW_DHCP_RELAY matching given criteria.
func IterateNgfwDhcpRelay(db *sql.DB, where string, callback func(v *NgfwDhcpRelayRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLE,SERVER_ADDR1_NAMED_OBJ_ID,SERVER_ADDR2_NAMED_OBJ_ID,SERVER_ADDR3_NAMED_OBJ_ID,SERVER_ADDR4_NAMED_OBJ_ID,CLIENT_INTERFACE_ON_ALL FROM NGFW_DHCP_RELAY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwDhcpRelayRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enable, &r.ServerAddr1NamedObjID, &r.ServerAddr2NamedObjID, &r.ServerAddr3NamedObjID, &r.ServerAddr4NamedObjID, &r.ClientInterfaceOnAll)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwDhcpRelay provide iterator to all rows of the NGFW_DHCP_RELAY matching given criteria.
func RangeNgfwDhcpRelay(db *sql.DB, where string) iter.Seq2[*NgfwDhcpRelayRow, error] {
	return func(yield func(v *NgfwDhcpRelayRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLE,SERVER_ADDR1_NAMED_OBJ_ID,SERVER_ADDR2_NAMED_OBJ_ID,SERVER_ADDR3_NAMED_OBJ_ID,SERVER_ADDR4_NAMED_OBJ_ID,CLIENT_INTERFACE_ON_ALL FROM NGFW_DHCP_RELAY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwDhcpRelayRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enable, &r.ServerAddr1NamedObjID, &r.ServerAddr2NamedObjID, &r.ServerAddr3NamedObjID, &r.ServerAddr4NamedObjID, &r.ClientInterfaceOnAll)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwDhcpReplayClientMappingRow struct represents rows of the NGFW_DHCP_REPLAY_CLIENT_MAPPING table.
type NgfwDhcpReplayClientMappingRow struct {
    DhcpReplayID	uint
    InterfaceID	uint
}

// IterateNgfwDhcpReplayClientMapping provide access to all rows of the NGFW_DHCP_REPLAY_CLIENT_MAPPING matching given criteria.
func IterateNgfwDhcpReplayClientMapping(db *sql.DB, where string, callback func(v *NgfwDhcpReplayClientMappingRow) error) error {
    query := "SELECT DHCP_REPLAY_ID,INTERFACE_ID FROM NGFW_DHCP_REPLAY_CLIENT_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwDhcpReplayClientMappingRow
        err := rows.Scan(&r.DhcpReplayID, &r.InterfaceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwDhcpReplayClientMapping provide iterator to all rows of the NGFW_DHCP_REPLAY_CLIENT_MAPPING matching given criteria.
func RangeNgfwDhcpReplayClientMapping(db *sql.DB, where string) iter.Seq2[*NgfwDhcpReplayClientMappingRow, error] {
	return func(yield func(v *NgfwDhcpReplayClientMappingRow, err error) bool) {
	    query := "SELECT DHCP_REPLAY_ID,INTERFACE_ID FROM NGFW_DHCP_REPLAY_CLIENT_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwDhcpReplayClientMappingRow
	        err := rows.Scan(&r.DhcpReplayID, &r.InterfaceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwDhcpReplayServerMappingRow struct represents rows of the NGFW_DHCP_REPLAY_SERVER_MAPPING table.
type NgfwDhcpReplayServerMappingRow struct {
    DhcpReplayID	uint
    InterfaceID	uint
}

// IterateNgfwDhcpReplayServerMapping provide access to all rows of the NGFW_DHCP_REPLAY_SERVER_MAPPING matching given criteria.
func IterateNgfwDhcpReplayServerMapping(db *sql.DB, where string, callback func(v *NgfwDhcpReplayServerMappingRow) error) error {
    query := "SELECT DHCP_REPLAY_ID,INTERFACE_ID FROM NGFW_DHCP_REPLAY_SERVER_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwDhcpReplayServerMappingRow
        err := rows.Scan(&r.DhcpReplayID, &r.InterfaceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwDhcpReplayServerMapping provide iterator to all rows of the NGFW_DHCP_REPLAY_SERVER_MAPPING matching given criteria.
func RangeNgfwDhcpReplayServerMapping(db *sql.DB, where string) iter.Seq2[*NgfwDhcpReplayServerMappingRow, error] {
	return func(yield func(v *NgfwDhcpReplayServerMappingRow, err error) bool) {
	    query := "SELECT DHCP_REPLAY_ID,INTERFACE_ID FROM NGFW_DHCP_REPLAY_SERVER_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwDhcpReplayServerMappingRow
	        err := rows.Scan(&r.DhcpReplayID, &r.InterfaceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwDhcpServerArrayRow struct represents rows of the NGFW_DHCP_SERVER_ARRAY table.
type NgfwDhcpServerArrayRow struct {
    ID	uint
    ScopeName	string
    SubnetNamedIPObjID	sql.NullInt32
    DnsServer1NamedObjID	sql.NullInt32
    DnsServer2NamedObjID	sql.NullInt32
    DnsServer3NamedObjID	sql.NullInt32
    Lease	sql.NullInt64
    DomainName	sql.NullString
    GatewayType	string
    GatewayAddrNamedObjID	sql.NullInt32
    NgfwDhcpServerV4ID	sql.NullInt32
}

// IterateNgfwDhcpServerArray provide access to all rows of the NGFW_DHCP_SERVER_ARRAY matching given criteria.
func IterateNgfwDhcpServerArray(db *sql.DB, where string, callback func(v *NgfwDhcpServerArrayRow) error) error {
    query := "SELECT ID,SCOPE_NAME,SUBNET_NAMED_IP_OBJ_ID,DNS_SERVER1_NAMED_OBJ_ID,DNS_SERVER2_NAMED_OBJ_ID,DNS_SERVER3_NAMED_OBJ_ID,LEASE,DOMAIN_NAME,GATEWAY_TYPE,GATEWAY_ADDR_NAMED_OBJ_ID,NGFW_DHCP_SERVER_V4_ID FROM NGFW_DHCP_SERVER_ARRAY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwDhcpServerArrayRow
        err := rows.Scan(&r.ID, &r.ScopeName, &r.SubnetNamedIPObjID, &r.DnsServer1NamedObjID, &r.DnsServer2NamedObjID, &r.DnsServer3NamedObjID, &r.Lease, &r.DomainName, &r.GatewayType, &r.GatewayAddrNamedObjID, &r.NgfwDhcpServerV4ID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwDhcpServerArray provide iterator to all rows of the NGFW_DHCP_SERVER_ARRAY matching given criteria.
func RangeNgfwDhcpServerArray(db *sql.DB, where string) iter.Seq2[*NgfwDhcpServerArrayRow, error] {
	return func(yield func(v *NgfwDhcpServerArrayRow, err error) bool) {
	    query := "SELECT ID,SCOPE_NAME,SUBNET_NAMED_IP_OBJ_ID,DNS_SERVER1_NAMED_OBJ_ID,DNS_SERVER2_NAMED_OBJ_ID,DNS_SERVER3_NAMED_OBJ_ID,LEASE,DOMAIN_NAME,GATEWAY_TYPE,GATEWAY_ADDR_NAMED_OBJ_ID,NGFW_DHCP_SERVER_V4_ID FROM NGFW_DHCP_SERVER_ARRAY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwDhcpServerArrayRow
	        err := rows.Scan(&r.ID, &r.ScopeName, &r.SubnetNamedIPObjID, &r.DnsServer1NamedObjID, &r.DnsServer2NamedObjID, &r.DnsServer3NamedObjID, &r.Lease, &r.DomainName, &r.GatewayType, &r.GatewayAddrNamedObjID, &r.NgfwDhcpServerV4ID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwDhcpServerV4Row struct represents rows of the NGFW_DHCP_SERVER_V4 table.
type NgfwDhcpServerV4Row struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Enable	sql.NullByte
}

// IterateNgfwDhcpServerV4 provide access to all rows of the NGFW_DHCP_SERVER_V4 matching given criteria.
func IterateNgfwDhcpServerV4(db *sql.DB, where string, callback func(v *NgfwDhcpServerV4Row) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLE FROM NGFW_DHCP_SERVER_V4"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwDhcpServerV4Row
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enable)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwDhcpServerV4 provide iterator to all rows of the NGFW_DHCP_SERVER_V4 matching given criteria.
func RangeNgfwDhcpServerV4(db *sql.DB, where string) iter.Seq2[*NgfwDhcpServerV4Row, error] {
	return func(yield func(v *NgfwDhcpServerV4Row, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLE FROM NGFW_DHCP_SERVER_V4"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwDhcpServerV4Row
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enable)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwDnsHostRow struct represents rows of the NGFW_DNS_HOST table.
type NgfwDnsHostRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    NameServer1AddrNamedObjID	sql.NullInt32
    NameServer2AddrNamedObjID	sql.NullInt32
    NameServer3AddrNamedObjID	sql.NullInt32
    NameServer4AddrNamedObjID	sql.NullInt32
    DomainName	sql.NullString
    SearchName1	sql.NullString
    SearchName2	sql.NullString
    SearchName3	sql.NullString
}

// IterateNgfwDnsHost provide access to all rows of the NGFW_DNS_HOST matching given criteria.
func IterateNgfwDnsHost(db *sql.DB, where string, callback func(v *NgfwDnsHostRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME_SERVER1_ADDR_NAMED_OBJ_ID,NAME_SERVER2_ADDR_NAMED_OBJ_ID,NAME_SERVER3_ADDR_NAMED_OBJ_ID,NAME_SERVER4_ADDR_NAMED_OBJ_ID,DOMAIN_NAME,SEARCH_NAME1,SEARCH_NAME2,SEARCH_NAME3 FROM NGFW_DNS_HOST"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwDnsHostRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.NameServer1AddrNamedObjID, &r.NameServer2AddrNamedObjID, &r.NameServer3AddrNamedObjID, &r.NameServer4AddrNamedObjID, &r.DomainName, &r.SearchName1, &r.SearchName2, &r.SearchName3)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwDnsHost provide iterator to all rows of the NGFW_DNS_HOST matching given criteria.
func RangeNgfwDnsHost(db *sql.DB, where string) iter.Seq2[*NgfwDnsHostRow, error] {
	return func(yield func(v *NgfwDnsHostRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME_SERVER1_ADDR_NAMED_OBJ_ID,NAME_SERVER2_ADDR_NAMED_OBJ_ID,NAME_SERVER3_ADDR_NAMED_OBJ_ID,NAME_SERVER4_ADDR_NAMED_OBJ_ID,DOMAIN_NAME,SEARCH_NAME1,SEARCH_NAME2,SEARCH_NAME3 FROM NGFW_DNS_HOST"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwDnsHostRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.NameServer1AddrNamedObjID, &r.NameServer2AddrNamedObjID, &r.NameServer3AddrNamedObjID, &r.NameServer4AddrNamedObjID, &r.DomainName, &r.SearchName1, &r.SearchName2, &r.SearchName3)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwDnsProxyCacheRow struct represents rows of the NGFW_DNS_PROXY_CACHE table.
type NgfwDnsProxyCacheRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Forwarder1IpaddrNamedObjID	sql.NullInt32
    Forwarder2IpaddrNamedObjID	sql.NullInt32
    Forwarder3IpaddrNamedObjID	sql.NullInt32
    Forwarder4IpaddrNamedObjID	sql.NullInt32
    Enable	int8
    MaxCacheSize	sql.NullInt32
    CleaningInterval	sql.NullInt32
    MaxTtl	sql.NullInt64
    MaxNegTtl	sql.NullInt64
}

// IterateNgfwDnsProxyCache provide access to all rows of the NGFW_DNS_PROXY_CACHE matching given criteria.
func IterateNgfwDnsProxyCache(db *sql.DB, where string, callback func(v *NgfwDnsProxyCacheRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,FORWARDER1_IPADDR_NAMED_OBJ_ID,FORWARDER2_IPADDR_NAMED_OBJ_ID,FORWARDER3_IPADDR_NAMED_OBJ_ID,FORWARDER4_IPADDR_NAMED_OBJ_ID,ENABLE,MAX_CACHE_SIZE,CLEANING_INTERVAL,MAX_TTL,MAX_NEG_TTL FROM NGFW_DNS_PROXY_CACHE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwDnsProxyCacheRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Forwarder1IpaddrNamedObjID, &r.Forwarder2IpaddrNamedObjID, &r.Forwarder3IpaddrNamedObjID, &r.Forwarder4IpaddrNamedObjID, &r.Enable, &r.MaxCacheSize, &r.CleaningInterval, &r.MaxTtl, &r.MaxNegTtl)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwDnsProxyCache provide iterator to all rows of the NGFW_DNS_PROXY_CACHE matching given criteria.
func RangeNgfwDnsProxyCache(db *sql.DB, where string) iter.Seq2[*NgfwDnsProxyCacheRow, error] {
	return func(yield func(v *NgfwDnsProxyCacheRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,FORWARDER1_IPADDR_NAMED_OBJ_ID,FORWARDER2_IPADDR_NAMED_OBJ_ID,FORWARDER3_IPADDR_NAMED_OBJ_ID,FORWARDER4_IPADDR_NAMED_OBJ_ID,ENABLE,MAX_CACHE_SIZE,CLEANING_INTERVAL,MAX_TTL,MAX_NEG_TTL FROM NGFW_DNS_PROXY_CACHE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwDnsProxyCacheRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Forwarder1IpaddrNamedObjID, &r.Forwarder2IpaddrNamedObjID, &r.Forwarder3IpaddrNamedObjID, &r.Forwarder4IpaddrNamedObjID, &r.Enable, &r.MaxCacheSize, &r.CleaningInterval, &r.MaxTtl, &r.MaxNegTtl)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwFwMaxSeqRow struct represents rows of the NGFW_FW_MAX_SEQ table.
type NgfwFwMaxSeqRow struct {
    Idx	uint64
    DeviceShortID	uint
    FwBlock	uint64
    FwAlert	uint64
    FwVisibility	uint64
    FwVpn	uint64
}

// IterateNgfwFwMaxSeq provide access to all rows of the NGFW_FW_MAX_SEQ matching given criteria.
func IterateNgfwFwMaxSeq(db *sql.DB, where string, callback func(v *NgfwFwMaxSeqRow) error) error {
    query := "SELECT IDX,DEVICE_SHORT_ID,FW_BLOCK,FW_ALERT,FW_VISIBILITY,FW_VPN FROM NGFW_FW_MAX_SEQ"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwFwMaxSeqRow
        err := rows.Scan(&r.Idx, &r.DeviceShortID, &r.FwBlock, &r.FwAlert, &r.FwVisibility, &r.FwVpn)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwFwMaxSeq provide iterator to all rows of the NGFW_FW_MAX_SEQ matching given criteria.
func RangeNgfwFwMaxSeq(db *sql.DB, where string) iter.Seq2[*NgfwFwMaxSeqRow, error] {
	return func(yield func(v *NgfwFwMaxSeqRow, err error) bool) {
	    query := "SELECT IDX,DEVICE_SHORT_ID,FW_BLOCK,FW_ALERT,FW_VISIBILITY,FW_VPN FROM NGFW_FW_MAX_SEQ"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwFwMaxSeqRow
	        err := rows.Scan(&r.Idx, &r.DeviceShortID, &r.FwBlock, &r.FwAlert, &r.FwVisibility, &r.FwVpn)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwGlobalAppVisibilityRow struct represents rows of the NGFW_GLOBAL_APP_VISIBILITY table.
type NgfwGlobalAppVisibilityRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    GlobalVisibilityStatus	sql.NullByte
}

// IterateNgfwGlobalAppVisibility provide access to all rows of the NGFW_GLOBAL_APP_VISIBILITY matching given criteria.
func IterateNgfwGlobalAppVisibility(db *sql.DB, where string, callback func(v *NgfwGlobalAppVisibilityRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,GLOBAL_VISIBILITY_STATUS FROM NGFW_GLOBAL_APP_VISIBILITY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwGlobalAppVisibilityRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.GlobalVisibilityStatus)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwGlobalAppVisibility provide iterator to all rows of the NGFW_GLOBAL_APP_VISIBILITY matching given criteria.
func RangeNgfwGlobalAppVisibility(db *sql.DB, where string) iter.Seq2[*NgfwGlobalAppVisibilityRow, error] {
	return func(yield func(v *NgfwGlobalAppVisibilityRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,GLOBAL_VISIBILITY_STATUS FROM NGFW_GLOBAL_APP_VISIBILITY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwGlobalAppVisibilityRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.GlobalVisibilityStatus)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwHaClusterDetailsRow struct represents rows of the NGFW_HA_CLUSTER_DETAILS table.
type NgfwHaClusterDetailsRow struct {
    ID	uint
    Version	uint
    ClusterID	string
    DeviceGrpNodeID	uint
    DeviceShortId1	sql.NullInt32
    DeviceShortId2	sql.NullInt32
    SoftwareCheckEnforced	int8
    ConfigCheckEnforced	int8
    ManualSyncByUser	int8
    SwUpdateCountDevice1	uint
    ConfigUpdateCountDevice1	uint
    SwUpdateCountDevice2	uint
    ConfigUpdateCountDevice2	uint
}

// IterateNgfwHaClusterDetails provide access to all rows of the NGFW_HA_CLUSTER_DETAILS matching given criteria.
func IterateNgfwHaClusterDetails(db *sql.DB, where string, callback func(v *NgfwHaClusterDetailsRow) error) error {
    query := "SELECT ID,VERSION,CLUSTER_ID,DEVICE_GRP_NODE_ID,DEVICE_SHORT_ID1,DEVICE_SHORT_ID2,SOFTWARE_CHECK_ENFORCED,CONFIG_CHECK_ENFORCED,MANUAL_SYNC_BY_USER,SW_UPDATE_COUNT_DEVICE1,CONFIG_UPDATE_COUNT_DEVICE1,SW_UPDATE_COUNT_DEVICE2,CONFIG_UPDATE_COUNT_DEVICE2 FROM NGFW_HA_CLUSTER_DETAILS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwHaClusterDetailsRow
        err := rows.Scan(&r.ID, &r.Version, &r.ClusterID, &r.DeviceGrpNodeID, &r.DeviceShortId1, &r.DeviceShortId2, &r.SoftwareCheckEnforced, &r.ConfigCheckEnforced, &r.ManualSyncByUser, &r.SwUpdateCountDevice1, &r.ConfigUpdateCountDevice1, &r.SwUpdateCountDevice2, &r.ConfigUpdateCountDevice2)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwHaClusterDetails provide iterator to all rows of the NGFW_HA_CLUSTER_DETAILS matching given criteria.
func RangeNgfwHaClusterDetails(db *sql.DB, where string) iter.Seq2[*NgfwHaClusterDetailsRow, error] {
	return func(yield func(v *NgfwHaClusterDetailsRow, err error) bool) {
	    query := "SELECT ID,VERSION,CLUSTER_ID,DEVICE_GRP_NODE_ID,DEVICE_SHORT_ID1,DEVICE_SHORT_ID2,SOFTWARE_CHECK_ENFORCED,CONFIG_CHECK_ENFORCED,MANUAL_SYNC_BY_USER,SW_UPDATE_COUNT_DEVICE1,CONFIG_UPDATE_COUNT_DEVICE1,SW_UPDATE_COUNT_DEVICE2,CONFIG_UPDATE_COUNT_DEVICE2 FROM NGFW_HA_CLUSTER_DETAILS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwHaClusterDetailsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.ClusterID, &r.DeviceGrpNodeID, &r.DeviceShortId1, &r.DeviceShortId2, &r.SoftwareCheckEnforced, &r.ConfigCheckEnforced, &r.ManualSyncByUser, &r.SwUpdateCountDevice1, &r.ConfigUpdateCountDevice1, &r.SwUpdateCountDevice2, &r.ConfigUpdateCountDevice2)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwHaClusterSettingsRow struct represents rows of the NGFW_HA_CLUSTER_SETTINGS table.
type NgfwHaClusterSettingsRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Enabled	sql.NullByte
    OnStandby	sql.NullByte
    ClusterID	sql.NullString
    MemberID	sql.NullString
    MemberName	sql.NullString
    FailoverGroupID	sql.NullString
    SerialNumber	sql.NullString
    SoftwareCheckEnabled	sql.NullByte
    HardwareCheckEnabled	sql.NullByte
    ConfigCheckEnabled	sql.NullByte
    ClusterTrafficID	sql.NullInt32
}

// IterateNgfwHaClusterSettings provide access to all rows of the NGFW_HA_CLUSTER_SETTINGS matching given criteria.
func IterateNgfwHaClusterSettings(db *sql.DB, where string, callback func(v *NgfwHaClusterSettingsRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLED,ON_STANDBY,CLUSTER_ID,MEMBER_ID,MEMBER_NAME,FAILOVER_GROUP_ID,SERIAL_NUMBER,SOFTWARE_CHECK_ENABLED,HARDWARE_CHECK_ENABLED,CONFIG_CHECK_ENABLED,CLUSTER_TRAFFIC_ID FROM NGFW_HA_CLUSTER_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwHaClusterSettingsRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enabled, &r.OnStandby, &r.ClusterID, &r.MemberID, &r.MemberName, &r.FailoverGroupID, &r.SerialNumber, &r.SoftwareCheckEnabled, &r.HardwareCheckEnabled, &r.ConfigCheckEnabled, &r.ClusterTrafficID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwHaClusterSettings provide iterator to all rows of the NGFW_HA_CLUSTER_SETTINGS matching given criteria.
func RangeNgfwHaClusterSettings(db *sql.DB, where string) iter.Seq2[*NgfwHaClusterSettingsRow, error] {
	return func(yield func(v *NgfwHaClusterSettingsRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLED,ON_STANDBY,CLUSTER_ID,MEMBER_ID,MEMBER_NAME,FAILOVER_GROUP_ID,SERIAL_NUMBER,SOFTWARE_CHECK_ENABLED,HARDWARE_CHECK_ENABLED,CONFIG_CHECK_ENABLED,CLUSTER_TRAFFIC_ID FROM NGFW_HA_CLUSTER_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwHaClusterSettingsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enabled, &r.OnStandby, &r.ClusterID, &r.MemberID, &r.MemberName, &r.FailoverGroupID, &r.SerialNumber, &r.SoftwareCheckEnabled, &r.HardwareCheckEnabled, &r.ConfigCheckEnabled, &r.ClusterTrafficID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwHaClusterTrafficRow struct represents rows of the NGFW_HA_CLUSTER_TRAFFIC table.
type NgfwHaClusterTrafficRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    EncryptionEnabled	sql.NullByte
    Hash	sql.NullString
    Cipher	sql.NullString
    Passphrase	sql.NullString
    SubnetIpaddr	sql.NullString
    Maskbits	sql.NullInt32
    Multicast	sql.NullString
    LinkSpeed	sql.NullInt32
    FullDuplex	sql.NullByte
    AutoNegEnabled	sql.NullByte
    Port	sql.NullInt32
    Ttl	sql.NullInt32
    Mtu	sql.NullInt32
    Timeout	sql.NullInt32
    Retry	sql.NullInt32
    MgmtPortFailoverEnabled	sql.NullByte
}

// IterateNgfwHaClusterTraffic provide access to all rows of the NGFW_HA_CLUSTER_TRAFFIC matching given criteria.
func IterateNgfwHaClusterTraffic(db *sql.DB, where string, callback func(v *NgfwHaClusterTrafficRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENCRYPTION_ENABLED,HASH,CIPHER,PASSPHRASE,SUBNET_IPADDR,MASKBITS,MULTICAST,LINK_SPEED,FULL_DUPLEX,AUTO_NEG_ENABLED,PORT,TTL,MTU,TIMEOUT,RETRY,MGMT_PORT_FAILOVER_ENABLED FROM NGFW_HA_CLUSTER_TRAFFIC"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwHaClusterTrafficRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.EncryptionEnabled, &r.Hash, &r.Cipher, &r.Passphrase, &r.SubnetIpaddr, &r.Maskbits, &r.Multicast, &r.LinkSpeed, &r.FullDuplex, &r.AutoNegEnabled, &r.Port, &r.Ttl, &r.Mtu, &r.Timeout, &r.Retry, &r.MgmtPortFailoverEnabled)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwHaClusterTraffic provide iterator to all rows of the NGFW_HA_CLUSTER_TRAFFIC matching given criteria.
func RangeNgfwHaClusterTraffic(db *sql.DB, where string) iter.Seq2[*NgfwHaClusterTrafficRow, error] {
	return func(yield func(v *NgfwHaClusterTrafficRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENCRYPTION_ENABLED,HASH,CIPHER,PASSPHRASE,SUBNET_IPADDR,MASKBITS,MULTICAST,LINK_SPEED,FULL_DUPLEX,AUTO_NEG_ENABLED,PORT,TTL,MTU,TIMEOUT,RETRY,MGMT_PORT_FAILOVER_ENABLED FROM NGFW_HA_CLUSTER_TRAFFIC"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwHaClusterTrafficRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.EncryptionEnabled, &r.Hash, &r.Cipher, &r.Passphrase, &r.SubnetIpaddr, &r.Maskbits, &r.Multicast, &r.LinkSpeed, &r.FullDuplex, &r.AutoNegEnabled, &r.Port, &r.Ttl, &r.Mtu, &r.Timeout, &r.Retry, &r.MgmtPortFailoverEnabled)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwHaFailoverGroupRow struct represents rows of the NGFW_HA_FAILOVER_GROUP table.
type NgfwHaFailoverGroupRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    FailoverGroupID	string
    FailoverGroupName	sql.NullString
    Mode	string
    MacAddress	sql.NullInt64
    ClusterSettingsID	sql.NullInt32
}

// IterateNgfwHaFailoverGroup provide access to all rows of the NGFW_HA_FAILOVER_GROUP matching given criteria.
func IterateNgfwHaFailoverGroup(db *sql.DB, where string, callback func(v *NgfwHaFailoverGroupRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,FAILOVER_GROUP_ID,FAILOVER_GROUP_NAME,MODE,MAC_ADDRESS,CLUSTER_SETTINGS_ID FROM NGFW_HA_FAILOVER_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwHaFailoverGroupRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.FailoverGroupID, &r.FailoverGroupName, &r.Mode, &r.MacAddress, &r.ClusterSettingsID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwHaFailoverGroup provide iterator to all rows of the NGFW_HA_FAILOVER_GROUP matching given criteria.
func RangeNgfwHaFailoverGroup(db *sql.DB, where string) iter.Seq2[*NgfwHaFailoverGroupRow, error] {
	return func(yield func(v *NgfwHaFailoverGroupRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,FAILOVER_GROUP_ID,FAILOVER_GROUP_NAME,MODE,MAC_ADDRESS,CLUSTER_SETTINGS_ID FROM NGFW_HA_FAILOVER_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwHaFailoverGroupRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.FailoverGroupID, &r.FailoverGroupName, &r.Mode, &r.MacAddress, &r.ClusterSettingsID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwHaSettingsRow struct represents rows of the NGFW_HA_SETTINGS table.
type NgfwHaSettingsRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Enabled	int8
    FailoverGroupID	sql.NullInt32
}

// IterateNgfwHaSettings provide access to all rows of the NGFW_HA_SETTINGS matching given criteria.
func IterateNgfwHaSettings(db *sql.DB, where string, callback func(v *NgfwHaSettingsRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLED,FAILOVER_GROUP_ID FROM NGFW_HA_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwHaSettingsRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enabled, &r.FailoverGroupID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwHaSettings provide iterator to all rows of the NGFW_HA_SETTINGS matching given criteria.
func RangeNgfwHaSettings(db *sql.DB, where string) iter.Seq2[*NgfwHaSettingsRow, error] {
	return func(yield func(v *NgfwHaSettingsRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLED,FAILOVER_GROUP_ID FROM NGFW_HA_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwHaSettingsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enabled, &r.FailoverGroupID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwHaStateSyncFeatureRow struct represents rows of the NGFW_HA_STATE_SYNC_FEATURE table.
type NgfwHaStateSyncFeatureRow struct {
    ID	uint
    Type	string
    Enabled	int8
    LogLevel	sql.NullString
    NgfwHaStateSyncSettingsID	uint
}

// IterateNgfwHaStateSyncFeature provide access to all rows of the NGFW_HA_STATE_SYNC_FEATURE matching given criteria.
func IterateNgfwHaStateSyncFeature(db *sql.DB, where string, callback func(v *NgfwHaStateSyncFeatureRow) error) error {
    query := "SELECT ID,TYPE,ENABLED,LOG_LEVEL,NGFW_HA_STATE_SYNC_SETTINGS_ID FROM NGFW_HA_STATE_SYNC_FEATURE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwHaStateSyncFeatureRow
        err := rows.Scan(&r.ID, &r.Type, &r.Enabled, &r.LogLevel, &r.NgfwHaStateSyncSettingsID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwHaStateSyncFeature provide iterator to all rows of the NGFW_HA_STATE_SYNC_FEATURE matching given criteria.
func RangeNgfwHaStateSyncFeature(db *sql.DB, where string) iter.Seq2[*NgfwHaStateSyncFeatureRow, error] {
	return func(yield func(v *NgfwHaStateSyncFeatureRow, err error) bool) {
	    query := "SELECT ID,TYPE,ENABLED,LOG_LEVEL,NGFW_HA_STATE_SYNC_SETTINGS_ID FROM NGFW_HA_STATE_SYNC_FEATURE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwHaStateSyncFeatureRow
	        err := rows.Scan(&r.ID, &r.Type, &r.Enabled, &r.LogLevel, &r.NgfwHaStateSyncSettingsID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwHaStateSyncSettingsRow struct represents rows of the NGFW_HA_STATE_SYNC_SETTINGS table.
type NgfwHaStateSyncSettingsRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    StateSyncEnabled	sql.NullByte
}

// IterateNgfwHaStateSyncSettings provide access to all rows of the NGFW_HA_STATE_SYNC_SETTINGS matching given criteria.
func IterateNgfwHaStateSyncSettings(db *sql.DB, where string, callback func(v *NgfwHaStateSyncSettingsRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,STATE_SYNC_ENABLED FROM NGFW_HA_STATE_SYNC_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwHaStateSyncSettingsRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.StateSyncEnabled)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwHaStateSyncSettings provide iterator to all rows of the NGFW_HA_STATE_SYNC_SETTINGS matching given criteria.
func RangeNgfwHaStateSyncSettings(db *sql.DB, where string) iter.Seq2[*NgfwHaStateSyncSettingsRow, error] {
	return func(yield func(v *NgfwHaStateSyncSettingsRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,STATE_SYNC_ENABLED FROM NGFW_HA_STATE_SYNC_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwHaStateSyncSettingsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.StateSyncEnabled)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwHaStateSyncTableRow struct represents rows of the NGFW_HA_STATE_SYNC_TABLE table.
type NgfwHaStateSyncTableRow struct {
    ID	uint
    DeviceShortID	uint
    SyncType	sql.NullString
    Enabled	sql.NullByte
    Status	sql.NullString
    Reason	sql.NullString
    TotalEntries	sql.NullInt32
    AddEntries	sql.NullInt32
    DelEntries	sql.NullInt32
    UpdateTime	string
}

// IterateNgfwHaStateSyncTable provide access to all rows of the NGFW_HA_STATE_SYNC_TABLE matching given criteria.
func IterateNgfwHaStateSyncTable(db *sql.DB, where string, callback func(v *NgfwHaStateSyncTableRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,SYNC_TYPE,ENABLED,STATUS,REASON,TOTAL_ENTRIES,ADD_ENTRIES,DEL_ENTRIES,UPDATE_TIME FROM NGFW_HA_STATE_SYNC_TABLE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwHaStateSyncTableRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.SyncType, &r.Enabled, &r.Status, &r.Reason, &r.TotalEntries, &r.AddEntries, &r.DelEntries, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwHaStateSyncTable provide iterator to all rows of the NGFW_HA_STATE_SYNC_TABLE matching given criteria.
func RangeNgfwHaStateSyncTable(db *sql.DB, where string) iter.Seq2[*NgfwHaStateSyncTableRow, error] {
	return func(yield func(v *NgfwHaStateSyncTableRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,SYNC_TYPE,ENABLED,STATUS,REASON,TOTAL_ENTRIES,ADD_ENTRIES,DEL_ENTRIES,UPDATE_TIME FROM NGFW_HA_STATE_SYNC_TABLE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwHaStateSyncTableRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.SyncType, &r.Enabled, &r.Status, &r.Reason, &r.TotalEntries, &r.AddEntries, &r.DelEntries, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwHwInfoRow struct represents rows of the NGFW_HW_INFO table.
type NgfwHwInfoRow struct {
    ID	uint
    DeviceShortID	uint
    Version	uint
    BaseMac	sql.NullInt64
    MacCount	sql.NullInt32
    BoardSerial	sql.NullString
    BoardMajorVer	sql.NullInt32
    BoardMinorVer	sql.NullInt32
    BoardRevision	sql.NullString
}

// IterateNgfwHwInfo provide access to all rows of the NGFW_HW_INFO matching given criteria.
func IterateNgfwHwInfo(db *sql.DB, where string, callback func(v *NgfwHwInfoRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,VERSION,BASE_MAC,MAC_COUNT,BOARD_SERIAL,BOARD_MAJOR_VER,BOARD_MINOR_VER,BOARD_REVISION FROM NGFW_HW_INFO"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwHwInfoRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Version, &r.BaseMac, &r.MacCount, &r.BoardSerial, &r.BoardMajorVer, &r.BoardMinorVer, &r.BoardRevision)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwHwInfo provide iterator to all rows of the NGFW_HW_INFO matching given criteria.
func RangeNgfwHwInfo(db *sql.DB, where string) iter.Seq2[*NgfwHwInfoRow, error] {
	return func(yield func(v *NgfwHwInfoRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,VERSION,BASE_MAC,MAC_COUNT,BOARD_SERIAL,BOARD_MAJOR_VER,BOARD_MINOR_VER,BOARD_REVISION FROM NGFW_HW_INFO"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwHwInfoRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Version, &r.BaseMac, &r.MacCount, &r.BoardSerial, &r.BoardMajorVer, &r.BoardMinorVer, &r.BoardRevision)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIfaceGreEpRow struct represents rows of the NGFW_IFACE_GRE_EP table.
type NgfwIfaceGreEpRow struct {
    ID	uint
    Version	uint
    LcAddr1	int64
    LcAddr2	int64
    RmAddr1	int64
    RmAddr2	int64
    IfaceGreID	uint
}

// IterateNgfwIfaceGreEp provide access to all rows of the NGFW_IFACE_GRE_EP matching given criteria.
func IterateNgfwIfaceGreEp(db *sql.DB, where string, callback func(v *NgfwIfaceGreEpRow) error) error {
    query := "SELECT ID,VERSION,LC_ADDR_1,LC_ADDR_2,RM_ADDR_1,RM_ADDR_2,IFACE_GRE_ID FROM NGFW_IFACE_GRE_EP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIfaceGreEpRow
        err := rows.Scan(&r.ID, &r.Version, &r.LcAddr1, &r.LcAddr2, &r.RmAddr1, &r.RmAddr2, &r.IfaceGreID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIfaceGreEp provide iterator to all rows of the NGFW_IFACE_GRE_EP matching given criteria.
func RangeNgfwIfaceGreEp(db *sql.DB, where string) iter.Seq2[*NgfwIfaceGreEpRow, error] {
	return func(yield func(v *NgfwIfaceGreEpRow, err error) bool) {
	    query := "SELECT ID,VERSION,LC_ADDR_1,LC_ADDR_2,RM_ADDR_1,RM_ADDR_2,IFACE_GRE_ID FROM NGFW_IFACE_GRE_EP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIfaceGreEpRow
	        err := rows.Scan(&r.ID, &r.Version, &r.LcAddr1, &r.LcAddr2, &r.RmAddr1, &r.RmAddr2, &r.IfaceGreID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIfacePppRow struct represents rows of the NGFW_IFACE_PPP table.
type NgfwIfacePppRow struct {
    ID	uint
    Version	uint
    Username	sql.NullString
    Password	sql.NullString
    Mru	sql.NullInt32
    RequestDnsServer	sql.NullByte
    IpcpEnabled	sql.NullByte
    Ipcpv6Enbled	sql.NullByte
    LcpKeepaliveEnabled	sql.NullByte
    LcpKeepalivePeriod	sql.NullInt32
    LcpKeepaliveRetries	sql.NullInt32
}

// IterateNgfwIfacePpp provide access to all rows of the NGFW_IFACE_PPP matching given criteria.
func IterateNgfwIfacePpp(db *sql.DB, where string, callback func(v *NgfwIfacePppRow) error) error {
    query := "SELECT ID,VERSION,USERNAME,PASSWORD,MRU,REQUEST_DNS_Server,IPCP_ENABLED,IPCPV6_ENBLED,LCP_KEEPALIVE_ENABLED,LCP_KEEPALIVE_PERIOD,LCP_KEEPALIVE_RETRIES FROM NGFW_IFACE_PPP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIfacePppRow
        err := rows.Scan(&r.ID, &r.Version, &r.Username, &r.Password, &r.Mru, &r.RequestDnsServer, &r.IpcpEnabled, &r.Ipcpv6Enbled, &r.LcpKeepaliveEnabled, &r.LcpKeepalivePeriod, &r.LcpKeepaliveRetries)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIfacePpp provide iterator to all rows of the NGFW_IFACE_PPP matching given criteria.
func RangeNgfwIfacePpp(db *sql.DB, where string) iter.Seq2[*NgfwIfacePppRow, error] {
	return func(yield func(v *NgfwIfacePppRow, err error) bool) {
	    query := "SELECT ID,VERSION,USERNAME,PASSWORD,MRU,REQUEST_DNS_Server,IPCP_ENABLED,IPCPV6_ENBLED,LCP_KEEPALIVE_ENABLED,LCP_KEEPALIVE_PERIOD,LCP_KEEPALIVE_RETRIES FROM NGFW_IFACE_PPP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIfacePppRow
	        err := rows.Scan(&r.ID, &r.Version, &r.Username, &r.Password, &r.Mru, &r.RequestDnsServer, &r.IpcpEnabled, &r.Ipcpv6Enbled, &r.LcpKeepaliveEnabled, &r.LcpKeepalivePeriod, &r.LcpKeepaliveRetries)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIfacePppReplyAuthRow struct represents rows of the NGFW_IFACE_PPP_REPLY_AUTH table.
type NgfwIfacePppReplyAuthRow struct {
    ID	uint
    Version	uint
    PppAuthAlg	string
    IfacePpp	uint
}

// IterateNgfwIfacePppReplyAuth provide access to all rows of the NGFW_IFACE_PPP_REPLY_AUTH matching given criteria.
func IterateNgfwIfacePppReplyAuth(db *sql.DB, where string, callback func(v *NgfwIfacePppReplyAuthRow) error) error {
    query := "SELECT ID,VERSION,PPP_AUTH_ALG,IFACE_PPP FROM NGFW_IFACE_PPP_REPLY_AUTH"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIfacePppReplyAuthRow
        err := rows.Scan(&r.ID, &r.Version, &r.PppAuthAlg, &r.IfacePpp)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIfacePppReplyAuth provide iterator to all rows of the NGFW_IFACE_PPP_REPLY_AUTH matching given criteria.
func RangeNgfwIfacePppReplyAuth(db *sql.DB, where string) iter.Seq2[*NgfwIfacePppReplyAuthRow, error] {
	return func(yield func(v *NgfwIfacePppReplyAuthRow, err error) bool) {
	    query := "SELECT ID,VERSION,PPP_AUTH_ALG,IFACE_PPP FROM NGFW_IFACE_PPP_REPLY_AUTH"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIfacePppReplyAuthRow
	        err := rows.Scan(&r.ID, &r.Version, &r.PppAuthAlg, &r.IfacePpp)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIfaceSubnetRow struct represents rows of the NGFW_IFACE_SUBNET table.
type NgfwIfaceSubnetRow struct {
    IfaceID	uint
    SubnetID	uint
}

// IterateNgfwIfaceSubnet provide access to all rows of the NGFW_IFACE_SUBNET matching given criteria.
func IterateNgfwIfaceSubnet(db *sql.DB, where string, callback func(v *NgfwIfaceSubnetRow) error) error {
    query := "SELECT IFACE_ID,SUBNET_ID FROM NGFW_IFACE_SUBNET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIfaceSubnetRow
        err := rows.Scan(&r.IfaceID, &r.SubnetID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIfaceSubnet provide iterator to all rows of the NGFW_IFACE_SUBNET matching given criteria.
func RangeNgfwIfaceSubnet(db *sql.DB, where string) iter.Seq2[*NgfwIfaceSubnetRow, error] {
	return func(yield func(v *NgfwIfaceSubnetRow, err error) bool) {
	    query := "SELECT IFACE_ID,SUBNET_ID FROM NGFW_IFACE_SUBNET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIfaceSubnetRow
	        err := rows.Scan(&r.IfaceID, &r.SubnetID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIgmpIfaceRow struct represents rows of the NGFW_IGMP_IFACE table.
type NgfwIgmpIfaceRow struct {
    ID	uint
    Version	uint
    DeviceShortID	sql.NullInt32
    Enabled	sql.NullByte
    IgmpVersion	sql.NullString
    InterfaceBaseID	sql.NullInt32
}

// IterateNgfwIgmpIface provide access to all rows of the NGFW_IGMP_IFACE matching given criteria.
func IterateNgfwIgmpIface(db *sql.DB, where string, callback func(v *NgfwIgmpIfaceRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLED,IGMP_VERSION,INTERFACE_BASE_ID FROM NGFW_IGMP_IFACE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIgmpIfaceRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enabled, &r.IgmpVersion, &r.InterfaceBaseID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIgmpIface provide iterator to all rows of the NGFW_IGMP_IFACE matching given criteria.
func RangeNgfwIgmpIface(db *sql.DB, where string) iter.Seq2[*NgfwIgmpIfaceRow, error] {
	return func(yield func(v *NgfwIgmpIfaceRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLED,IGMP_VERSION,INTERFACE_BASE_ID FROM NGFW_IGMP_IFACE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIgmpIfaceRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enabled, &r.IgmpVersion, &r.InterfaceBaseID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIkePh2EncriptionToV1MappingRow struct represents rows of the NGFW_IKE_PH2_ENCRIPTION_TO_V1_MAPPING table.
type NgfwIkePh2EncriptionToV1MappingRow struct {
    ID	uint
    Version	uint
    IkePh2ProposalID	uint
    V1Ph2Encription	string
    Priority	int
}

// IterateNgfwIkePh2EncriptionToV1Mapping provide access to all rows of the NGFW_IKE_PH2_ENCRIPTION_TO_V1_MAPPING matching given criteria.
func IterateNgfwIkePh2EncriptionToV1Mapping(db *sql.DB, where string, callback func(v *NgfwIkePh2EncriptionToV1MappingRow) error) error {
    query := "SELECT ID,VERSION,IKE_PH2_PROPOSAL_ID,V1_PH2_ENCRIPTION,PRIORITY FROM NGFW_IKE_PH2_ENCRIPTION_TO_V1_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIkePh2EncriptionToV1MappingRow
        err := rows.Scan(&r.ID, &r.Version, &r.IkePh2ProposalID, &r.V1Ph2Encription, &r.Priority)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIkePh2EncriptionToV1Mapping provide iterator to all rows of the NGFW_IKE_PH2_ENCRIPTION_TO_V1_MAPPING matching given criteria.
func RangeNgfwIkePh2EncriptionToV1Mapping(db *sql.DB, where string) iter.Seq2[*NgfwIkePh2EncriptionToV1MappingRow, error] {
	return func(yield func(v *NgfwIkePh2EncriptionToV1MappingRow, err error) bool) {
	    query := "SELECT ID,VERSION,IKE_PH2_PROPOSAL_ID,V1_PH2_ENCRIPTION,PRIORITY FROM NGFW_IKE_PH2_ENCRIPTION_TO_V1_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIkePh2EncriptionToV1MappingRow
	        err := rows.Scan(&r.ID, &r.Version, &r.IkePh2ProposalID, &r.V1Ph2Encription, &r.Priority)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIkePh2EncriptionToV2MappingRow struct represents rows of the NGFW_IKE_PH2_ENCRIPTION_TO_V2_MAPPING table.
type NgfwIkePh2EncriptionToV2MappingRow struct {
    ID	uint
    Version	uint
    IkePh2ProposalID	uint
    V2Ph2Encription	string
    Priority	int
}

// IterateNgfwIkePh2EncriptionToV2Mapping provide access to all rows of the NGFW_IKE_PH2_ENCRIPTION_TO_V2_MAPPING matching given criteria.
func IterateNgfwIkePh2EncriptionToV2Mapping(db *sql.DB, where string, callback func(v *NgfwIkePh2EncriptionToV2MappingRow) error) error {
    query := "SELECT ID,VERSION,IKE_PH2_PROPOSAL_ID,V2_PH2_ENCRIPTION,PRIORITY FROM NGFW_IKE_PH2_ENCRIPTION_TO_V2_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIkePh2EncriptionToV2MappingRow
        err := rows.Scan(&r.ID, &r.Version, &r.IkePh2ProposalID, &r.V2Ph2Encription, &r.Priority)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIkePh2EncriptionToV2Mapping provide iterator to all rows of the NGFW_IKE_PH2_ENCRIPTION_TO_V2_MAPPING matching given criteria.
func RangeNgfwIkePh2EncriptionToV2Mapping(db *sql.DB, where string) iter.Seq2[*NgfwIkePh2EncriptionToV2MappingRow, error] {
	return func(yield func(v *NgfwIkePh2EncriptionToV2MappingRow, err error) bool) {
	    query := "SELECT ID,VERSION,IKE_PH2_PROPOSAL_ID,V2_PH2_ENCRIPTION,PRIORITY FROM NGFW_IKE_PH2_ENCRIPTION_TO_V2_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIkePh2EncriptionToV2MappingRow
	        err := rows.Scan(&r.ID, &r.Version, &r.IkePh2ProposalID, &r.V2Ph2Encription, &r.Priority)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIkePh2ToIntegrityMappingRow struct represents rows of the NGFW_IKE_PH2_TO_INTEGRITY_MAPPING table.
type NgfwIkePh2ToIntegrityMappingRow struct {
    ID	uint
    Version	uint
    IkePh2ProposalID	uint
    Integrity	string
    Priority	int
}

// IterateNgfwIkePh2ToIntegrityMapping provide access to all rows of the NGFW_IKE_PH2_TO_INTEGRITY_MAPPING matching given criteria.
func IterateNgfwIkePh2ToIntegrityMapping(db *sql.DB, where string, callback func(v *NgfwIkePh2ToIntegrityMappingRow) error) error {
    query := "SELECT ID,VERSION,IKE_PH2_PROPOSAL_ID,INTEGRITY,PRIORITY FROM NGFW_IKE_PH2_TO_INTEGRITY_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIkePh2ToIntegrityMappingRow
        err := rows.Scan(&r.ID, &r.Version, &r.IkePh2ProposalID, &r.Integrity, &r.Priority)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIkePh2ToIntegrityMapping provide iterator to all rows of the NGFW_IKE_PH2_TO_INTEGRITY_MAPPING matching given criteria.
func RangeNgfwIkePh2ToIntegrityMapping(db *sql.DB, where string) iter.Seq2[*NgfwIkePh2ToIntegrityMappingRow, error] {
	return func(yield func(v *NgfwIkePh2ToIntegrityMappingRow, err error) bool) {
	    query := "SELECT ID,VERSION,IKE_PH2_PROPOSAL_ID,INTEGRITY,PRIORITY FROM NGFW_IKE_PH2_TO_INTEGRITY_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIkePh2ToIntegrityMappingRow
	        err := rows.Scan(&r.ID, &r.Version, &r.IkePh2ProposalID, &r.Integrity, &r.Priority)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIkePhase1ProposalRow struct represents rows of the NGFW_IKE_PHASE1_PROPOSAL table.
type NgfwIkePhase1ProposalRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Phase1Proposalname	string
    IkeVersion	int
    Encryption	string
    Integrity	string
    DiffieHelman	string
    LifeTime	int
    Lifetimetype	string
    Authentication	string
    RemoteAuth	string
    Xauth	string
}

// IterateNgfwIkePhase1Proposal provide access to all rows of the NGFW_IKE_PHASE1_PROPOSAL matching given criteria.
func IterateNgfwIkePhase1Proposal(db *sql.DB, where string, callback func(v *NgfwIkePhase1ProposalRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,PHASE1_PROPOSALNAME,IKE_VERSION,ENCRYPTION,INTEGRITY,DIFFIE_HELMAN,LIFE_TIME,LIFETIMETYPE,AUTHENTICATION,REMOTE_AUTH,XAUTH FROM NGFW_IKE_PHASE1_PROPOSAL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIkePhase1ProposalRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Phase1Proposalname, &r.IkeVersion, &r.Encryption, &r.Integrity, &r.DiffieHelman, &r.LifeTime, &r.Lifetimetype, &r.Authentication, &r.RemoteAuth, &r.Xauth)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIkePhase1Proposal provide iterator to all rows of the NGFW_IKE_PHASE1_PROPOSAL matching given criteria.
func RangeNgfwIkePhase1Proposal(db *sql.DB, where string) iter.Seq2[*NgfwIkePhase1ProposalRow, error] {
	return func(yield func(v *NgfwIkePhase1ProposalRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,PHASE1_PROPOSALNAME,IKE_VERSION,ENCRYPTION,INTEGRITY,DIFFIE_HELMAN,LIFE_TIME,LIFETIMETYPE,AUTHENTICATION,REMOTE_AUTH,XAUTH FROM NGFW_IKE_PHASE1_PROPOSAL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIkePhase1ProposalRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Phase1Proposalname, &r.IkeVersion, &r.Encryption, &r.Integrity, &r.DiffieHelman, &r.LifeTime, &r.Lifetimetype, &r.Authentication, &r.RemoteAuth, &r.Xauth)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIkePhase2ProposalRow struct represents rows of the NGFW_IKE_PHASE2_PROPOSAL table.
type NgfwIkePhase2ProposalRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Phase2Proposalname	string
    IkeVersion	int
    DiffieHelman	string
    LifeTime	int
    Lifetimetype	string
}

// IterateNgfwIkePhase2Proposal provide access to all rows of the NGFW_IKE_PHASE2_PROPOSAL matching given criteria.
func IterateNgfwIkePhase2Proposal(db *sql.DB, where string, callback func(v *NgfwIkePhase2ProposalRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,PHASE2_PROPOSALNAME,IKE_VERSION,DIFFIE_HELMAN,LIFE_TIME,LIFETIMETYPE FROM NGFW_IKE_PHASE2_PROPOSAL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIkePhase2ProposalRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Phase2Proposalname, &r.IkeVersion, &r.DiffieHelman, &r.LifeTime, &r.Lifetimetype)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIkePhase2Proposal provide iterator to all rows of the NGFW_IKE_PHASE2_PROPOSAL matching given criteria.
func RangeNgfwIkePhase2Proposal(db *sql.DB, where string) iter.Seq2[*NgfwIkePhase2ProposalRow, error] {
	return func(yield func(v *NgfwIkePhase2ProposalRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,PHASE2_PROPOSALNAME,IKE_VERSION,DIFFIE_HELMAN,LIFE_TIME,LIFETIMETYPE FROM NGFW_IKE_PHASE2_PROPOSAL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIkePhase2ProposalRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Phase2Proposalname, &r.IkeVersion, &r.DiffieHelman, &r.LifeTime, &r.Lifetimetype)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfaceAggrRow struct represents rows of the NGFW_INTERFACE_AGGR table.
type NgfwInterfaceAggrRow struct {
    InterfaceBaseID	uint
    LoadBalance	string
    MinimumLinks	int
}

// IterateNgfwInterfaceAggr provide access to all rows of the NGFW_INTERFACE_AGGR matching given criteria.
func IterateNgfwInterfaceAggr(db *sql.DB, where string, callback func(v *NgfwInterfaceAggrRow) error) error {
    query := "SELECT INTERFACE_BASE_ID,LOAD_BALANCE,MINIMUM_LINKS FROM NGFW_INTERFACE_AGGR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfaceAggrRow
        err := rows.Scan(&r.InterfaceBaseID, &r.LoadBalance, &r.MinimumLinks)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfaceAggr provide iterator to all rows of the NGFW_INTERFACE_AGGR matching given criteria.
func RangeNgfwInterfaceAggr(db *sql.DB, where string) iter.Seq2[*NgfwInterfaceAggrRow, error] {
	return func(yield func(v *NgfwInterfaceAggrRow, err error) bool) {
	    query := "SELECT INTERFACE_BASE_ID,LOAD_BALANCE,MINIMUM_LINKS FROM NGFW_INTERFACE_AGGR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfaceAggrRow
	        err := rows.Scan(&r.InterfaceBaseID, &r.LoadBalance, &r.MinimumLinks)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfaceBaseRow struct represents rows of the NGFW_INTERFACE_BASE table.
type NgfwInterfaceBaseRow struct {
    ID	uint
    Version	uint
    Name	string
    DisplayName	sql.NullString
    Description	sql.NullString
    DeviceShortID	uint
    InterfaceType	string
    IfaceID	uint
    Enabled	int8
    Mtu	sql.NullInt32
    SmsUuid	sql.NullString
    LastModified	string
}

// IterateNgfwInterfaceBase provide access to all rows of the NGFW_INTERFACE_BASE matching given criteria.
func IterateNgfwInterfaceBase(db *sql.DB, where string, callback func(v *NgfwInterfaceBaseRow) error) error {
    query := "SELECT ID,VERSION,NAME,DISPLAY_NAME,DESCRIPTION,DEVICE_SHORT_ID,INTERFACE_TYPE,IFACE_ID,ENABLED,MTU,SMS_UUID,LAST_MODIFIED FROM NGFW_INTERFACE_BASE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfaceBaseRow
        err := rows.Scan(&r.ID, &r.Version, &r.Name, &r.DisplayName, &r.Description, &r.DeviceShortID, &r.InterfaceType, &r.IfaceID, &r.Enabled, &r.Mtu, &r.SmsUuid, &r.LastModified)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfaceBase provide iterator to all rows of the NGFW_INTERFACE_BASE matching given criteria.
func RangeNgfwInterfaceBase(db *sql.DB, where string) iter.Seq2[*NgfwInterfaceBaseRow, error] {
	return func(yield func(v *NgfwInterfaceBaseRow, err error) bool) {
	    query := "SELECT ID,VERSION,NAME,DISPLAY_NAME,DESCRIPTION,DEVICE_SHORT_ID,INTERFACE_TYPE,IFACE_ID,ENABLED,MTU,SMS_UUID,LAST_MODIFIED FROM NGFW_INTERFACE_BASE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfaceBaseRow
	        err := rows.Scan(&r.ID, &r.Version, &r.Name, &r.DisplayName, &r.Description, &r.DeviceShortID, &r.InterfaceType, &r.IfaceID, &r.Enabled, &r.Mtu, &r.SmsUuid, &r.LastModified)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfaceBridgeRow struct represents rows of the NGFW_INTERFACE_BRIDGE table.
type NgfwInterfaceBridgeRow struct {
    InterfaceBaseID	uint
}

// IterateNgfwInterfaceBridge provide access to all rows of the NGFW_INTERFACE_BRIDGE matching given criteria.
func IterateNgfwInterfaceBridge(db *sql.DB, where string, callback func(v *NgfwInterfaceBridgeRow) error) error {
    query := "SELECT INTERFACE_BASE_ID FROM NGFW_INTERFACE_BRIDGE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfaceBridgeRow
        err := rows.Scan(&r.InterfaceBaseID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfaceBridge provide iterator to all rows of the NGFW_INTERFACE_BRIDGE matching given criteria.
func RangeNgfwInterfaceBridge(db *sql.DB, where string) iter.Seq2[*NgfwInterfaceBridgeRow, error] {
	return func(yield func(v *NgfwInterfaceBridgeRow, err error) bool) {
	    query := "SELECT INTERFACE_BASE_ID FROM NGFW_INTERFACE_BRIDGE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfaceBridgeRow
	        err := rows.Scan(&r.InterfaceBaseID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfaceDhcp6Row struct represents rows of the NGFW_INTERFACE_DHCP6 table.
type NgfwInterfaceDhcp6Row struct {
    ID	uint
    Version	uint
    EnabledV6	sql.NullByte
    ReqIPAddress	sql.NullByte
    ReqDnsServerV6	sql.NullByte
    ReqDnsDomains	sql.NullByte
    ReqPrefixDelegation	sql.NullByte
    EnableRapidCommit	sql.NullByte
    Duid	sql.NullString
    IfaceIP	uint
}

// IterateNgfwInterfaceDhcp6 provide access to all rows of the NGFW_INTERFACE_DHCP6 matching given criteria.
func IterateNgfwInterfaceDhcp6(db *sql.DB, where string, callback func(v *NgfwInterfaceDhcp6Row) error) error {
    query := "SELECT ID,VERSION,ENABLED_V6,REQ_IP_ADDRESS,REQ_DNS_SERVER_V6,REQ_DNS_DOMAINS,REQ_PREFIX_DELEGATION,ENABLE_RAPID_COMMIT,DUID,IFACE_IP FROM NGFW_INTERFACE_DHCP6"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfaceDhcp6Row
        err := rows.Scan(&r.ID, &r.Version, &r.EnabledV6, &r.ReqIPAddress, &r.ReqDnsServerV6, &r.ReqDnsDomains, &r.ReqPrefixDelegation, &r.EnableRapidCommit, &r.Duid, &r.IfaceIP)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfaceDhcp6 provide iterator to all rows of the NGFW_INTERFACE_DHCP6 matching given criteria.
func RangeNgfwInterfaceDhcp6(db *sql.DB, where string) iter.Seq2[*NgfwInterfaceDhcp6Row, error] {
	return func(yield func(v *NgfwInterfaceDhcp6Row, err error) bool) {
	    query := "SELECT ID,VERSION,ENABLED_V6,REQ_IP_ADDRESS,REQ_DNS_SERVER_V6,REQ_DNS_DOMAINS,REQ_PREFIX_DELEGATION,ENABLE_RAPID_COMMIT,DUID,IFACE_IP FROM NGFW_INTERFACE_DHCP6"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfaceDhcp6Row
	        err := rows.Scan(&r.ID, &r.Version, &r.EnabledV6, &r.ReqIPAddress, &r.ReqDnsServerV6, &r.ReqDnsDomains, &r.ReqPrefixDelegation, &r.EnableRapidCommit, &r.Duid, &r.IfaceIP)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfaceEthernetRow struct represents rows of the NGFW_INTERFACE_ETHERNET table.
type NgfwInterfaceEthernetRow struct {
    InterfaceBaseID	uint
    EnableAutoNeg	int8
    LinkSpeed	sql.NullInt32
    FullDuplex	sql.NullByte
}

// IterateNgfwInterfaceEthernet provide access to all rows of the NGFW_INTERFACE_ETHERNET matching given criteria.
func IterateNgfwInterfaceEthernet(db *sql.DB, where string, callback func(v *NgfwInterfaceEthernetRow) error) error {
    query := "SELECT INTERFACE_BASE_ID,ENABLE_AUTO_NEG,LINK_SPEED,FULL_DUPLEX FROM NGFW_INTERFACE_ETHERNET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfaceEthernetRow
        err := rows.Scan(&r.InterfaceBaseID, &r.EnableAutoNeg, &r.LinkSpeed, &r.FullDuplex)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfaceEthernet provide iterator to all rows of the NGFW_INTERFACE_ETHERNET matching given criteria.
func RangeNgfwInterfaceEthernet(db *sql.DB, where string) iter.Seq2[*NgfwInterfaceEthernetRow, error] {
	return func(yield func(v *NgfwInterfaceEthernetRow, err error) bool) {
	    query := "SELECT INTERFACE_BASE_ID,ENABLE_AUTO_NEG,LINK_SPEED,FULL_DUPLEX FROM NGFW_INTERFACE_ETHERNET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfaceEthernetRow
	        err := rows.Scan(&r.InterfaceBaseID, &r.EnableAutoNeg, &r.LinkSpeed, &r.FullDuplex)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfaceGreRow struct represents rows of the NGFW_INTERFACE_GRE table.
type NgfwInterfaceGreRow struct {
    InterfaceBaseID	uint
    OtLcAddr1	int64
    OtLcAddr2	int64
    OtRmAddr1	int64
    OtRmAddr2	int64
    CheckSum	int8
    EnableGreKeys	int8
    KeyValue	sql.NullInt32
}

// IterateNgfwInterfaceGre provide access to all rows of the NGFW_INTERFACE_GRE matching given criteria.
func IterateNgfwInterfaceGre(db *sql.DB, where string, callback func(v *NgfwInterfaceGreRow) error) error {
    query := "SELECT INTERFACE_BASE_ID,OT_LC_ADDR_1,OT_LC_ADDR_2,OT_RM_ADDR_1,OT_RM_ADDR_2,CHECK_SUM,ENABLE_GRE_KEYS,KEY_VALUE FROM NGFW_INTERFACE_GRE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfaceGreRow
        err := rows.Scan(&r.InterfaceBaseID, &r.OtLcAddr1, &r.OtLcAddr2, &r.OtRmAddr1, &r.OtRmAddr2, &r.CheckSum, &r.EnableGreKeys, &r.KeyValue)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfaceGre provide iterator to all rows of the NGFW_INTERFACE_GRE matching given criteria.
func RangeNgfwInterfaceGre(db *sql.DB, where string) iter.Seq2[*NgfwInterfaceGreRow, error] {
	return func(yield func(v *NgfwInterfaceGreRow, err error) bool) {
	    query := "SELECT INTERFACE_BASE_ID,OT_LC_ADDR_1,OT_LC_ADDR_2,OT_RM_ADDR_1,OT_RM_ADDR_2,CHECK_SUM,ENABLE_GRE_KEYS,KEY_VALUE FROM NGFW_INTERFACE_GRE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfaceGreRow
	        err := rows.Scan(&r.InterfaceBaseID, &r.OtLcAddr1, &r.OtLcAddr2, &r.OtRmAddr1, &r.OtRmAddr2, &r.CheckSum, &r.EnableGreKeys, &r.KeyValue)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfaceIPRow struct represents rows of the NGFW_INTERFACE_IP table.
type NgfwInterfaceIPRow struct {
    ID	uint
    Version	uint
    EnabledV4	sql.NullByte
    ReqDefRoute	sql.NullByte
    ReqDnsServerV4	sql.NullByte
    ReqNtpServer	sql.NullByte
    Hostname	sql.NullString
    Identifier	sql.NullString
    OptionName	sql.NullString
    Ipv4Address	sql.NullInt64
    IfaceID	uint
    HexIdentifier	[]byte
}

// IterateNgfwInterfaceIP provide access to all rows of the NGFW_INTERFACE_IP matching given criteria.
func IterateNgfwInterfaceIP(db *sql.DB, where string, callback func(v *NgfwInterfaceIPRow) error) error {
    query := "SELECT ID,VERSION,ENABLED_V4,REQ_DEF_ROUTE,REQ_DNS_SERVER_V4,REQ_NTP_SERVER,HOSTNAME,IDENTIFIER,OPTION_NAME,IPV4_ADDRESS,IFACE_ID,HEX_IDENTIFIER FROM NGFW_INTERFACE_IP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfaceIPRow
        err := rows.Scan(&r.ID, &r.Version, &r.EnabledV4, &r.ReqDefRoute, &r.ReqDnsServerV4, &r.ReqNtpServer, &r.Hostname, &r.Identifier, &r.OptionName, &r.Ipv4Address, &r.IfaceID, &r.HexIdentifier)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfaceIP provide iterator to all rows of the NGFW_INTERFACE_IP matching given criteria.
func RangeNgfwInterfaceIP(db *sql.DB, where string) iter.Seq2[*NgfwInterfaceIPRow, error] {
	return func(yield func(v *NgfwInterfaceIPRow, err error) bool) {
	    query := "SELECT ID,VERSION,ENABLED_V4,REQ_DEF_ROUTE,REQ_DNS_SERVER_V4,REQ_NTP_SERVER,HOSTNAME,IDENTIFIER,OPTION_NAME,IPV4_ADDRESS,IFACE_ID,HEX_IDENTIFIER FROM NGFW_INTERFACE_IP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfaceIPRow
	        err := rows.Scan(&r.ID, &r.Version, &r.EnabledV4, &r.ReqDefRoute, &r.ReqDnsServerV4, &r.ReqNtpServer, &r.Hostname, &r.Identifier, &r.OptionName, &r.Ipv4Address, &r.IfaceID, &r.HexIdentifier)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfaceIPOptionsRow struct represents rows of the NGFW_INTERFACE_IP_OPTIONS table.
type NgfwInterfaceIPOptionsRow struct {
    ID	uint
    Version	uint
    Tcp4mss	string
    Tcp4mssManual	sql.NullInt32
    IgmpVersion	sql.NullInt32
    Tcp6mss	string
    Tcp6mssManual	sql.NullInt32
    MldVersion	sql.NullInt32
    EnableAutoV6Cfg	sql.NullByte
    RaAutoConfLevel	string
    RaTransmitMode	string
    RaIntervalMsec	sql.NullInt32
    RaLifetimeSec	sql.NullInt32
    RaMtu	sql.NullInt32
    EnableRaIntervalTransmit	sql.NullByte
    IfaceID	uint
}

// IterateNgfwInterfaceIPOptions provide access to all rows of the NGFW_INTERFACE_IP_OPTIONS matching given criteria.
func IterateNgfwInterfaceIPOptions(db *sql.DB, where string, callback func(v *NgfwInterfaceIPOptionsRow) error) error {
    query := "SELECT ID,VERSION,TCP4MSS,TCP4MSS_MANUAL,IGMP_VERSION,TCP6MSS,TCP6MSS_MANUAL,MLD_VERSION,ENABLE_AUTO_V6_CFG,RA_AUTO_CONF_LEVEL,RA_TRANSMIT_MODE,RA_INTERVAL_MSEC,RA_LIFETIME_SEC,RA_MTU,ENABLE_RA_INTERVAL_TRANSMIT,IFACE_ID FROM NGFW_INTERFACE_IP_OPTIONS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfaceIPOptionsRow
        err := rows.Scan(&r.ID, &r.Version, &r.Tcp4mss, &r.Tcp4mssManual, &r.IgmpVersion, &r.Tcp6mss, &r.Tcp6mssManual, &r.MldVersion, &r.EnableAutoV6Cfg, &r.RaAutoConfLevel, &r.RaTransmitMode, &r.RaIntervalMsec, &r.RaLifetimeSec, &r.RaMtu, &r.EnableRaIntervalTransmit, &r.IfaceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfaceIPOptions provide iterator to all rows of the NGFW_INTERFACE_IP_OPTIONS matching given criteria.
func RangeNgfwInterfaceIPOptions(db *sql.DB, where string) iter.Seq2[*NgfwInterfaceIPOptionsRow, error] {
	return func(yield func(v *NgfwInterfaceIPOptionsRow, err error) bool) {
	    query := "SELECT ID,VERSION,TCP4MSS,TCP4MSS_MANUAL,IGMP_VERSION,TCP6MSS,TCP6MSS_MANUAL,MLD_VERSION,ENABLE_AUTO_V6_CFG,RA_AUTO_CONF_LEVEL,RA_TRANSMIT_MODE,RA_INTERVAL_MSEC,RA_LIFETIME_SEC,RA_MTU,ENABLE_RA_INTERVAL_TRANSMIT,IFACE_ID FROM NGFW_INTERFACE_IP_OPTIONS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfaceIPOptionsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.Tcp4mss, &r.Tcp4mssManual, &r.IgmpVersion, &r.Tcp6mss, &r.Tcp6mssManual, &r.MldVersion, &r.EnableAutoV6Cfg, &r.RaAutoConfLevel, &r.RaTransmitMode, &r.RaIntervalMsec, &r.RaLifetimeSec, &r.RaMtu, &r.EnableRaIntervalTransmit, &r.IfaceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfaceL2tpClientRow struct represents rows of the NGFW_INTERFACE_L2TP_CLIENT table.
type NgfwInterfaceL2tpClientRow struct {
    InterfaceBaseID	uint
    LocalIpv4Address	sql.NullInt64
    RemoteIpv4Address	sql.NullInt64
    SequencingEnabled	int8
    L2tpAuthEnabled	int8
    SharedSecret	sql.NullString
    IfacePpp	uint
}

// IterateNgfwInterfaceL2tpClient provide access to all rows of the NGFW_INTERFACE_L2TP_CLIENT matching given criteria.
func IterateNgfwInterfaceL2tpClient(db *sql.DB, where string, callback func(v *NgfwInterfaceL2tpClientRow) error) error {
    query := "SELECT INTERFACE_BASE_ID,LOCAL_IPV4_ADDRESS,REMOTE_IPV4_ADDRESS,SEQUENCING_ENABLED,L2TP_AUTH_ENABLED,SHARED_SECRET,IFACE_PPP FROM NGFW_INTERFACE_L2TP_CLIENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfaceL2tpClientRow
        err := rows.Scan(&r.InterfaceBaseID, &r.LocalIpv4Address, &r.RemoteIpv4Address, &r.SequencingEnabled, &r.L2tpAuthEnabled, &r.SharedSecret, &r.IfacePpp)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfaceL2tpClient provide iterator to all rows of the NGFW_INTERFACE_L2TP_CLIENT matching given criteria.
func RangeNgfwInterfaceL2tpClient(db *sql.DB, where string) iter.Seq2[*NgfwInterfaceL2tpClientRow, error] {
	return func(yield func(v *NgfwInterfaceL2tpClientRow, err error) bool) {
	    query := "SELECT INTERFACE_BASE_ID,LOCAL_IPV4_ADDRESS,REMOTE_IPV4_ADDRESS,SEQUENCING_ENABLED,L2TP_AUTH_ENABLED,SHARED_SECRET,IFACE_PPP FROM NGFW_INTERFACE_L2TP_CLIENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfaceL2tpClientRow
	        err := rows.Scan(&r.InterfaceBaseID, &r.LocalIpv4Address, &r.RemoteIpv4Address, &r.SequencingEnabled, &r.L2tpAuthEnabled, &r.SharedSecret, &r.IfacePpp)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfaceLoopbackRow struct represents rows of the NGFW_INTERFACE_LOOPBACK table.
type NgfwInterfaceLoopbackRow struct {
    InterfaceBaseID	uint
}

// IterateNgfwInterfaceLoopback provide access to all rows of the NGFW_INTERFACE_LOOPBACK matching given criteria.
func IterateNgfwInterfaceLoopback(db *sql.DB, where string, callback func(v *NgfwInterfaceLoopbackRow) error) error {
    query := "SELECT INTERFACE_BASE_ID FROM NGFW_INTERFACE_LOOPBACK"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfaceLoopbackRow
        err := rows.Scan(&r.InterfaceBaseID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfaceLoopback provide iterator to all rows of the NGFW_INTERFACE_LOOPBACK matching given criteria.
func RangeNgfwInterfaceLoopback(db *sql.DB, where string) iter.Seq2[*NgfwInterfaceLoopbackRow, error] {
	return func(yield func(v *NgfwInterfaceLoopbackRow, err error) bool) {
	    query := "SELECT INTERFACE_BASE_ID FROM NGFW_INTERFACE_LOOPBACK"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfaceLoopbackRow
	        err := rows.Scan(&r.InterfaceBaseID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfaceManagementRow struct represents rows of the NGFW_INTERFACE_MANAGEMENT table.
type NgfwInterfaceManagementRow struct {
    InterfaceBaseID	uint
    EnableAutoNeg	int8
    LinkSpeed	sql.NullInt32
    FullDuplex	sql.NullByte
    HostName	sql.NullString
    Location	sql.NullString
    Contact	sql.NullString
}

// IterateNgfwInterfaceManagement provide access to all rows of the NGFW_INTERFACE_MANAGEMENT matching given criteria.
func IterateNgfwInterfaceManagement(db *sql.DB, where string, callback func(v *NgfwInterfaceManagementRow) error) error {
    query := "SELECT INTERFACE_BASE_ID,ENABLE_AUTO_NEG,LINK_SPEED,FULL_DUPLEX,HOST_NAME,LOCATION,CONTACT FROM NGFW_INTERFACE_MANAGEMENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfaceManagementRow
        err := rows.Scan(&r.InterfaceBaseID, &r.EnableAutoNeg, &r.LinkSpeed, &r.FullDuplex, &r.HostName, &r.Location, &r.Contact)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfaceManagement provide iterator to all rows of the NGFW_INTERFACE_MANAGEMENT matching given criteria.
func RangeNgfwInterfaceManagement(db *sql.DB, where string) iter.Seq2[*NgfwInterfaceManagementRow, error] {
	return func(yield func(v *NgfwInterfaceManagementRow, err error) bool) {
	    query := "SELECT INTERFACE_BASE_ID,ENABLE_AUTO_NEG,LINK_SPEED,FULL_DUPLEX,HOST_NAME,LOCATION,CONTACT FROM NGFW_INTERFACE_MANAGEMENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfaceManagementRow
	        err := rows.Scan(&r.InterfaceBaseID, &r.EnableAutoNeg, &r.LinkSpeed, &r.FullDuplex, &r.HostName, &r.Location, &r.Contact)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfacePppoeClientRow struct represents rows of the NGFW_INTERFACE_PPPOE_CLIENT table.
type NgfwInterfacePppoeClientRow struct {
    InterfaceBaseID	uint
    PppoeIfaceID	sql.NullInt32
    IfacePpp	uint
    ServiceName	sql.NullString
}

// IterateNgfwInterfacePppoeClient provide access to all rows of the NGFW_INTERFACE_PPPOE_CLIENT matching given criteria.
func IterateNgfwInterfacePppoeClient(db *sql.DB, where string, callback func(v *NgfwInterfacePppoeClientRow) error) error {
    query := "SELECT INTERFACE_BASE_ID,PPPOE_IFACE_ID,IFACE_PPP,SERVICE_NAME FROM NGFW_INTERFACE_PPPOE_CLIENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfacePppoeClientRow
        err := rows.Scan(&r.InterfaceBaseID, &r.PppoeIfaceID, &r.IfacePpp, &r.ServiceName)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfacePppoeClient provide iterator to all rows of the NGFW_INTERFACE_PPPOE_CLIENT matching given criteria.
func RangeNgfwInterfacePppoeClient(db *sql.DB, where string) iter.Seq2[*NgfwInterfacePppoeClientRow, error] {
	return func(yield func(v *NgfwInterfacePppoeClientRow, err error) bool) {
	    query := "SELECT INTERFACE_BASE_ID,PPPOE_IFACE_ID,IFACE_PPP,SERVICE_NAME FROM NGFW_INTERFACE_PPPOE_CLIENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfacePppoeClientRow
	        err := rows.Scan(&r.InterfaceBaseID, &r.PppoeIfaceID, &r.IfacePpp, &r.ServiceName)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfacePptpClientRow struct represents rows of the NGFW_INTERFACE_PPTP_CLIENT table.
type NgfwInterfacePptpClientRow struct {
    InterfaceBaseID	uint
    LocalIpv4Address	int64
    RemoteIpv4Address	int64
    AlwaysAckEnabled	int8
    DelayedAckEnabled	int8
    WindowingEnabled	int8
    IfacePpp	uint
}

// IterateNgfwInterfacePptpClient provide access to all rows of the NGFW_INTERFACE_PPTP_CLIENT matching given criteria.
func IterateNgfwInterfacePptpClient(db *sql.DB, where string, callback func(v *NgfwInterfacePptpClientRow) error) error {
    query := "SELECT INTERFACE_BASE_ID,LOCAL_IPV4_ADDRESS,REMOTE_IPV4_ADDRESS,ALWAYS_ACK_ENABLED,DELAYED_ACK_ENABLED,WINDOWING_ENABLED,IFACE_PPP FROM NGFW_INTERFACE_PPTP_CLIENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfacePptpClientRow
        err := rows.Scan(&r.InterfaceBaseID, &r.LocalIpv4Address, &r.RemoteIpv4Address, &r.AlwaysAckEnabled, &r.DelayedAckEnabled, &r.WindowingEnabled, &r.IfacePpp)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfacePptpClient provide iterator to all rows of the NGFW_INTERFACE_PPTP_CLIENT matching given criteria.
func RangeNgfwInterfacePptpClient(db *sql.DB, where string) iter.Seq2[*NgfwInterfacePptpClientRow, error] {
	return func(yield func(v *NgfwInterfacePptpClientRow, err error) bool) {
	    query := "SELECT INTERFACE_BASE_ID,LOCAL_IPV4_ADDRESS,REMOTE_IPV4_ADDRESS,ALWAYS_ACK_ENABLED,DELAYED_ACK_ENABLED,WINDOWING_ENABLED,IFACE_PPP FROM NGFW_INTERFACE_PPTP_CLIENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfacePptpClientRow
	        err := rows.Scan(&r.InterfaceBaseID, &r.LocalIpv4Address, &r.RemoteIpv4Address, &r.AlwaysAckEnabled, &r.DelayedAckEnabled, &r.WindowingEnabled, &r.IfacePpp)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfaceSpRow struct represents rows of the NGFW_INTERFACE_SP table.
type NgfwInterfaceSpRow struct {
    InterfaceBaseID	uint
}

// IterateNgfwInterfaceSp provide access to all rows of the NGFW_INTERFACE_SP matching given criteria.
func IterateNgfwInterfaceSp(db *sql.DB, where string, callback func(v *NgfwInterfaceSpRow) error) error {
    query := "SELECT INTERFACE_BASE_ID FROM NGFW_INTERFACE_SP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfaceSpRow
        err := rows.Scan(&r.InterfaceBaseID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfaceSp provide iterator to all rows of the NGFW_INTERFACE_SP matching given criteria.
func RangeNgfwInterfaceSp(db *sql.DB, where string) iter.Seq2[*NgfwInterfaceSpRow, error] {
	return func(yield func(v *NgfwInterfaceSpRow, err error) bool) {
	    query := "SELECT INTERFACE_BASE_ID FROM NGFW_INTERFACE_SP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfaceSpRow
	        err := rows.Scan(&r.InterfaceBaseID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwInterfaceVLANRow struct represents rows of the NGFW_INTERFACE_VLAN table.
type NgfwInterfaceVLANRow struct {
    InterfaceBaseID	uint
    VLANID	uint16
    VLANIfaceID	uint
}

// IterateNgfwInterfaceVLAN provide access to all rows of the NGFW_INTERFACE_VLAN matching given criteria.
func IterateNgfwInterfaceVLAN(db *sql.DB, where string, callback func(v *NgfwInterfaceVLANRow) error) error {
    query := "SELECT INTERFACE_BASE_ID,VLAN_ID,VLAN_IFACE_ID FROM NGFW_INTERFACE_VLAN"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwInterfaceVLANRow
        err := rows.Scan(&r.InterfaceBaseID, &r.VLANID, &r.VLANIfaceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwInterfaceVLAN provide iterator to all rows of the NGFW_INTERFACE_VLAN matching given criteria.
func RangeNgfwInterfaceVLAN(db *sql.DB, where string) iter.Seq2[*NgfwInterfaceVLANRow, error] {
	return func(yield func(v *NgfwInterfaceVLANRow, err error) bool) {
	    query := "SELECT INTERFACE_BASE_ID,VLAN_ID,VLAN_IFACE_ID FROM NGFW_INTERFACE_VLAN"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwInterfaceVLANRow
	        err := rows.Scan(&r.InterfaceBaseID, &r.VLANID, &r.VLANIfaceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIpsecGlobalSettingsRow struct represents rows of the NGFW_IPSEC_GLOBAL_SETTINGS table.
type NgfwIpsecGlobalSettingsRow struct {
    ID	uint
    Version	uint
    DeviceShortID	sql.NullInt32
    Enabled	int8
    RetransmitTries	uint
    RetransmitTimeout	uint
    CrlValidationRequired	int8
}

// IterateNgfwIpsecGlobalSettings provide access to all rows of the NGFW_IPSEC_GLOBAL_SETTINGS matching given criteria.
func IterateNgfwIpsecGlobalSettings(db *sql.DB, where string, callback func(v *NgfwIpsecGlobalSettingsRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLED,RETRANSMIT_TRIES,RETRANSMIT_TIMEOUT,CRL_VALIDATION_REQUIRED FROM NGFW_IPSEC_GLOBAL_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIpsecGlobalSettingsRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enabled, &r.RetransmitTries, &r.RetransmitTimeout, &r.CrlValidationRequired)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIpsecGlobalSettings provide iterator to all rows of the NGFW_IPSEC_GLOBAL_SETTINGS matching given criteria.
func RangeNgfwIpsecGlobalSettings(db *sql.DB, where string) iter.Seq2[*NgfwIpsecGlobalSettingsRow, error] {
	return func(yield func(v *NgfwIpsecGlobalSettingsRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLED,RETRANSMIT_TRIES,RETRANSMIT_TIMEOUT,CRL_VALIDATION_REQUIRED FROM NGFW_IPSEC_GLOBAL_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIpsecGlobalSettingsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enabled, &r.RetransmitTries, &r.RetransmitTimeout, &r.CrlValidationRequired)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIpsecPolicyRow struct represents rows of the NGFW_IPSEC_POLICY table.
type NgfwIpsecPolicyRow struct {
    ID	uint
    Version	sql.NullInt32
    DeviceShortID	uint
    Priority	uint
    PolicyName	string
    LocalSubnetNamedObjID	int
    RemoteSubnetNamedObjID	int
    Protocol	sql.NullString
    ProtoNumber	sql.NullInt32
    LocalPort	sql.NullInt32
    RemotePort	sql.NullInt32
    PolicyType	string
    IpsecMode	string
    VpnID	uint
    Enable	sql.NullByte
}

// IterateNgfwIpsecPolicy provide access to all rows of the NGFW_IPSEC_POLICY matching given criteria.
func IterateNgfwIpsecPolicy(db *sql.DB, where string, callback func(v *NgfwIpsecPolicyRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,PRIORITY,POLICY_NAME,LOCAL_SUBNET_NAMED_OBJ_ID,REMOTE_SUBNET_NAMED_OBJ_ID,PROTOCOL,PROTO_NUMBER,LOCAL_PORT,REMOTE_PORT,POLICY_TYPE,IPSEC_MODE,VPN_ID,ENABLE FROM NGFW_IPSEC_POLICY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIpsecPolicyRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Priority, &r.PolicyName, &r.LocalSubnetNamedObjID, &r.RemoteSubnetNamedObjID, &r.Protocol, &r.ProtoNumber, &r.LocalPort, &r.RemotePort, &r.PolicyType, &r.IpsecMode, &r.VpnID, &r.Enable)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIpsecPolicy provide iterator to all rows of the NGFW_IPSEC_POLICY matching given criteria.
func RangeNgfwIpsecPolicy(db *sql.DB, where string) iter.Seq2[*NgfwIpsecPolicyRow, error] {
	return func(yield func(v *NgfwIpsecPolicyRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,PRIORITY,POLICY_NAME,LOCAL_SUBNET_NAMED_OBJ_ID,REMOTE_SUBNET_NAMED_OBJ_ID,PROTOCOL,PROTO_NUMBER,LOCAL_PORT,REMOTE_PORT,POLICY_TYPE,IPSEC_MODE,VPN_ID,ENABLE FROM NGFW_IPSEC_POLICY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIpsecPolicyRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Priority, &r.PolicyName, &r.LocalSubnetNamedObjID, &r.RemoteSubnetNamedObjID, &r.Protocol, &r.ProtoNumber, &r.LocalPort, &r.RemotePort, &r.PolicyType, &r.IpsecMode, &r.VpnID, &r.Enable)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIpsecPreSharedKeyRow struct represents rows of the NGFW_IPSEC_PRE_SHARED_KEY table.
type NgfwIpsecPreSharedKeyRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Keyvalue	string
    Localhost	string
    Peerhost	string
}

// IterateNgfwIpsecPreSharedKey provide access to all rows of the NGFW_IPSEC_PRE_SHARED_KEY matching given criteria.
func IterateNgfwIpsecPreSharedKey(db *sql.DB, where string, callback func(v *NgfwIpsecPreSharedKeyRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,KEYVALUE,LOCALHOST,PEERHOST FROM NGFW_IPSEC_PRE_SHARED_KEY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIpsecPreSharedKeyRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Keyvalue, &r.Localhost, &r.Peerhost)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIpsecPreSharedKey provide iterator to all rows of the NGFW_IPSEC_PRE_SHARED_KEY matching given criteria.
func RangeNgfwIpsecPreSharedKey(db *sql.DB, where string) iter.Seq2[*NgfwIpsecPreSharedKeyRow, error] {
	return func(yield func(v *NgfwIpsecPreSharedKeyRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,KEYVALUE,LOCALHOST,PEERHOST FROM NGFW_IPSEC_PRE_SHARED_KEY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIpsecPreSharedKeyRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Keyvalue, &r.Localhost, &r.Peerhost)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIpsecUserRow struct represents rows of the NGFW_IPSEC_USER table.
type NgfwIpsecUserRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Username	string
    Password	string
}

// IterateNgfwIpsecUser provide access to all rows of the NGFW_IPSEC_USER matching given criteria.
func IterateNgfwIpsecUser(db *sql.DB, where string, callback func(v *NgfwIpsecUserRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,USERNAME,PASSWORD FROM NGFW_IPSEC_USER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIpsecUserRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Username, &r.Password)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIpsecUser provide iterator to all rows of the NGFW_IPSEC_USER matching given criteria.
func RangeNgfwIpsecUser(db *sql.DB, where string) iter.Seq2[*NgfwIpsecUserRow, error] {
	return func(yield func(v *NgfwIpsecUserRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,USERNAME,PASSWORD FROM NGFW_IPSEC_USER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIpsecUserRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Username, &r.Password)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIpsecUserConfigRow struct represents rows of the NGFW_IPSEC_USER_CONFIG table.
type NgfwIpsecUserConfigRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    PrimaryDnsNamedIPObjID	sql.NullInt32
    SecondaryDnsNamedIPObjID	sql.NullInt32
    PrimaryWinsNamedIPObjID	sql.NullInt32
    SecondaryWinsNamedIPObjID	sql.NullInt32
}

// IterateNgfwIpsecUserConfig provide access to all rows of the NGFW_IPSEC_USER_CONFIG matching given criteria.
func IterateNgfwIpsecUserConfig(db *sql.DB, where string, callback func(v *NgfwIpsecUserConfigRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,PRIMARY_DNS_NAMED_IP_OBJ_ID,SECONDARY_DNS_NAMED_IP_OBJ_ID,PRIMARY_WINS_NAMED_IP_OBJ_ID,SECONDARY_WINS_NAMED_IP_OBJ_ID FROM NGFW_IPSEC_USER_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIpsecUserConfigRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.PrimaryDnsNamedIPObjID, &r.SecondaryDnsNamedIPObjID, &r.PrimaryWinsNamedIPObjID, &r.SecondaryWinsNamedIPObjID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIpsecUserConfig provide iterator to all rows of the NGFW_IPSEC_USER_CONFIG matching given criteria.
func RangeNgfwIpsecUserConfig(db *sql.DB, where string) iter.Seq2[*NgfwIpsecUserConfigRow, error] {
	return func(yield func(v *NgfwIpsecUserConfigRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,PRIMARY_DNS_NAMED_IP_OBJ_ID,SECONDARY_DNS_NAMED_IP_OBJ_ID,PRIMARY_WINS_NAMED_IP_OBJ_ID,SECONDARY_WINS_NAMED_IP_OBJ_ID FROM NGFW_IPSEC_USER_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIpsecUserConfigRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.PrimaryDnsNamedIPObjID, &r.SecondaryDnsNamedIPObjID, &r.PrimaryWinsNamedIPObjID, &r.SecondaryWinsNamedIPObjID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIpv4AddrArrayRow struct represents rows of the NGFW_IPV4_ADDR_ARRAY table.
type NgfwIpv4AddrArrayRow struct {
    ID	uint
    NgfwDhcpServerArrayID	sql.NullInt32
    IpaddrNamedObjID	int
}

// IterateNgfwIpv4AddrArray provide access to all rows of the NGFW_IPV4_ADDR_ARRAY matching given criteria.
func IterateNgfwIpv4AddrArray(db *sql.DB, where string, callback func(v *NgfwIpv4AddrArrayRow) error) error {
    query := "SELECT ID,NGFW_DHCP_SERVER_ARRAY_ID,IPADDR_NAMED_OBJ_ID FROM NGFW_IPV4_ADDR_ARRAY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIpv4AddrArrayRow
        err := rows.Scan(&r.ID, &r.NgfwDhcpServerArrayID, &r.IpaddrNamedObjID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIpv4AddrArray provide iterator to all rows of the NGFW_IPV4_ADDR_ARRAY matching given criteria.
func RangeNgfwIpv4AddrArray(db *sql.DB, where string) iter.Seq2[*NgfwIpv4AddrArrayRow, error] {
	return func(yield func(v *NgfwIpv4AddrArrayRow, err error) bool) {
	    query := "SELECT ID,NGFW_DHCP_SERVER_ARRAY_ID,IPADDR_NAMED_OBJ_ID FROM NGFW_IPV4_ADDR_ARRAY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIpv4AddrArrayRow
	        err := rows.Scan(&r.ID, &r.NgfwDhcpServerArrayID, &r.IpaddrNamedObjID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwIPSubnetRow struct represents rows of the NGFW_IP_SUBNET table.
type NgfwIPSubnetRow struct {
    ID	uint
    Version	uint
    IPAddr1	int64
    IPAddr2	sql.NullInt64
    Mask	sql.NullInt32
}

// IterateNgfwIPSubnet provide access to all rows of the NGFW_IP_SUBNET matching given criteria.
func IterateNgfwIPSubnet(db *sql.DB, where string, callback func(v *NgfwIPSubnetRow) error) error {
    query := "SELECT ID,VERSION,IP_ADDR_1,IP_ADDR_2,MASK FROM NGFW_IP_SUBNET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwIPSubnetRow
        err := rows.Scan(&r.ID, &r.Version, &r.IPAddr1, &r.IPAddr2, &r.Mask)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwIPSubnet provide iterator to all rows of the NGFW_IP_SUBNET matching given criteria.
func RangeNgfwIPSubnet(db *sql.DB, where string) iter.Seq2[*NgfwIPSubnetRow, error] {
	return func(yield func(v *NgfwIPSubnetRow, err error) bool) {
	    query := "SELECT ID,VERSION,IP_ADDR_1,IP_ADDR_2,MASK FROM NGFW_IP_SUBNET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwIPSubnetRow
	        err := rows.Scan(&r.ID, &r.Version, &r.IPAddr1, &r.IPAddr2, &r.Mask)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwL2tpSettingsRow struct represents rows of the NGFW_L2TP_SETTINGS table.
type NgfwL2tpSettingsRow struct {
    ID	uint
    Version	uint
    DeviceShortID	sql.NullInt32
    Type	sql.NullString
    Enabled	sql.NullByte
    KeepAlive	sql.NullInt32
    UserGroup	string
    LocalIPNamedObjID	int
    LocalIPPoolNamedObjID	sql.NullInt32
    DhcpName	sql.NullString
    PrimaryDnsIPNamedObjID	sql.NullInt32
    SecondaryDnsIPNamedObjID	sql.NullInt32
    PrimaryWinsIPNamedObjID	sql.NullInt32
    SecondaryWinsIPNamedObjID	sql.NullInt32
    DisabledDns	sql.NullByte
    DisabledWins	sql.NullByte
    Proto	string
    Authserver	sql.NullString
}

// IterateNgfwL2tpSettings provide access to all rows of the NGFW_L2TP_SETTINGS matching given criteria.
func IterateNgfwL2tpSettings(db *sql.DB, where string, callback func(v *NgfwL2tpSettingsRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,TYPE,ENABLED,KEEP_ALIVE,USER_GROUP,LOCAL_IP_NAMED_OBJ_ID,LOCAL_IP_POOL_NAMED_OBJ_ID,DHCP_NAME,PRIMARY_DNS_IP_NAMED_OBJ_ID,SECONDARY_DNS_IP_NAMED_OBJ_ID,PRIMARY_WINS_IP_NAMED_OBJ_ID,SECONDARY_WINS_IP_NAMED_OBJ_ID,DISABLED_DNS,DISABLED_WINS,PROTO,AUTHSERVER FROM NGFW_L2TP_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwL2tpSettingsRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Type, &r.Enabled, &r.KeepAlive, &r.UserGroup, &r.LocalIPNamedObjID, &r.LocalIPPoolNamedObjID, &r.DhcpName, &r.PrimaryDnsIPNamedObjID, &r.SecondaryDnsIPNamedObjID, &r.PrimaryWinsIPNamedObjID, &r.SecondaryWinsIPNamedObjID, &r.DisabledDns, &r.DisabledWins, &r.Proto, &r.Authserver)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwL2tpSettings provide iterator to all rows of the NGFW_L2TP_SETTINGS matching given criteria.
func RangeNgfwL2tpSettings(db *sql.DB, where string) iter.Seq2[*NgfwL2tpSettingsRow, error] {
	return func(yield func(v *NgfwL2tpSettingsRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,TYPE,ENABLED,KEEP_ALIVE,USER_GROUP,LOCAL_IP_NAMED_OBJ_ID,LOCAL_IP_POOL_NAMED_OBJ_ID,DHCP_NAME,PRIMARY_DNS_IP_NAMED_OBJ_ID,SECONDARY_DNS_IP_NAMED_OBJ_ID,PRIMARY_WINS_IP_NAMED_OBJ_ID,SECONDARY_WINS_IP_NAMED_OBJ_ID,DISABLED_DNS,DISABLED_WINS,PROTO,AUTHSERVER FROM NGFW_L2TP_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwL2tpSettingsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Type, &r.Enabled, &r.KeepAlive, &r.UserGroup, &r.LocalIPNamedObjID, &r.LocalIPPoolNamedObjID, &r.DhcpName, &r.PrimaryDnsIPNamedObjID, &r.SecondaryDnsIPNamedObjID, &r.PrimaryWinsIPNamedObjID, &r.SecondaryWinsIPNamedObjID, &r.DisabledDns, &r.DisabledWins, &r.Proto, &r.Authserver)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwLdapGroupRow struct represents rows of the NGFW_LDAP_GROUP table.
type NgfwLdapGroupRow struct {
    ID	uint
    Optlock	uint
    DeviceShortID	uint
    Name	string
    Uuid	sql.NullString
    Version	uint16
    Retries	uint16
    Timeout	uint16
    ServerPort	uint
    BindPassword	sql.NullString
    BindDn	sql.NullString
    BaseDn	sql.NullString
    TlsEnabled	int8
    TlsStartEnabled	int8
    TlsRequireServerCertificate	int8
    LocalCertificateDn	sql.NullString
    SchemaType	string
}

// IterateNgfwLdapGroup provide access to all rows of the NGFW_LDAP_GROUP matching given criteria.
func IterateNgfwLdapGroup(db *sql.DB, where string, callback func(v *NgfwLdapGroupRow) error) error {
    query := "SELECT ID,OPTLOCK,DEVICE_SHORT_ID,NAME,UUID,VERSION,RETRIES,TIMEOUT,SERVER_PORT,BIND_PASSWORD,BIND_DN,BASE_DN,TLS_ENABLED,TLS_START_ENABLED,TLS_REQUIRE_SERVER_CERTIFICATE,LOCAL_CERTIFICATE_DN,SCHEMA_TYPE FROM NGFW_LDAP_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwLdapGroupRow
        err := rows.Scan(&r.ID, &r.Optlock, &r.DeviceShortID, &r.Name, &r.Uuid, &r.Version, &r.Retries, &r.Timeout, &r.ServerPort, &r.BindPassword, &r.BindDn, &r.BaseDn, &r.TlsEnabled, &r.TlsStartEnabled, &r.TlsRequireServerCertificate, &r.LocalCertificateDn, &r.SchemaType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwLdapGroup provide iterator to all rows of the NGFW_LDAP_GROUP matching given criteria.
func RangeNgfwLdapGroup(db *sql.DB, where string) iter.Seq2[*NgfwLdapGroupRow, error] {
	return func(yield func(v *NgfwLdapGroupRow, err error) bool) {
	    query := "SELECT ID,OPTLOCK,DEVICE_SHORT_ID,NAME,UUID,VERSION,RETRIES,TIMEOUT,SERVER_PORT,BIND_PASSWORD,BIND_DN,BASE_DN,TLS_ENABLED,TLS_START_ENABLED,TLS_REQUIRE_SERVER_CERTIFICATE,LOCAL_CERTIFICATE_DN,SCHEMA_TYPE FROM NGFW_LDAP_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwLdapGroupRow
	        err := rows.Scan(&r.ID, &r.Optlock, &r.DeviceShortID, &r.Name, &r.Uuid, &r.Version, &r.Retries, &r.Timeout, &r.ServerPort, &r.BindPassword, &r.BindDn, &r.BaseDn, &r.TlsEnabled, &r.TlsStartEnabled, &r.TlsRequireServerCertificate, &r.LocalCertificateDn, &r.SchemaType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwLdapSchemaEntryRow struct represents rows of the NGFW_LDAP_SCHEMA_ENTRY table.
type NgfwLdapSchemaEntryRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    SchemaType	string
    SchemaPosixAccount	sql.NullString
    SchemaCn	sql.NullString
    SchemaUid	sql.NullString
    SchemaPosixGroup	sql.NullString
    SchemaUniqueMember	sql.NullString
    SchemaLoginAttribute	sql.NullString
    SchemaFilter	sql.NullString
}

// IterateNgfwLdapSchemaEntry provide access to all rows of the NGFW_LDAP_SCHEMA_ENTRY matching given criteria.
func IterateNgfwLdapSchemaEntry(db *sql.DB, where string, callback func(v *NgfwLdapSchemaEntryRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,SCHEMA_TYPE,SCHEMA_POSIX_ACCOUNT,SCHEMA_CN,SCHEMA_UID,SCHEMA_POSIX_GROUP,SCHEMA_UNIQUE_MEMBER,SCHEMA_LOGIN_ATTRIBUTE,SCHEMA_FILTER FROM NGFW_LDAP_SCHEMA_ENTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwLdapSchemaEntryRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.SchemaType, &r.SchemaPosixAccount, &r.SchemaCn, &r.SchemaUid, &r.SchemaPosixGroup, &r.SchemaUniqueMember, &r.SchemaLoginAttribute, &r.SchemaFilter)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwLdapSchemaEntry provide iterator to all rows of the NGFW_LDAP_SCHEMA_ENTRY matching given criteria.
func RangeNgfwLdapSchemaEntry(db *sql.DB, where string) iter.Seq2[*NgfwLdapSchemaEntryRow, error] {
	return func(yield func(v *NgfwLdapSchemaEntryRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,SCHEMA_TYPE,SCHEMA_POSIX_ACCOUNT,SCHEMA_CN,SCHEMA_UID,SCHEMA_POSIX_GROUP,SCHEMA_UNIQUE_MEMBER,SCHEMA_LOGIN_ATTRIBUTE,SCHEMA_FILTER FROM NGFW_LDAP_SCHEMA_ENTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwLdapSchemaEntryRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.SchemaType, &r.SchemaPosixAccount, &r.SchemaCn, &r.SchemaUid, &r.SchemaPosixGroup, &r.SchemaUniqueMember, &r.SchemaLoginAttribute, &r.SchemaFilter)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwLdapServerRow struct represents rows of the NGFW_LDAP_SERVER table.
type NgfwLdapServerRow struct {
    ID	uint
    Version	uint
    Priority	uint16
    ServerIPNamedObjID	sql.NullInt32
    ServerName	sql.NullString
    LdapGroup	uint
}

// IterateNgfwLdapServer provide access to all rows of the NGFW_LDAP_SERVER matching given criteria.
func IterateNgfwLdapServer(db *sql.DB, where string, callback func(v *NgfwLdapServerRow) error) error {
    query := "SELECT ID,VERSION,PRIORITY,SERVER_IP_NAMED_OBJ_ID,SERVER_NAME,LDAP_GROUP FROM NGFW_LDAP_SERVER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwLdapServerRow
        err := rows.Scan(&r.ID, &r.Version, &r.Priority, &r.ServerIPNamedObjID, &r.ServerName, &r.LdapGroup)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwLdapServer provide iterator to all rows of the NGFW_LDAP_SERVER matching given criteria.
func RangeNgfwLdapServer(db *sql.DB, where string) iter.Seq2[*NgfwLdapServerRow, error] {
	return func(yield func(v *NgfwLdapServerRow, err error) bool) {
	    query := "SELECT ID,VERSION,PRIORITY,SERVER_IP_NAMED_OBJ_ID,SERVER_NAME,LDAP_GROUP FROM NGFW_LDAP_SERVER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwLdapServerRow
	        err := rows.Scan(&r.ID, &r.Version, &r.Priority, &r.ServerIPNamedObjID, &r.ServerName, &r.LdapGroup)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwLocalUserRow struct represents rows of the NGFW_LOCAL_USER table.
type NgfwLocalUserRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Name	sql.NullString
    PasswordSetEpochTime	sql.NullInt32
    Enabled	int8
    DeviceUser	int8
}

// IterateNgfwLocalUser provide access to all rows of the NGFW_LOCAL_USER matching given criteria.
func IterateNgfwLocalUser(db *sql.DB, where string, callback func(v *NgfwLocalUserRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME,PASSWORD_SET_EPOCH_TIME,ENABLED,DEVICE_USER FROM NGFW_LOCAL_USER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwLocalUserRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Name, &r.PasswordSetEpochTime, &r.Enabled, &r.DeviceUser)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwLocalUser provide iterator to all rows of the NGFW_LOCAL_USER matching given criteria.
func RangeNgfwLocalUser(db *sql.DB, where string) iter.Seq2[*NgfwLocalUserRow, error] {
	return func(yield func(v *NgfwLocalUserRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME,PASSWORD_SET_EPOCH_TIME,ENABLED,DEVICE_USER FROM NGFW_LOCAL_USER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwLocalUserRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Name, &r.PasswordSetEpochTime, &r.Enabled, &r.DeviceUser)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwLogEncriptionEnableRow struct represents rows of the NGFW_LOG_ENCRIPTION_ENABLE table.
type NgfwLogEncriptionEnableRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Enabled	int8
    MasterKey	sql.NullString
    MasterKeyEnc	sql.NullString
    DeviceKeyEnable	int8
}

// IterateNgfwLogEncriptionEnable provide access to all rows of the NGFW_LOG_ENCRIPTION_ENABLE matching given criteria.
func IterateNgfwLogEncriptionEnable(db *sql.DB, where string, callback func(v *NgfwLogEncriptionEnableRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLED,MASTER_KEY,MASTER_KEY_ENC,DEVICE_KEY_ENABLE FROM NGFW_LOG_ENCRIPTION_ENABLE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwLogEncriptionEnableRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enabled, &r.MasterKey, &r.MasterKeyEnc, &r.DeviceKeyEnable)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwLogEncriptionEnable provide iterator to all rows of the NGFW_LOG_ENCRIPTION_ENABLE matching given criteria.
func RangeNgfwLogEncriptionEnable(db *sql.DB, where string) iter.Seq2[*NgfwLogEncriptionEnableRow, error] {
	return func(yield func(v *NgfwLogEncriptionEnableRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLED,MASTER_KEY,MASTER_KEY_ENC,DEVICE_KEY_ENABLE FROM NGFW_LOG_ENCRIPTION_ENABLE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwLogEncriptionEnableRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enabled, &r.MasterKey, &r.MasterKeyEnc, &r.DeviceKeyEnable)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwLogServiceConfigRow struct represents rows of the NGFW_LOG_SERVICE_CONFIG table.
type NgfwLogServiceConfigRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    LogType	string
    Severity	string
    NotificationContact	string
}

// IterateNgfwLogServiceConfig provide access to all rows of the NGFW_LOG_SERVICE_CONFIG matching given criteria.
func IterateNgfwLogServiceConfig(db *sql.DB, where string, callback func(v *NgfwLogServiceConfigRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,LOG_TYPE,SEVERITY,NOTIFICATION_CONTACT FROM NGFW_LOG_SERVICE_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwLogServiceConfigRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.LogType, &r.Severity, &r.NotificationContact)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwLogServiceConfig provide iterator to all rows of the NGFW_LOG_SERVICE_CONFIG matching given criteria.
func RangeNgfwLogServiceConfig(db *sql.DB, where string) iter.Seq2[*NgfwLogServiceConfigRow, error] {
	return func(yield func(v *NgfwLogServiceConfigRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,LOG_TYPE,SEVERITY,NOTIFICATION_CONTACT FROM NGFW_LOG_SERVICE_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwLogServiceConfigRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.LogType, &r.Severity, &r.NotificationContact)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwManualSaRow struct represents rows of the NGFW_MANUAL_SA table.
type NgfwManualSaRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    SaType	sql.NullString
    SrcAddrNamedObjID	int
    DstAddrNamedObjID	int
    DstAddrNamedObjAddressBlock	string
    Spi	sql.NullInt32
    Mode	string
    SaIntegrity	sql.NullString
    AuthKey	[]byte
    Aencryption	sql.NullString
    EncryptionKey	[]byte
    AsciiAuthKey	sql.NullString
    AsciiEncryptionKey	sql.NullString
}

// IterateNgfwManualSa provide access to all rows of the NGFW_MANUAL_SA matching given criteria.
func IterateNgfwManualSa(db *sql.DB, where string, callback func(v *NgfwManualSaRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,SA_TYPE,SRC_ADDR_NAMED_OBJ_ID,DST_ADDR_NAMED_OBJ_ID,DST_ADDR_NAMED_OBJ_ADDRESS_BLOCK,SPI,MODE,SA_INTEGRITY,AUTH_KEY,AENCRYPTION,ENCRYPTION_KEY,ASCII_AUTH_KEY,ASCII_ENCRYPTION_KEY FROM NGFW_MANUAL_SA"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwManualSaRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.SaType, &r.SrcAddrNamedObjID, &r.DstAddrNamedObjID, &r.DstAddrNamedObjAddressBlock, &r.Spi, &r.Mode, &r.SaIntegrity, &r.AuthKey, &r.Aencryption, &r.EncryptionKey, &r.AsciiAuthKey, &r.AsciiEncryptionKey)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwManualSa provide iterator to all rows of the NGFW_MANUAL_SA matching given criteria.
func RangeNgfwManualSa(db *sql.DB, where string) iter.Seq2[*NgfwManualSaRow, error] {
	return func(yield func(v *NgfwManualSaRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,SA_TYPE,SRC_ADDR_NAMED_OBJ_ID,DST_ADDR_NAMED_OBJ_ID,DST_ADDR_NAMED_OBJ_ADDRESS_BLOCK,SPI,MODE,SA_INTEGRITY,AUTH_KEY,AENCRYPTION,ENCRYPTION_KEY,ASCII_AUTH_KEY,ASCII_ENCRYPTION_KEY FROM NGFW_MANUAL_SA"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwManualSaRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.SaType, &r.SrcAddrNamedObjID, &r.DstAddrNamedObjID, &r.DstAddrNamedObjAddressBlock, &r.Spi, &r.Mode, &r.SaIntegrity, &r.AuthKey, &r.Aencryption, &r.EncryptionKey, &r.AsciiAuthKey, &r.AsciiEncryptionKey)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwMaxValueEntryRow struct represents rows of the NGFW_MAX_VALUE_ENTRY table.
type NgfwMaxValueEntryRow struct {
    ID	uint
    DeviceShortID	uint
    MaxValue	uint
    ValueType	string
    Version	uint
}

// IterateNgfwMaxValueEntry provide access to all rows of the NGFW_MAX_VALUE_ENTRY matching given criteria.
func IterateNgfwMaxValueEntry(db *sql.DB, where string, callback func(v *NgfwMaxValueEntryRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,MAX_VALUE,VALUE_TYPE,VERSION FROM NGFW_MAX_VALUE_ENTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwMaxValueEntryRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.MaxValue, &r.ValueType, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwMaxValueEntry provide iterator to all rows of the NGFW_MAX_VALUE_ENTRY matching given criteria.
func RangeNgfwMaxValueEntry(db *sql.DB, where string) iter.Seq2[*NgfwMaxValueEntryRow, error] {
	return func(yield func(v *NgfwMaxValueEntryRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,MAX_VALUE,VALUE_TYPE,VERSION FROM NGFW_MAX_VALUE_ENTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwMaxValueEntryRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.MaxValue, &r.ValueType, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwMgmtInterfaceFilterCfgRow struct represents rows of the NGFW_MGMT_INTERFACE_FILTER_CFG table.
type NgfwMgmtInterfaceFilterCfgRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    DefaultAction	string
}

// IterateNgfwMgmtInterfaceFilterCfg provide access to all rows of the NGFW_MGMT_INTERFACE_FILTER_CFG matching given criteria.
func IterateNgfwMgmtInterfaceFilterCfg(db *sql.DB, where string, callback func(v *NgfwMgmtInterfaceFilterCfgRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,DEFAULT_ACTION FROM NGFW_MGMT_INTERFACE_FILTER_CFG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwMgmtInterfaceFilterCfgRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.DefaultAction)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwMgmtInterfaceFilterCfg provide iterator to all rows of the NGFW_MGMT_INTERFACE_FILTER_CFG matching given criteria.
func RangeNgfwMgmtInterfaceFilterCfg(db *sql.DB, where string) iter.Seq2[*NgfwMgmtInterfaceFilterCfgRow, error] {
	return func(yield func(v *NgfwMgmtInterfaceFilterCfgRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,DEFAULT_ACTION FROM NGFW_MGMT_INTERFACE_FILTER_CFG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwMgmtInterfaceFilterCfgRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.DefaultAction)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwMgmtInterfaceFilterRuleRow struct represents rows of the NGFW_MGMT_INTERFACE_FILTER_RULE table.
type NgfwMgmtInterfaceFilterRuleRow struct {
    ID	uint
    SubnetNamedObjID	sql.NullInt32
    Service	string
    RuleAction	string
    NgfwMgmtInterfaceFilterCfgID	sql.NullInt32
}

// IterateNgfwMgmtInterfaceFilterRule provide access to all rows of the NGFW_MGMT_INTERFACE_FILTER_RULE matching given criteria.
func IterateNgfwMgmtInterfaceFilterRule(db *sql.DB, where string, callback func(v *NgfwMgmtInterfaceFilterRuleRow) error) error {
    query := "SELECT ID,SUBNET_NAMED_OBJ_ID,SERVICE,RULE_ACTION,NGFW_MGMT_INTERFACE_FILTER_CFG_ID FROM NGFW_MGMT_INTERFACE_FILTER_RULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwMgmtInterfaceFilterRuleRow
        err := rows.Scan(&r.ID, &r.SubnetNamedObjID, &r.Service, &r.RuleAction, &r.NgfwMgmtInterfaceFilterCfgID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwMgmtInterfaceFilterRule provide iterator to all rows of the NGFW_MGMT_INTERFACE_FILTER_RULE matching given criteria.
func RangeNgfwMgmtInterfaceFilterRule(db *sql.DB, where string) iter.Seq2[*NgfwMgmtInterfaceFilterRuleRow, error] {
	return func(yield func(v *NgfwMgmtInterfaceFilterRuleRow, err error) bool) {
	    query := "SELECT ID,SUBNET_NAMED_OBJ_ID,SERVICE,RULE_ACTION,NGFW_MGMT_INTERFACE_FILTER_CFG_ID FROM NGFW_MGMT_INTERFACE_FILTER_RULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwMgmtInterfaceFilterRuleRow
	        err := rows.Scan(&r.ID, &r.SubnetNamedObjID, &r.Service, &r.RuleAction, &r.NgfwMgmtInterfaceFilterCfgID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwMgmtServersRow struct represents rows of the NGFW_MGMT_SERVERS table.
type NgfwMgmtServersRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    SshEnabled	int8
    HttpsEnabled	int8
    SnmpEnabled	int8
    InbandMgmtEnabled	int8
    InbandDnsEnabled	int8
    InbandEmailEnabled	int8
    InbandLdapEnabled	int8
    InbandRadiusEnabled	int8
    InbandNtpEnabled	int8
    InbandRsyslogEnabled	int8
    InbandIdentityAgentEnabled	int8
}

// IterateNgfwMgmtServers provide access to all rows of the NGFW_MGMT_SERVERS matching given criteria.
func IterateNgfwMgmtServers(db *sql.DB, where string, callback func(v *NgfwMgmtServersRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,SSH_ENABLED,HTTPS_ENABLED,SNMP_ENABLED,INBAND_MGMT_ENABLED,INBAND_DNS_ENABLED,INBAND_EMAIL_ENABLED,INBAND_LDAP_ENABLED,INBAND_RADIUS_ENABLED,INBAND_NTP_ENABLED,INBAND_RSYSLOG_ENABLED,INBAND_IDENTITY_AGENT_ENABLED FROM NGFW_MGMT_SERVERS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwMgmtServersRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.SshEnabled, &r.HttpsEnabled, &r.SnmpEnabled, &r.InbandMgmtEnabled, &r.InbandDnsEnabled, &r.InbandEmailEnabled, &r.InbandLdapEnabled, &r.InbandRadiusEnabled, &r.InbandNtpEnabled, &r.InbandRsyslogEnabled, &r.InbandIdentityAgentEnabled)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwMgmtServers provide iterator to all rows of the NGFW_MGMT_SERVERS matching given criteria.
func RangeNgfwMgmtServers(db *sql.DB, where string) iter.Seq2[*NgfwMgmtServersRow, error] {
	return func(yield func(v *NgfwMgmtServersRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,SSH_ENABLED,HTTPS_ENABLED,SNMP_ENABLED,INBAND_MGMT_ENABLED,INBAND_DNS_ENABLED,INBAND_EMAIL_ENABLED,INBAND_LDAP_ENABLED,INBAND_RADIUS_ENABLED,INBAND_NTP_ENABLED,INBAND_RSYSLOG_ENABLED,INBAND_IDENTITY_AGENT_ENABLED FROM NGFW_MGMT_SERVERS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwMgmtServersRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.SshEnabled, &r.HttpsEnabled, &r.SnmpEnabled, &r.InbandMgmtEnabled, &r.InbandDnsEnabled, &r.InbandEmailEnabled, &r.InbandLdapEnabled, &r.InbandRadiusEnabled, &r.InbandNtpEnabled, &r.InbandRsyslogEnabled, &r.InbandIdentityAgentEnabled)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwMldInterfaceRow struct represents rows of the NGFW_MLD_INTERFACE table.
type NgfwMldInterfaceRow struct {
    ID	uint
    Version	uint
    DeviceShortID	sql.NullInt32
    Enable	sql.NullByte
    MldVersion	sql.NullString
    InterfaceBaseID	sql.NullInt32
}

// IterateNgfwMldInterface provide access to all rows of the NGFW_MLD_INTERFACE matching given criteria.
func IterateNgfwMldInterface(db *sql.DB, where string, callback func(v *NgfwMldInterfaceRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLE,MLD_VERSION,INTERFACE_BASE_ID FROM NGFW_MLD_INTERFACE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwMldInterfaceRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enable, &r.MldVersion, &r.InterfaceBaseID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwMldInterface provide iterator to all rows of the NGFW_MLD_INTERFACE matching given criteria.
func RangeNgfwMldInterface(db *sql.DB, where string) iter.Seq2[*NgfwMldInterfaceRow, error] {
	return func(yield func(v *NgfwMldInterfaceRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLE,MLD_VERSION,INTERFACE_BASE_ID FROM NGFW_MLD_INTERFACE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwMldInterfaceRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enable, &r.MldVersion, &r.InterfaceBaseID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwMulticastGroupRangeRow struct represents rows of the NGFW_MULTICAST_GROUP_RANGE table.
type NgfwMulticastGroupRangeRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    ParentType	sql.NullString
    SubnetIpaddr	sql.NullString
    Maskbits	sql.NullInt32
}

// IterateNgfwMulticastGroupRange provide access to all rows of the NGFW_MULTICAST_GROUP_RANGE matching given criteria.
func IterateNgfwMulticastGroupRange(db *sql.DB, where string, callback func(v *NgfwMulticastGroupRangeRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,PARENT_TYPE,SUBNET_IPADDR,MASKBITS FROM NGFW_MULTICAST_GROUP_RANGE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwMulticastGroupRangeRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.ParentType, &r.SubnetIpaddr, &r.Maskbits)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwMulticastGroupRange provide iterator to all rows of the NGFW_MULTICAST_GROUP_RANGE matching given criteria.
func RangeNgfwMulticastGroupRange(db *sql.DB, where string) iter.Seq2[*NgfwMulticastGroupRangeRow, error] {
	return func(yield func(v *NgfwMulticastGroupRangeRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,PARENT_TYPE,SUBNET_IPADDR,MASKBITS FROM NGFW_MULTICAST_GROUP_RANGE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwMulticastGroupRangeRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.ParentType, &r.SubnetIpaddr, &r.Maskbits)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwNdpEntryRow struct represents rows of the NGFW_NDP_ENTRY table.
type NgfwNdpEntryRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    IPV6NamedObjID	int
    IPV6NamedObjAddressBlock	string
    EntryState	sql.NullString
    InterfaceBaseID	sql.NullInt32
    MacAddr	uint64
}

// IterateNgfwNdpEntry provide access to all rows of the NGFW_NDP_ENTRY matching given criteria.
func IterateNgfwNdpEntry(db *sql.DB, where string, callback func(v *NgfwNdpEntryRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,IP_V6_NAMED_OBJ_ID,IP_V6_NAMED_OBJ_ADDRESS_BLOCK,ENTRY_STATE,INTERFACE_BASE_ID,MAC_ADDR FROM NGFW_NDP_ENTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwNdpEntryRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.IPV6NamedObjID, &r.IPV6NamedObjAddressBlock, &r.EntryState, &r.InterfaceBaseID, &r.MacAddr)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwNdpEntry provide iterator to all rows of the NGFW_NDP_ENTRY matching given criteria.
func RangeNgfwNdpEntry(db *sql.DB, where string) iter.Seq2[*NgfwNdpEntryRow, error] {
	return func(yield func(v *NgfwNdpEntryRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,IP_V6_NAMED_OBJ_ID,IP_V6_NAMED_OBJ_ADDRESS_BLOCK,ENTRY_STATE,INTERFACE_BASE_ID,MAC_ADDR FROM NGFW_NDP_ENTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwNdpEntryRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.IPV6NamedObjID, &r.IPV6NamedObjAddressBlock, &r.EntryState, &r.InterfaceBaseID, &r.MacAddr)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwNtpRow struct represents rows of the NGFW_NTP table.
type NgfwNtpRow struct {
    ID	uint
    DeviceShortID	uint
    Version	uint
    Enabled	sql.NullByte
    AuthEnabled	sql.NullByte
    PollingPeriod	string
}

// IterateNgfwNtp provide access to all rows of the NGFW_NTP matching given criteria.
func IterateNgfwNtp(db *sql.DB, where string, callback func(v *NgfwNtpRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,VERSION,ENABLED,AUTH_ENABLED,POLLING_PERIOD FROM NGFW_NTP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwNtpRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Version, &r.Enabled, &r.AuthEnabled, &r.PollingPeriod)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwNtp provide iterator to all rows of the NGFW_NTP matching given criteria.
func RangeNgfwNtp(db *sql.DB, where string) iter.Seq2[*NgfwNtpRow, error] {
	return func(yield func(v *NgfwNtpRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,VERSION,ENABLED,AUTH_ENABLED,POLLING_PERIOD FROM NGFW_NTP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwNtpRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Version, &r.Enabled, &r.AuthEnabled, &r.PollingPeriod)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwNtpKeyRow struct represents rows of the NGFW_NTP_KEY table.
type NgfwNtpKeyRow struct {
    ID	uint
    Value	sql.NullString
    KeyIndex	sql.NullInt32
    NgfwNtpID	sql.NullInt32
}

// IterateNgfwNtpKey provide access to all rows of the NGFW_NTP_KEY matching given criteria.
func IterateNgfwNtpKey(db *sql.DB, where string, callback func(v *NgfwNtpKeyRow) error) error {
    query := "SELECT ID,VALUE,KEY_INDEX,NGFW_NTP_ID FROM NGFW_NTP_KEY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwNtpKeyRow
        err := rows.Scan(&r.ID, &r.Value, &r.KeyIndex, &r.NgfwNtpID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwNtpKey provide iterator to all rows of the NGFW_NTP_KEY matching given criteria.
func RangeNgfwNtpKey(db *sql.DB, where string) iter.Seq2[*NgfwNtpKeyRow, error] {
	return func(yield func(v *NgfwNtpKeyRow, err error) bool) {
	    query := "SELECT ID,VALUE,KEY_INDEX,NGFW_NTP_ID FROM NGFW_NTP_KEY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwNtpKeyRow
	        err := rows.Scan(&r.ID, &r.Value, &r.KeyIndex, &r.NgfwNtpID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwNtpServerRow struct represents rows of the NGFW_NTP_SERVER table.
type NgfwNtpServerRow struct {
    ID	uint
    Name	sql.NullString
    Version	sql.NullInt32
    Preferred	sql.NullByte
    IpaddrNamedObjID	sql.NullInt32
    KeyIdx	sql.NullInt32
    NgfwNtpID	sql.NullInt32
}

// IterateNgfwNtpServer provide access to all rows of the NGFW_NTP_SERVER matching given criteria.
func IterateNgfwNtpServer(db *sql.DB, where string, callback func(v *NgfwNtpServerRow) error) error {
    query := "SELECT ID,NAME,VERSION,PREFERRED,IPADDR_NAMED_OBJ_ID,KEY_IDX,NGFW_NTP_ID FROM NGFW_NTP_SERVER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwNtpServerRow
        err := rows.Scan(&r.ID, &r.Name, &r.Version, &r.Preferred, &r.IpaddrNamedObjID, &r.KeyIdx, &r.NgfwNtpID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwNtpServer provide iterator to all rows of the NGFW_NTP_SERVER matching given criteria.
func RangeNgfwNtpServer(db *sql.DB, where string) iter.Seq2[*NgfwNtpServerRow, error] {
	return func(yield func(v *NgfwNtpServerRow, err error) bool) {
	    query := "SELECT ID,NAME,VERSION,PREFERRED,IPADDR_NAMED_OBJ_ID,KEY_IDX,NGFW_NTP_ID FROM NGFW_NTP_SERVER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwNtpServerRow
	        err := rows.Scan(&r.ID, &r.Name, &r.Version, &r.Preferred, &r.IpaddrNamedObjID, &r.KeyIdx, &r.NgfwNtpID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwOspfv2GeneralRow struct represents rows of the NGFW_OSPFV2_GENERAL table.
type NgfwOspfv2GeneralRow struct {
    DeviceShortID	uint
    Version	sql.NullInt32
    EnableFlag	sql.NullByte
    Rfc1583CompatibilityFlag	sql.NullByte
    RouterID	sql.NullInt32
    Distance	sql.NullInt32
    IntraAreaDistance	sql.NullInt32
    InterAreaDistance	sql.NullInt32
    ExternalDistance	sql.NullInt32
    DefaultMetric	sql.NullInt32
}

// IterateNgfwOspfv2General provide access to all rows of the NGFW_OSPFV2_GENERAL matching given criteria.
func IterateNgfwOspfv2General(db *sql.DB, where string, callback func(v *NgfwOspfv2GeneralRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,VERSION,ENABLE_FLAG,RFC1583_COMPATIBILITY_FLAG,ROUTER_ID,DISTANCE,INTRA_AREA_DISTANCE,INTER_AREA_DISTANCE,EXTERNAL_DISTANCE,DEFAULT_METRIC FROM NGFW_OSPFV2_GENERAL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwOspfv2GeneralRow
        err := rows.Scan(&r.DeviceShortID, &r.Version, &r.EnableFlag, &r.Rfc1583CompatibilityFlag, &r.RouterID, &r.Distance, &r.IntraAreaDistance, &r.InterAreaDistance, &r.ExternalDistance, &r.DefaultMetric)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwOspfv2General provide iterator to all rows of the NGFW_OSPFV2_GENERAL matching given criteria.
func RangeNgfwOspfv2General(db *sql.DB, where string) iter.Seq2[*NgfwOspfv2GeneralRow, error] {
	return func(yield func(v *NgfwOspfv2GeneralRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,VERSION,ENABLE_FLAG,RFC1583_COMPATIBILITY_FLAG,ROUTER_ID,DISTANCE,INTRA_AREA_DISTANCE,INTER_AREA_DISTANCE,EXTERNAL_DISTANCE,DEFAULT_METRIC FROM NGFW_OSPFV2_GENERAL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwOspfv2GeneralRow
	        err := rows.Scan(&r.DeviceShortID, &r.Version, &r.EnableFlag, &r.Rfc1583CompatibilityFlag, &r.RouterID, &r.Distance, &r.IntraAreaDistance, &r.InterAreaDistance, &r.ExternalDistance, &r.DefaultMetric)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwOspfv2GeneralRedistributesRow struct represents rows of the NGFW_OSPFV2_GENERAL_REDISTRIBUTES table.
type NgfwOspfv2GeneralRedistributesRow struct {
    NgfwOspfv2GeneralDeviceID	uint
    NgfwOspfRedistributeID	uint
}

// IterateNgfwOspfv2GeneralRedistributes provide access to all rows of the NGFW_OSPFV2_GENERAL_REDISTRIBUTES matching given criteria.
func IterateNgfwOspfv2GeneralRedistributes(db *sql.DB, where string, callback func(v *NgfwOspfv2GeneralRedistributesRow) error) error {
    query := "SELECT NGFW_OSPFV2_GENERAL_DEVICE_ID,NGFW_OSPF_REDISTRIBUTE_ID FROM NGFW_OSPFV2_GENERAL_REDISTRIBUTES"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwOspfv2GeneralRedistributesRow
        err := rows.Scan(&r.NgfwOspfv2GeneralDeviceID, &r.NgfwOspfRedistributeID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwOspfv2GeneralRedistributes provide iterator to all rows of the NGFW_OSPFV2_GENERAL_REDISTRIBUTES matching given criteria.
func RangeNgfwOspfv2GeneralRedistributes(db *sql.DB, where string) iter.Seq2[*NgfwOspfv2GeneralRedistributesRow, error] {
	return func(yield func(v *NgfwOspfv2GeneralRedistributesRow, err error) bool) {
	    query := "SELECT NGFW_OSPFV2_GENERAL_DEVICE_ID,NGFW_OSPF_REDISTRIBUTE_ID FROM NGFW_OSPFV2_GENERAL_REDISTRIBUTES"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwOspfv2GeneralRedistributesRow
	        err := rows.Scan(&r.NgfwOspfv2GeneralDeviceID, &r.NgfwOspfRedistributeID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwOspfv2InterfaceRow struct represents rows of the NGFW_OSPFV2_INTERFACE table.
type NgfwOspfv2InterfaceRow struct {
    ID	uint
    Version	uint
    DeviceShortID	sql.NullInt32
    AreaID	uint
    InterfaceBaseID	uint
    Priority	sql.NullInt32
    OspfEnable	sql.NullByte
    Passive	sql.NullByte
    Cost	sql.NullInt32
    HelloInterval	sql.NullInt32
    DeadInterval	sql.NullInt32
    RetransmitInterval	sql.NullInt32
    TransmitDelay	sql.NullInt32
    AuthenticationType	sql.NullString
    SimplePasswd	sql.NullString
    SimplePasswdLen	sql.NullInt32
    Md5Passwd	sql.NullString
    Md5PasswdLen	sql.NullInt32
    Md5KeyID	sql.NullInt32
    InboundNgfwAccessListID	sql.NullInt32
}

// IterateNgfwOspfv2Interface provide access to all rows of the NGFW_OSPFV2_INTERFACE matching given criteria.
func IterateNgfwOspfv2Interface(db *sql.DB, where string, callback func(v *NgfwOspfv2InterfaceRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,AREA_ID,INTERFACE_BASE_ID,PRIORITY,OSPF_ENABLE,PASSIVE,COST,HELLO_INTERVAL,DEAD_INTERVAL,RETRANSMIT_INTERVAL,TRANSMIT_DELAY,AUTHENTICATION_TYPE,SIMPLE_PASSWD,SIMPLE_PASSWD_LEN,MD5_PASSWD,MD5_PASSWD_LEN,MD5_KEY_ID,INBOUND_NGFW_ACCESS_LIST_ID FROM NGFW_OSPFV2_INTERFACE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwOspfv2InterfaceRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.AreaID, &r.InterfaceBaseID, &r.Priority, &r.OspfEnable, &r.Passive, &r.Cost, &r.HelloInterval, &r.DeadInterval, &r.RetransmitInterval, &r.TransmitDelay, &r.AuthenticationType, &r.SimplePasswd, &r.SimplePasswdLen, &r.Md5Passwd, &r.Md5PasswdLen, &r.Md5KeyID, &r.InboundNgfwAccessListID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwOspfv2Interface provide iterator to all rows of the NGFW_OSPFV2_INTERFACE matching given criteria.
func RangeNgfwOspfv2Interface(db *sql.DB, where string) iter.Seq2[*NgfwOspfv2InterfaceRow, error] {
	return func(yield func(v *NgfwOspfv2InterfaceRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,AREA_ID,INTERFACE_BASE_ID,PRIORITY,OSPF_ENABLE,PASSIVE,COST,HELLO_INTERVAL,DEAD_INTERVAL,RETRANSMIT_INTERVAL,TRANSMIT_DELAY,AUTHENTICATION_TYPE,SIMPLE_PASSWD,SIMPLE_PASSWD_LEN,MD5_PASSWD,MD5_PASSWD_LEN,MD5_KEY_ID,INBOUND_NGFW_ACCESS_LIST_ID FROM NGFW_OSPFV2_INTERFACE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwOspfv2InterfaceRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.AreaID, &r.InterfaceBaseID, &r.Priority, &r.OspfEnable, &r.Passive, &r.Cost, &r.HelloInterval, &r.DeadInterval, &r.RetransmitInterval, &r.TransmitDelay, &r.AuthenticationType, &r.SimplePasswd, &r.SimplePasswdLen, &r.Md5Passwd, &r.Md5PasswdLen, &r.Md5KeyID, &r.InboundNgfwAccessListID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwOspfv3GeneralRow struct represents rows of the NGFW_OSPFV3_GENERAL table.
type NgfwOspfv3GeneralRow struct {
    DeviceShortID	uint
    Version	uint
    EnableFlag	sql.NullByte
    RouterID	sql.NullInt64
}

// IterateNgfwOspfv3General provide access to all rows of the NGFW_OSPFV3_GENERAL matching given criteria.
func IterateNgfwOspfv3General(db *sql.DB, where string, callback func(v *NgfwOspfv3GeneralRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,VERSION,ENABLE_FLAG,ROUTER_ID FROM NGFW_OSPFV3_GENERAL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwOspfv3GeneralRow
        err := rows.Scan(&r.DeviceShortID, &r.Version, &r.EnableFlag, &r.RouterID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwOspfv3General provide iterator to all rows of the NGFW_OSPFV3_GENERAL matching given criteria.
func RangeNgfwOspfv3General(db *sql.DB, where string) iter.Seq2[*NgfwOspfv3GeneralRow, error] {
	return func(yield func(v *NgfwOspfv3GeneralRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,VERSION,ENABLE_FLAG,ROUTER_ID FROM NGFW_OSPFV3_GENERAL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwOspfv3GeneralRow
	        err := rows.Scan(&r.DeviceShortID, &r.Version, &r.EnableFlag, &r.RouterID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwOspfv3GeneralRedistributesRow struct represents rows of the NGFW_OSPFV3_GENERAL_REDISTRIBUTES table.
type NgfwOspfv3GeneralRedistributesRow struct {
    NgfwOspfv3GeneralDeviceID	uint
    NgfwOspfRedistributeID	uint
}

// IterateNgfwOspfv3GeneralRedistributes provide access to all rows of the NGFW_OSPFV3_GENERAL_REDISTRIBUTES matching given criteria.
func IterateNgfwOspfv3GeneralRedistributes(db *sql.DB, where string, callback func(v *NgfwOspfv3GeneralRedistributesRow) error) error {
    query := "SELECT NGFW_OSPFV3_GENERAL_DEVICE_ID,NGFW_OSPF_REDISTRIBUTE_ID FROM NGFW_OSPFV3_GENERAL_REDISTRIBUTES"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwOspfv3GeneralRedistributesRow
        err := rows.Scan(&r.NgfwOspfv3GeneralDeviceID, &r.NgfwOspfRedistributeID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwOspfv3GeneralRedistributes provide iterator to all rows of the NGFW_OSPFV3_GENERAL_REDISTRIBUTES matching given criteria.
func RangeNgfwOspfv3GeneralRedistributes(db *sql.DB, where string) iter.Seq2[*NgfwOspfv3GeneralRedistributesRow, error] {
	return func(yield func(v *NgfwOspfv3GeneralRedistributesRow, err error) bool) {
	    query := "SELECT NGFW_OSPFV3_GENERAL_DEVICE_ID,NGFW_OSPF_REDISTRIBUTE_ID FROM NGFW_OSPFV3_GENERAL_REDISTRIBUTES"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwOspfv3GeneralRedistributesRow
	        err := rows.Scan(&r.NgfwOspfv3GeneralDeviceID, &r.NgfwOspfRedistributeID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwOspfv3InterfaceRow struct represents rows of the NGFW_OSPFV3_INTERFACE table.
type NgfwOspfv3InterfaceRow struct {
    ID	uint
    Version	uint
    DeviceShortID	sql.NullInt32
    Priority	sql.NullInt32
    Ospfv3Enable	sql.NullByte
    AreaID	sql.NullInt64
    Passive	sql.NullByte
    Cost	sql.NullInt32
    HelloInterval	sql.NullInt32
    DeadInterval	sql.NullInt32
    RetransmitInterval	sql.NullInt32
    TransmitDelay	sql.NullInt32
    InterfaceBaseID	uint
}

// IterateNgfwOspfv3Interface provide access to all rows of the NGFW_OSPFV3_INTERFACE matching given criteria.
func IterateNgfwOspfv3Interface(db *sql.DB, where string, callback func(v *NgfwOspfv3InterfaceRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,PRIORITY,OSPFV3_ENABLE,AREA_ID,PASSIVE,COST,HELLO_INTERVAL,DEAD_INTERVAL,RETRANSMIT_INTERVAL,TRANSMIT_DELAY,INTERFACE_BASE_ID FROM NGFW_OSPFV3_INTERFACE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwOspfv3InterfaceRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Priority, &r.Ospfv3Enable, &r.AreaID, &r.Passive, &r.Cost, &r.HelloInterval, &r.DeadInterval, &r.RetransmitInterval, &r.TransmitDelay, &r.InterfaceBaseID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwOspfv3Interface provide iterator to all rows of the NGFW_OSPFV3_INTERFACE matching given criteria.
func RangeNgfwOspfv3Interface(db *sql.DB, where string) iter.Seq2[*NgfwOspfv3InterfaceRow, error] {
	return func(yield func(v *NgfwOspfv3InterfaceRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,PRIORITY,OSPFV3_ENABLE,AREA_ID,PASSIVE,COST,HELLO_INTERVAL,DEAD_INTERVAL,RETRANSMIT_INTERVAL,TRANSMIT_DELAY,INTERFACE_BASE_ID FROM NGFW_OSPFV3_INTERFACE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwOspfv3InterfaceRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Priority, &r.Ospfv3Enable, &r.AreaID, &r.Passive, &r.Cost, &r.HelloInterval, &r.DeadInterval, &r.RetransmitInterval, &r.TransmitDelay, &r.InterfaceBaseID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwOspfAreaRow struct represents rows of the NGFW_OSPF_AREA table.
type NgfwOspfAreaRow struct {
    ID	uint
    Version	sql.NullInt32
    OspfVersion	string
    DeviceShortID	uint
    AreaType	sql.NullString
    AreaID	uint
    AreaDefaultCost	sql.NullInt32
}

// IterateNgfwOspfArea provide access to all rows of the NGFW_OSPF_AREA matching given criteria.
func IterateNgfwOspfArea(db *sql.DB, where string, callback func(v *NgfwOspfAreaRow) error) error {
    query := "SELECT ID,VERSION,OSPF_VERSION,DEVICE_SHORT_ID,AREA_TYPE,AREA_ID,AREA_DEFAULT_COST FROM NGFW_OSPF_AREA"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwOspfAreaRow
        err := rows.Scan(&r.ID, &r.Version, &r.OspfVersion, &r.DeviceShortID, &r.AreaType, &r.AreaID, &r.AreaDefaultCost)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwOspfArea provide iterator to all rows of the NGFW_OSPF_AREA matching given criteria.
func RangeNgfwOspfArea(db *sql.DB, where string) iter.Seq2[*NgfwOspfAreaRow, error] {
	return func(yield func(v *NgfwOspfAreaRow, err error) bool) {
	    query := "SELECT ID,VERSION,OSPF_VERSION,DEVICE_SHORT_ID,AREA_TYPE,AREA_ID,AREA_DEFAULT_COST FROM NGFW_OSPF_AREA"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwOspfAreaRow
	        err := rows.Scan(&r.ID, &r.Version, &r.OspfVersion, &r.DeviceShortID, &r.AreaType, &r.AreaID, &r.AreaDefaultCost)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwOspfAreaRangeRow struct represents rows of the NGFW_OSPF_AREA_RANGE table.
type NgfwOspfAreaRangeRow struct {
    ID	uint
    SubnetIpaddr	sql.NullString
    Maskbits	sql.NullInt32
    AdvertiseFlag	sql.NullInt32
    NgfwOspfAreaID	sql.NullInt32
}

// IterateNgfwOspfAreaRange provide access to all rows of the NGFW_OSPF_AREA_RANGE matching given criteria.
func IterateNgfwOspfAreaRange(db *sql.DB, where string, callback func(v *NgfwOspfAreaRangeRow) error) error {
    query := "SELECT ID,SUBNET_IPADDR,MASKBITS,ADVERTISE_FLAG,NGFW_OSPF_AREA_ID FROM NGFW_OSPF_AREA_RANGE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwOspfAreaRangeRow
        err := rows.Scan(&r.ID, &r.SubnetIpaddr, &r.Maskbits, &r.AdvertiseFlag, &r.NgfwOspfAreaID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwOspfAreaRange provide iterator to all rows of the NGFW_OSPF_AREA_RANGE matching given criteria.
func RangeNgfwOspfAreaRange(db *sql.DB, where string) iter.Seq2[*NgfwOspfAreaRangeRow, error] {
	return func(yield func(v *NgfwOspfAreaRangeRow, err error) bool) {
	    query := "SELECT ID,SUBNET_IPADDR,MASKBITS,ADVERTISE_FLAG,NGFW_OSPF_AREA_ID FROM NGFW_OSPF_AREA_RANGE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwOspfAreaRangeRow
	        err := rows.Scan(&r.ID, &r.SubnetIpaddr, &r.Maskbits, &r.AdvertiseFlag, &r.NgfwOspfAreaID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwOspfRedistributeRow struct represents rows of the NGFW_OSPF_REDISTRIBUTE table.
type NgfwOspfRedistributeRow struct {
    ID	uint
    Version	sql.NullInt32
    DeviceShortID	sql.NullInt32
    OspfVersion	sql.NullString
    RouteType	sql.NullString
    Metric	sql.NullInt32
    RoutemapID	sql.NullInt32
    MetricType	sql.NullString
}

// IterateNgfwOspfRedistribute provide access to all rows of the NGFW_OSPF_REDISTRIBUTE matching given criteria.
func IterateNgfwOspfRedistribute(db *sql.DB, where string, callback func(v *NgfwOspfRedistributeRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,OSPF_VERSION,ROUTE_TYPE,METRIC,ROUTEMAP_ID,METRIC_TYPE FROM NGFW_OSPF_REDISTRIBUTE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwOspfRedistributeRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.OspfVersion, &r.RouteType, &r.Metric, &r.RoutemapID, &r.MetricType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwOspfRedistribute provide iterator to all rows of the NGFW_OSPF_REDISTRIBUTE matching given criteria.
func RangeNgfwOspfRedistribute(db *sql.DB, where string) iter.Seq2[*NgfwOspfRedistributeRow, error] {
	return func(yield func(v *NgfwOspfRedistributeRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,OSPF_VERSION,ROUTE_TYPE,METRIC,ROUTEMAP_ID,METRIC_TYPE FROM NGFW_OSPF_REDISTRIBUTE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwOspfRedistributeRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.OspfVersion, &r.RouteType, &r.Metric, &r.RoutemapID, &r.MetricType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwOspfVirtualLinkRow struct represents rows of the NGFW_OSPF_VIRTUAL_LINK table.
type NgfwOspfVirtualLinkRow struct {
    ID	uint
    Version	sql.NullInt32
    DeviceShortID	uint
    OspfVersion	string
    AreaID	uint
    RemoteRouterID	uint
    HelloInterval	uint
    DeadInterval	uint
    RetransmitInterval	uint
    TransmitDelay	uint
    AuthenticationType	sql.NullString
    SimplePasswd	sql.NullString
    SimplePasswdLen	sql.NullInt32
    Md5Passwd	sql.NullString
    Md5PasswdLen	sql.NullInt32
    Md5KeyID	sql.NullInt32
}

// IterateNgfwOspfVirtualLink provide access to all rows of the NGFW_OSPF_VIRTUAL_LINK matching given criteria.
func IterateNgfwOspfVirtualLink(db *sql.DB, where string, callback func(v *NgfwOspfVirtualLinkRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,OSPF_VERSION,AREA_ID,REMOTE_ROUTER_ID,HELLO_INTERVAL,DEAD_INTERVAL,RETRANSMIT_INTERVAL,TRANSMIT_DELAY,AUTHENTICATION_TYPE,SIMPLE_PASSWD,SIMPLE_PASSWD_LEN,MD5_PASSWD,MD5_PASSWD_LEN,MD5_KEY_ID FROM NGFW_OSPF_VIRTUAL_LINK"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwOspfVirtualLinkRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.OspfVersion, &r.AreaID, &r.RemoteRouterID, &r.HelloInterval, &r.DeadInterval, &r.RetransmitInterval, &r.TransmitDelay, &r.AuthenticationType, &r.SimplePasswd, &r.SimplePasswdLen, &r.Md5Passwd, &r.Md5PasswdLen, &r.Md5KeyID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwOspfVirtualLink provide iterator to all rows of the NGFW_OSPF_VIRTUAL_LINK matching given criteria.
func RangeNgfwOspfVirtualLink(db *sql.DB, where string) iter.Seq2[*NgfwOspfVirtualLinkRow, error] {
	return func(yield func(v *NgfwOspfVirtualLinkRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,OSPF_VERSION,AREA_ID,REMOTE_ROUTER_ID,HELLO_INTERVAL,DEAD_INTERVAL,RETRANSMIT_INTERVAL,TRANSMIT_DELAY,AUTHENTICATION_TYPE,SIMPLE_PASSWD,SIMPLE_PASSWD_LEN,MD5_PASSWD,MD5_PASSWD_LEN,MD5_KEY_ID FROM NGFW_OSPF_VIRTUAL_LINK"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwOspfVirtualLinkRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.OspfVersion, &r.AreaID, &r.RemoteRouterID, &r.HelloInterval, &r.DeadInterval, &r.RetransmitInterval, &r.TransmitDelay, &r.AuthenticationType, &r.SimplePasswd, &r.SimplePasswdLen, &r.Md5Passwd, &r.Md5PasswdLen, &r.Md5KeyID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwPimSmGlobalRow struct represents rows of the NGFW_PIM_SM_GLOBAL table.
type NgfwPimSmGlobalRow struct {
    DeviceShortID	uint
    IPType	string
    Version	uint
    Enable	sql.NullByte
    BsrCandidatePriority	sql.NullInt16
    BsrCandidateInterfaceBaseID	sql.NullInt32
    DrPriority	sql.NullInt64
    NgfwPimSmRpCandidateID	sql.NullInt32
    Threshold	sql.NullInt64
}

// IterateNgfwPimSmGlobal provide access to all rows of the NGFW_PIM_SM_GLOBAL matching given criteria.
func IterateNgfwPimSmGlobal(db *sql.DB, where string, callback func(v *NgfwPimSmGlobalRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,IP_TYPE,VERSION,ENABLE,BSR_CANDIDATE_PRIORITY,BSR_CANDIDATE_INTERFACE_BASE_ID,DR_PRIORITY,NGFW_PIM_SM_RP_CANDIDATE_ID,THRESHOLD FROM NGFW_PIM_SM_GLOBAL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwPimSmGlobalRow
        err := rows.Scan(&r.DeviceShortID, &r.IPType, &r.Version, &r.Enable, &r.BsrCandidatePriority, &r.BsrCandidateInterfaceBaseID, &r.DrPriority, &r.NgfwPimSmRpCandidateID, &r.Threshold)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwPimSmGlobal provide iterator to all rows of the NGFW_PIM_SM_GLOBAL matching given criteria.
func RangeNgfwPimSmGlobal(db *sql.DB, where string) iter.Seq2[*NgfwPimSmGlobalRow, error] {
	return func(yield func(v *NgfwPimSmGlobalRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,IP_TYPE,VERSION,ENABLE,BSR_CANDIDATE_PRIORITY,BSR_CANDIDATE_INTERFACE_BASE_ID,DR_PRIORITY,NGFW_PIM_SM_RP_CANDIDATE_ID,THRESHOLD FROM NGFW_PIM_SM_GLOBAL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwPimSmGlobalRow
	        err := rows.Scan(&r.DeviceShortID, &r.IPType, &r.Version, &r.Enable, &r.BsrCandidatePriority, &r.BsrCandidateInterfaceBaseID, &r.DrPriority, &r.NgfwPimSmRpCandidateID, &r.Threshold)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwPimSmIfaceRow struct represents rows of the NGFW_PIM_SM_IFACE table.
type NgfwPimSmIfaceRow struct {
    ID	uint
    Version	uint
    DeviceShortID	sql.NullInt32
    InterfaceBaseID	uint
    IPType	string
    Enabled	sql.NullByte
}

// IterateNgfwPimSmIface provide access to all rows of the NGFW_PIM_SM_IFACE matching given criteria.
func IterateNgfwPimSmIface(db *sql.DB, where string, callback func(v *NgfwPimSmIfaceRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,INTERFACE_BASE_ID,IP_TYPE,ENABLED FROM NGFW_PIM_SM_IFACE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwPimSmIfaceRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.InterfaceBaseID, &r.IPType, &r.Enabled)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwPimSmIface provide iterator to all rows of the NGFW_PIM_SM_IFACE matching given criteria.
func RangeNgfwPimSmIface(db *sql.DB, where string) iter.Seq2[*NgfwPimSmIfaceRow, error] {
	return func(yield func(v *NgfwPimSmIfaceRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,INTERFACE_BASE_ID,IP_TYPE,ENABLED FROM NGFW_PIM_SM_IFACE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwPimSmIfaceRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.InterfaceBaseID, &r.IPType, &r.Enabled)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwPimSmRpCandidateRow struct represents rows of the NGFW_PIM_SM_RP_CANDIDATE table.
type NgfwPimSmRpCandidateRow struct {
    ID	uint
    Priority	sql.NullInt16
    InterfaceBaseID	sql.NullInt32
    IPType	string
    DeviceShortID	sql.NullInt32
}

// IterateNgfwPimSmRpCandidate provide access to all rows of the NGFW_PIM_SM_RP_CANDIDATE matching given criteria.
func IterateNgfwPimSmRpCandidate(db *sql.DB, where string, callback func(v *NgfwPimSmRpCandidateRow) error) error {
    query := "SELECT ID,PRIORITY,INTERFACE_BASE_ID,IP_TYPE,DEVICE_SHORT_ID FROM NGFW_PIM_SM_RP_CANDIDATE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwPimSmRpCandidateRow
        err := rows.Scan(&r.ID, &r.Priority, &r.InterfaceBaseID, &r.IPType, &r.DeviceShortID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwPimSmRpCandidate provide iterator to all rows of the NGFW_PIM_SM_RP_CANDIDATE matching given criteria.
func RangeNgfwPimSmRpCandidate(db *sql.DB, where string) iter.Seq2[*NgfwPimSmRpCandidateRow, error] {
	return func(yield func(v *NgfwPimSmRpCandidateRow, err error) bool) {
	    query := "SELECT ID,PRIORITY,INTERFACE_BASE_ID,IP_TYPE,DEVICE_SHORT_ID FROM NGFW_PIM_SM_RP_CANDIDATE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwPimSmRpCandidateRow
	        err := rows.Scan(&r.ID, &r.Priority, &r.InterfaceBaseID, &r.IPType, &r.DeviceShortID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwPimSmRpCandidateMulticastGroupRangesRow struct represents rows of the NGFW_PIM_SM_RP_CANDIDATE_MULTICAST_GROUP_RANGES table.
type NgfwPimSmRpCandidateMulticastGroupRangesRow struct {
    NgfwPimSmRpCandidateID	uint
    NgfwMulticastGroupRangeID	uint
}

// IterateNgfwPimSmRpCandidateMulticastGroupRanges provide access to all rows of the NGFW_PIM_SM_RP_CANDIDATE_MULTICAST_GROUP_RANGES matching given criteria.
func IterateNgfwPimSmRpCandidateMulticastGroupRanges(db *sql.DB, where string, callback func(v *NgfwPimSmRpCandidateMulticastGroupRangesRow) error) error {
    query := "SELECT NGFW_PIM_SM_RP_CANDIDATE_ID,NGFW_MULTICAST_GROUP_RANGE_ID FROM NGFW_PIM_SM_RP_CANDIDATE_MULTICAST_GROUP_RANGES"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwPimSmRpCandidateMulticastGroupRangesRow
        err := rows.Scan(&r.NgfwPimSmRpCandidateID, &r.NgfwMulticastGroupRangeID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwPimSmRpCandidateMulticastGroupRanges provide iterator to all rows of the NGFW_PIM_SM_RP_CANDIDATE_MULTICAST_GROUP_RANGES matching given criteria.
func RangeNgfwPimSmRpCandidateMulticastGroupRanges(db *sql.DB, where string) iter.Seq2[*NgfwPimSmRpCandidateMulticastGroupRangesRow, error] {
	return func(yield func(v *NgfwPimSmRpCandidateMulticastGroupRangesRow, err error) bool) {
	    query := "SELECT NGFW_PIM_SM_RP_CANDIDATE_ID,NGFW_MULTICAST_GROUP_RANGE_ID FROM NGFW_PIM_SM_RP_CANDIDATE_MULTICAST_GROUP_RANGES"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwPimSmRpCandidateMulticastGroupRangesRow
	        err := rows.Scan(&r.NgfwPimSmRpCandidateID, &r.NgfwMulticastGroupRangeID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwPimStaticRpAddressRow struct represents rows of the NGFW_PIM_STATIC_RP_ADDRESS table.
type NgfwPimStaticRpAddressRow struct {
    ID	uint
    NgfwPimSmGlobalDeviceShortID	sql.NullInt32
    NgfwPimSmGlobalIPType	sql.NullString
    Ipaddr	sql.NullString
    NgfwMulticastGroupRangeID	sql.NullInt32
}

// IterateNgfwPimStaticRpAddress provide access to all rows of the NGFW_PIM_STATIC_RP_ADDRESS matching given criteria.
func IterateNgfwPimStaticRpAddress(db *sql.DB, where string, callback func(v *NgfwPimStaticRpAddressRow) error) error {
    query := "SELECT ID,NGFW_PIM_SM_GLOBAL_DEVICE_SHORT_ID,NGFW_PIM_SM_GLOBAL_IP_TYPE,IPADDR,NGFW_MULTICAST_GROUP_RANGE_ID FROM NGFW_PIM_STATIC_RP_ADDRESS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwPimStaticRpAddressRow
        err := rows.Scan(&r.ID, &r.NgfwPimSmGlobalDeviceShortID, &r.NgfwPimSmGlobalIPType, &r.Ipaddr, &r.NgfwMulticastGroupRangeID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwPimStaticRpAddress provide iterator to all rows of the NGFW_PIM_STATIC_RP_ADDRESS matching given criteria.
func RangeNgfwPimStaticRpAddress(db *sql.DB, where string) iter.Seq2[*NgfwPimStaticRpAddressRow, error] {
	return func(yield func(v *NgfwPimStaticRpAddressRow, err error) bool) {
	    query := "SELECT ID,NGFW_PIM_SM_GLOBAL_DEVICE_SHORT_ID,NGFW_PIM_SM_GLOBAL_IP_TYPE,IPADDR,NGFW_MULTICAST_GROUP_RANGE_ID FROM NGFW_PIM_STATIC_RP_ADDRESS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwPimStaticRpAddressRow
	        err := rows.Scan(&r.ID, &r.NgfwPimSmGlobalDeviceShortID, &r.NgfwPimSmGlobalIPType, &r.Ipaddr, &r.NgfwMulticastGroupRangeID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwPrefixEntryRow struct represents rows of the NGFW_PREFIX_ENTRY table.
type NgfwPrefixEntryRow struct {
    ID	uint
    Version	uint
    IfaceIPOptionID	uint
    IPAddr1	int64
    IPAddr2	int64
    Mask	sql.NullInt32
    PreferredLifetimeSecs	sql.NullInt32
    ValidLifetimeSecs	sql.NullInt32
}

// IterateNgfwPrefixEntry provide access to all rows of the NGFW_PREFIX_ENTRY matching given criteria.
func IterateNgfwPrefixEntry(db *sql.DB, where string, callback func(v *NgfwPrefixEntryRow) error) error {
    query := "SELECT ID,VERSION,IFACE_IP_OPTION_ID,IP_ADDR_1,IP_ADDR_2,MASK,PREFERRED_LIFETIME_SECS,VALID_LIFETIME_SECS FROM NGFW_PREFIX_ENTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwPrefixEntryRow
        err := rows.Scan(&r.ID, &r.Version, &r.IfaceIPOptionID, &r.IPAddr1, &r.IPAddr2, &r.Mask, &r.PreferredLifetimeSecs, &r.ValidLifetimeSecs)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwPrefixEntry provide iterator to all rows of the NGFW_PREFIX_ENTRY matching given criteria.
func RangeNgfwPrefixEntry(db *sql.DB, where string) iter.Seq2[*NgfwPrefixEntryRow, error] {
	return func(yield func(v *NgfwPrefixEntryRow, err error) bool) {
	    query := "SELECT ID,VERSION,IFACE_IP_OPTION_ID,IP_ADDR_1,IP_ADDR_2,MASK,PREFERRED_LIFETIME_SECS,VALID_LIFETIME_SECS FROM NGFW_PREFIX_ENTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwPrefixEntryRow
	        err := rows.Scan(&r.ID, &r.Version, &r.IfaceIPOptionID, &r.IPAddr1, &r.IPAddr2, &r.Mask, &r.PreferredLifetimeSecs, &r.ValidLifetimeSecs)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwRadiusGroupRow struct represents rows of the NGFW_RADIUS_GROUP table.
type NgfwRadiusGroupRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Name	sql.NullString
    Uuid	sql.NullString
    DefaultUserGroup	sql.NullString
    Retries	sql.NullInt32
    AuthType	string
}

// IterateNgfwRadiusGroup provide access to all rows of the NGFW_RADIUS_GROUP matching given criteria.
func IterateNgfwRadiusGroup(db *sql.DB, where string, callback func(v *NgfwRadiusGroupRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME,UUID,DEFAULT_USER_GROUP,RETRIES,AUTH_TYPE FROM NGFW_RADIUS_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwRadiusGroupRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Name, &r.Uuid, &r.DefaultUserGroup, &r.Retries, &r.AuthType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwRadiusGroup provide iterator to all rows of the NGFW_RADIUS_GROUP matching given criteria.
func RangeNgfwRadiusGroup(db *sql.DB, where string) iter.Seq2[*NgfwRadiusGroupRow, error] {
	return func(yield func(v *NgfwRadiusGroupRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME,UUID,DEFAULT_USER_GROUP,RETRIES,AUTH_TYPE FROM NGFW_RADIUS_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwRadiusGroupRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Name, &r.Uuid, &r.DefaultUserGroup, &r.Retries, &r.AuthType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwRadiusServerRow struct represents rows of the NGFW_RADIUS_SERVER table.
type NgfwRadiusServerRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    RadiusGroupID	uint
    Priority	sql.NullInt32
    ServerName	sql.NullString
    ServerPort	sql.NullInt32
    Password	sql.NullString
    Timeout	sql.NullInt32
    ServerIPNamedObjID	sql.NullInt32
    ServerIPNamedObjBlock	sql.NullString
    NasIdentifier	sql.NullString
}

// IterateNgfwRadiusServer provide access to all rows of the NGFW_RADIUS_SERVER matching given criteria.
func IterateNgfwRadiusServer(db *sql.DB, where string, callback func(v *NgfwRadiusServerRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,RADIUS_GROUP_ID,PRIORITY,SERVER_NAME,SERVER_PORT,PASSWORD,TIMEOUT,SERVER_IP_NAMED_OBJ_ID,SERVER_IP_NAMED_OBJ_BLOCK,NAS_IDENTIFIER FROM NGFW_RADIUS_SERVER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwRadiusServerRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.RadiusGroupID, &r.Priority, &r.ServerName, &r.ServerPort, &r.Password, &r.Timeout, &r.ServerIPNamedObjID, &r.ServerIPNamedObjBlock, &r.NasIdentifier)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwRadiusServer provide iterator to all rows of the NGFW_RADIUS_SERVER matching given criteria.
func RangeNgfwRadiusServer(db *sql.DB, where string) iter.Seq2[*NgfwRadiusServerRow, error] {
	return func(yield func(v *NgfwRadiusServerRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,RADIUS_GROUP_ID,PRIORITY,SERVER_NAME,SERVER_PORT,PASSWORD,TIMEOUT,SERVER_IP_NAMED_OBJ_ID,SERVER_IP_NAMED_OBJ_BLOCK,NAS_IDENTIFIER FROM NGFW_RADIUS_SERVER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwRadiusServerRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.RadiusGroupID, &r.Priority, &r.ServerName, &r.ServerPort, &r.Password, &r.Timeout, &r.ServerIPNamedObjID, &r.ServerIPNamedObjBlock, &r.NasIdentifier)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwRedistributeRow struct represents rows of the NGFW_REDISTRIBUTE table.
type NgfwRedistributeRow struct {
    ID	uint
    DeviceShortID	uint
    ParentType	sql.NullString
    RouteType	sql.NullString
    Metric	sql.NullInt64
    RoutemapID	sql.NullInt32
}

// IterateNgfwRedistribute provide access to all rows of the NGFW_REDISTRIBUTE matching given criteria.
func IterateNgfwRedistribute(db *sql.DB, where string, callback func(v *NgfwRedistributeRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,PARENT_TYPE,ROUTE_TYPE,METRIC,ROUTEMAP_ID FROM NGFW_REDISTRIBUTE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwRedistributeRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.ParentType, &r.RouteType, &r.Metric, &r.RoutemapID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwRedistribute provide iterator to all rows of the NGFW_REDISTRIBUTE matching given criteria.
func RangeNgfwRedistribute(db *sql.DB, where string) iter.Seq2[*NgfwRedistributeRow, error] {
	return func(yield func(v *NgfwRedistributeRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,PARENT_TYPE,ROUTE_TYPE,METRIC,ROUTEMAP_ID FROM NGFW_REDISTRIBUTE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwRedistributeRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.ParentType, &r.RouteType, &r.Metric, &r.RoutemapID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwRemoteSyslogSettingsRow struct represents rows of the NGFW_REMOTE_SYSLOG_SETTINGS table.
type NgfwRemoteSyslogSettingsRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    EnableAdditionalEventInfo	int8
}

// IterateNgfwRemoteSyslogSettings provide access to all rows of the NGFW_REMOTE_SYSLOG_SETTINGS matching given criteria.
func IterateNgfwRemoteSyslogSettings(db *sql.DB, where string, callback func(v *NgfwRemoteSyslogSettingsRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLE_ADDITIONAL_EVENT_INFO FROM NGFW_REMOTE_SYSLOG_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwRemoteSyslogSettingsRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.EnableAdditionalEventInfo)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwRemoteSyslogSettings provide iterator to all rows of the NGFW_REMOTE_SYSLOG_SETTINGS matching given criteria.
func RangeNgfwRemoteSyslogSettings(db *sql.DB, where string) iter.Seq2[*NgfwRemoteSyslogSettingsRow, error] {
	return func(yield func(v *NgfwRemoteSyslogSettingsRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLE_ADDITIONAL_EVENT_INFO FROM NGFW_REMOTE_SYSLOG_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwRemoteSyslogSettingsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.EnableAdditionalEventInfo)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwRipngGeneralRedistributesRow struct represents rows of the NGFW_RIPNG_GENERAL_REDISTRIBUTES table.
type NgfwRipngGeneralRedistributesRow struct {
    RipnggeneralDeviceID	uint
    RedistributeID	uint
}

// IterateNgfwRipngGeneralRedistributes provide access to all rows of the NGFW_RIPNG_GENERAL_REDISTRIBUTES matching given criteria.
func IterateNgfwRipngGeneralRedistributes(db *sql.DB, where string, callback func(v *NgfwRipngGeneralRedistributesRow) error) error {
    query := "SELECT RIPNGGENERAL_DEVICE_ID,REDISTRIBUTE_ID FROM NGFW_RIPNG_GENERAL_REDISTRIBUTES"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwRipngGeneralRedistributesRow
        err := rows.Scan(&r.RipnggeneralDeviceID, &r.RedistributeID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwRipngGeneralRedistributes provide iterator to all rows of the NGFW_RIPNG_GENERAL_REDISTRIBUTES matching given criteria.
func RangeNgfwRipngGeneralRedistributes(db *sql.DB, where string) iter.Seq2[*NgfwRipngGeneralRedistributesRow, error] {
	return func(yield func(v *NgfwRipngGeneralRedistributesRow, err error) bool) {
	    query := "SELECT RIPNGGENERAL_DEVICE_ID,REDISTRIBUTE_ID FROM NGFW_RIPNG_GENERAL_REDISTRIBUTES"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwRipngGeneralRedistributesRow
	        err := rows.Scan(&r.RipnggeneralDeviceID, &r.RedistributeID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwRipngGeneralSettingsRow struct represents rows of the NGFW_RIPNG_GENERAL_SETTINGS table.
type NgfwRipngGeneralSettingsRow struct {
    DeviceShortID	uint
    Version	sql.NullInt32
    RipNgEnable	sql.NullByte
    TriggeredUpdatesEnable	sql.NullByte
    AdministrativeDistance	sql.NullInt32
    EqualCost	sql.NullInt32
    TimerUpdate	sql.NullInt32
    TimerTimeout	sql.NullInt32
    TimerGarbage	sql.NullInt32
    DefaultMetric	sql.NullInt32
}

// IterateNgfwRipngGeneralSettings provide access to all rows of the NGFW_RIPNG_GENERAL_SETTINGS matching given criteria.
func IterateNgfwRipngGeneralSettings(db *sql.DB, where string, callback func(v *NgfwRipngGeneralSettingsRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,VERSION,RIP_NG_ENABLE,TRIGGERED_UPDATES_ENABLE,ADMINISTRATIVE_DISTANCE,EQUAL_COST,TIMER_UPDATE,TIMER_TIMEOUT,TIMER_GARBAGE,DEFAULT_METRIC FROM NGFW_RIPNG_GENERAL_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwRipngGeneralSettingsRow
        err := rows.Scan(&r.DeviceShortID, &r.Version, &r.RipNgEnable, &r.TriggeredUpdatesEnable, &r.AdministrativeDistance, &r.EqualCost, &r.TimerUpdate, &r.TimerTimeout, &r.TimerGarbage, &r.DefaultMetric)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwRipngGeneralSettings provide iterator to all rows of the NGFW_RIPNG_GENERAL_SETTINGS matching given criteria.
func RangeNgfwRipngGeneralSettings(db *sql.DB, where string) iter.Seq2[*NgfwRipngGeneralSettingsRow, error] {
	return func(yield func(v *NgfwRipngGeneralSettingsRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,VERSION,RIP_NG_ENABLE,TRIGGERED_UPDATES_ENABLE,ADMINISTRATIVE_DISTANCE,EQUAL_COST,TIMER_UPDATE,TIMER_TIMEOUT,TIMER_GARBAGE,DEFAULT_METRIC FROM NGFW_RIPNG_GENERAL_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwRipngGeneralSettingsRow
	        err := rows.Scan(&r.DeviceShortID, &r.Version, &r.RipNgEnable, &r.TriggeredUpdatesEnable, &r.AdministrativeDistance, &r.EqualCost, &r.TimerUpdate, &r.TimerTimeout, &r.TimerGarbage, &r.DefaultMetric)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwRipngInterfaceRow struct represents rows of the NGFW_RIPNG_INTERFACE table.
type NgfwRipngInterfaceRow struct {
    ID	uint
    Version	sql.NullInt32
    DeviceShortID	sql.NullInt32
    InterfaceBaseID	sql.NullInt32
    Enabled	sql.NullByte
    PassiveMode	sql.NullByte
    SplitHorizonMode	sql.NullString
    InboundNgfwAccessListID	sql.NullInt32
    OutboundNgfwAccessListID	sql.NullInt32
}

// IterateNgfwRipngInterface provide access to all rows of the NGFW_RIPNG_INTERFACE matching given criteria.
func IterateNgfwRipngInterface(db *sql.DB, where string, callback func(v *NgfwRipngInterfaceRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,INTERFACE_BASE_ID,ENABLED,PASSIVE_MODE,SPLIT_HORIZON_MODE,INBOUND_NGFW_ACCESS_LIST_ID,OUTBOUND_NGFW_ACCESS_LIST_ID FROM NGFW_RIPNG_INTERFACE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwRipngInterfaceRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.InterfaceBaseID, &r.Enabled, &r.PassiveMode, &r.SplitHorizonMode, &r.InboundNgfwAccessListID, &r.OutboundNgfwAccessListID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwRipngInterface provide iterator to all rows of the NGFW_RIPNG_INTERFACE matching given criteria.
func RangeNgfwRipngInterface(db *sql.DB, where string) iter.Seq2[*NgfwRipngInterfaceRow, error] {
	return func(yield func(v *NgfwRipngInterfaceRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,INTERFACE_BASE_ID,ENABLED,PASSIVE_MODE,SPLIT_HORIZON_MODE,INBOUND_NGFW_ACCESS_LIST_ID,OUTBOUND_NGFW_ACCESS_LIST_ID FROM NGFW_RIPNG_INTERFACE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwRipngInterfaceRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.InterfaceBaseID, &r.Enabled, &r.PassiveMode, &r.SplitHorizonMode, &r.InboundNgfwAccessListID, &r.OutboundNgfwAccessListID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwRipGeneralRedistributesRow struct represents rows of the NGFW_RIP_GENERAL_REDISTRIBUTES table.
type NgfwRipGeneralRedistributesRow struct {
    RipgeneralDeviceID	uint
    RedistributeID	uint
}

// IterateNgfwRipGeneralRedistributes provide access to all rows of the NGFW_RIP_GENERAL_REDISTRIBUTES matching given criteria.
func IterateNgfwRipGeneralRedistributes(db *sql.DB, where string, callback func(v *NgfwRipGeneralRedistributesRow) error) error {
    query := "SELECT RIPGENERAL_DEVICE_ID,REDISTRIBUTE_ID FROM NGFW_RIP_GENERAL_REDISTRIBUTES"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwRipGeneralRedistributesRow
        err := rows.Scan(&r.RipgeneralDeviceID, &r.RedistributeID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwRipGeneralRedistributes provide iterator to all rows of the NGFW_RIP_GENERAL_REDISTRIBUTES matching given criteria.
func RangeNgfwRipGeneralRedistributes(db *sql.DB, where string) iter.Seq2[*NgfwRipGeneralRedistributesRow, error] {
	return func(yield func(v *NgfwRipGeneralRedistributesRow, err error) bool) {
	    query := "SELECT RIPGENERAL_DEVICE_ID,REDISTRIBUTE_ID FROM NGFW_RIP_GENERAL_REDISTRIBUTES"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwRipGeneralRedistributesRow
	        err := rows.Scan(&r.RipgeneralDeviceID, &r.RedistributeID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwRipGeneralSettingsRow struct represents rows of the NGFW_RIP_GENERAL_SETTINGS table.
type NgfwRipGeneralSettingsRow struct {
    DeviceShortID	uint
    Version	sql.NullInt32
    RipEnable	sql.NullByte
    TriggeredUpdatesEnable	sql.NullByte
    AdministrativeDistance	sql.NullInt32
    EqualCost	sql.NullInt32
    TimerUpdate	sql.NullInt32
    TimerTimeout	sql.NullInt32
    TimerGarbage	sql.NullInt32
    DefaultMetric	sql.NullInt32
}

// IterateNgfwRipGeneralSettings provide access to all rows of the NGFW_RIP_GENERAL_SETTINGS matching given criteria.
func IterateNgfwRipGeneralSettings(db *sql.DB, where string, callback func(v *NgfwRipGeneralSettingsRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,VERSION,RIP_ENABLE,TRIGGERED_UPDATES_ENABLE,ADMINISTRATIVE_DISTANCE,EQUAL_COST,TIMER_UPDATE,TIMER_TIMEOUT,TIMER_GARBAGE,DEFAULT_METRIC FROM NGFW_RIP_GENERAL_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwRipGeneralSettingsRow
        err := rows.Scan(&r.DeviceShortID, &r.Version, &r.RipEnable, &r.TriggeredUpdatesEnable, &r.AdministrativeDistance, &r.EqualCost, &r.TimerUpdate, &r.TimerTimeout, &r.TimerGarbage, &r.DefaultMetric)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwRipGeneralSettings provide iterator to all rows of the NGFW_RIP_GENERAL_SETTINGS matching given criteria.
func RangeNgfwRipGeneralSettings(db *sql.DB, where string) iter.Seq2[*NgfwRipGeneralSettingsRow, error] {
	return func(yield func(v *NgfwRipGeneralSettingsRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,VERSION,RIP_ENABLE,TRIGGERED_UPDATES_ENABLE,ADMINISTRATIVE_DISTANCE,EQUAL_COST,TIMER_UPDATE,TIMER_TIMEOUT,TIMER_GARBAGE,DEFAULT_METRIC FROM NGFW_RIP_GENERAL_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwRipGeneralSettingsRow
	        err := rows.Scan(&r.DeviceShortID, &r.Version, &r.RipEnable, &r.TriggeredUpdatesEnable, &r.AdministrativeDistance, &r.EqualCost, &r.TimerUpdate, &r.TimerTimeout, &r.TimerGarbage, &r.DefaultMetric)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwRipInterfaceRow struct represents rows of the NGFW_RIP_INTERFACE table.
type NgfwRipInterfaceRow struct {
    ID	uint
    Version	sql.NullInt32
    DeviceShortID	sql.NullInt32
    InterfaceBaseID	uint
    Enabled	sql.NullByte
    SendVersion	sql.NullString
    ReceiveVersion	sql.NullString
    AuthenticationType	sql.NullString
    SimplePasswd	sql.NullString
    SimplePasswdLen	sql.NullInt32
    Md5Passwd	sql.NullString
    Md5PasswdLen	sql.NullInt32
    Md5KeyID	sql.NullInt32
    PassiveMode	sql.NullByte
    SplitHorizonMode	sql.NullString
    InboundNgfwAccessListID	sql.NullInt32
    OutboundNgfwAccessListID	sql.NullInt32
}

// IterateNgfwRipInterface provide access to all rows of the NGFW_RIP_INTERFACE matching given criteria.
func IterateNgfwRipInterface(db *sql.DB, where string, callback func(v *NgfwRipInterfaceRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,INTERFACE_BASE_ID,ENABLED,SEND_VERSION,RECEIVE_VERSION,AUTHENTICATION_TYPE,SIMPLE_PASSWD,SIMPLE_PASSWD_LEN,MD5_PASSWD,MD5_PASSWD_LEN,MD5_KEY_ID,PASSIVE_MODE,SPLIT_HORIZON_MODE,INBOUND_NGFW_ACCESS_LIST_ID,OUTBOUND_NGFW_ACCESS_LIST_ID FROM NGFW_RIP_INTERFACE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwRipInterfaceRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.InterfaceBaseID, &r.Enabled, &r.SendVersion, &r.ReceiveVersion, &r.AuthenticationType, &r.SimplePasswd, &r.SimplePasswdLen, &r.Md5Passwd, &r.Md5PasswdLen, &r.Md5KeyID, &r.PassiveMode, &r.SplitHorizonMode, &r.InboundNgfwAccessListID, &r.OutboundNgfwAccessListID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwRipInterface provide iterator to all rows of the NGFW_RIP_INTERFACE matching given criteria.
func RangeNgfwRipInterface(db *sql.DB, where string) iter.Seq2[*NgfwRipInterfaceRow, error] {
	return func(yield func(v *NgfwRipInterfaceRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,INTERFACE_BASE_ID,ENABLED,SEND_VERSION,RECEIVE_VERSION,AUTHENTICATION_TYPE,SIMPLE_PASSWD,SIMPLE_PASSWD_LEN,MD5_PASSWD,MD5_PASSWD_LEN,MD5_KEY_ID,PASSIVE_MODE,SPLIT_HORIZON_MODE,INBOUND_NGFW_ACCESS_LIST_ID,OUTBOUND_NGFW_ACCESS_LIST_ID FROM NGFW_RIP_INTERFACE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwRipInterfaceRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.InterfaceBaseID, &r.Enabled, &r.SendVersion, &r.ReceiveVersion, &r.AuthenticationType, &r.SimplePasswd, &r.SimplePasswdLen, &r.Md5Passwd, &r.Md5PasswdLen, &r.Md5KeyID, &r.PassiveMode, &r.SplitHorizonMode, &r.InboundNgfwAccessListID, &r.OutboundNgfwAccessListID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwRoutemapRow struct represents rows of the NGFW_ROUTEMAP table.
type NgfwRoutemapRow struct {
    ID	uint
    Version	sql.NullInt32
    DeviceShortID	uint
    RoutemapID	sql.NullString
}

// IterateNgfwRoutemap provide access to all rows of the NGFW_ROUTEMAP matching given criteria.
func IterateNgfwRoutemap(db *sql.DB, where string, callback func(v *NgfwRoutemapRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ROUTEMAP_ID FROM NGFW_ROUTEMAP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwRoutemapRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.RoutemapID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwRoutemap provide iterator to all rows of the NGFW_ROUTEMAP matching given criteria.
func RangeNgfwRoutemap(db *sql.DB, where string) iter.Seq2[*NgfwRoutemapRow, error] {
	return func(yield func(v *NgfwRoutemapRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ROUTEMAP_ID FROM NGFW_ROUTEMAP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwRoutemapRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.RoutemapID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwRoutemapEntryRow struct represents rows of the NGFW_ROUTEMAP_ENTRY table.
type NgfwRoutemapEntryRow struct {
    ID	uint
    RoutemapID	sql.NullInt32
    Sequence	sql.NullInt32
    Action	sql.NullString
    MatchAddressAccessListName	sql.NullString
    MatchAddressIpv6AccessListName	sql.NullString
    MatchNextHopIpaddr	sql.NullString
    MatchMetric	sql.NullInt32
    MatchAspathListname	sql.NullString
    MatchCommunityListname	sql.NullString
    SetNextHopIpaddr	sql.NullString
    SetMetric	sql.NullInt32
    SetLocalPreference	sql.NullInt32
    SetCommunity	sql.NullInt32
    SetCommunityToDelete	sql.NullString
    SetPrependPath	sql.NullString
}

// IterateNgfwRoutemapEntry provide access to all rows of the NGFW_ROUTEMAP_ENTRY matching given criteria.
func IterateNgfwRoutemapEntry(db *sql.DB, where string, callback func(v *NgfwRoutemapEntryRow) error) error {
    query := "SELECT ID,ROUTEMAP_ID,SEQUENCE,ACTION,MATCH_ADDRESS_ACCESS_LIST_NAME,MATCH_ADDRESS_IPV6_ACCESS_LIST_NAME,MATCH_NEXT_HOP_IPADDR,MATCH_METRIC,MATCH_ASPATH_LISTNAME,MATCH_COMMUNITY_LISTNAME,SET_NEXT_HOP_IPADDR,SET_METRIC,SET_LOCAL_PREFERENCE,SET_COMMUNITY,SET_COMMUNITY_TO_DELETE,SET_PREPEND_PATH FROM NGFW_ROUTEMAP_ENTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwRoutemapEntryRow
        err := rows.Scan(&r.ID, &r.RoutemapID, &r.Sequence, &r.Action, &r.MatchAddressAccessListName, &r.MatchAddressIpv6AccessListName, &r.MatchNextHopIpaddr, &r.MatchMetric, &r.MatchAspathListname, &r.MatchCommunityListname, &r.SetNextHopIpaddr, &r.SetMetric, &r.SetLocalPreference, &r.SetCommunity, &r.SetCommunityToDelete, &r.SetPrependPath)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwRoutemapEntry provide iterator to all rows of the NGFW_ROUTEMAP_ENTRY matching given criteria.
func RangeNgfwRoutemapEntry(db *sql.DB, where string) iter.Seq2[*NgfwRoutemapEntryRow, error] {
	return func(yield func(v *NgfwRoutemapEntryRow, err error) bool) {
	    query := "SELECT ID,ROUTEMAP_ID,SEQUENCE,ACTION,MATCH_ADDRESS_ACCESS_LIST_NAME,MATCH_ADDRESS_IPV6_ACCESS_LIST_NAME,MATCH_NEXT_HOP_IPADDR,MATCH_METRIC,MATCH_ASPATH_LISTNAME,MATCH_COMMUNITY_LISTNAME,SET_NEXT_HOP_IPADDR,SET_METRIC,SET_LOCAL_PREFERENCE,SET_COMMUNITY,SET_COMMUNITY_TO_DELETE,SET_PREPEND_PATH FROM NGFW_ROUTEMAP_ENTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwRoutemapEntryRow
	        err := rows.Scan(&r.ID, &r.RoutemapID, &r.Sequence, &r.Action, &r.MatchAddressAccessListName, &r.MatchAddressIpv6AccessListName, &r.MatchNextHopIpaddr, &r.MatchMetric, &r.MatchAspathListname, &r.MatchCommunityListname, &r.SetNextHopIpaddr, &r.SetMetric, &r.SetLocalPreference, &r.SetCommunity, &r.SetCommunityToDelete, &r.SetPrependPath)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwRpfRuleRow struct represents rows of the NGFW_RPF_RULE table.
type NgfwRpfRuleRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Ipv4	int8
    Ipv6	int8
    Log	int8
    InterfaceID	uint
}

// IterateNgfwRpfRule provide access to all rows of the NGFW_RPF_RULE matching given criteria.
func IterateNgfwRpfRule(db *sql.DB, where string, callback func(v *NgfwRpfRuleRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,IPV4,IPV6,LOG,INTERFACE_ID FROM NGFW_RPF_RULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwRpfRuleRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Ipv4, &r.Ipv6, &r.Log, &r.InterfaceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwRpfRule provide iterator to all rows of the NGFW_RPF_RULE matching given criteria.
func RangeNgfwRpfRule(db *sql.DB, where string) iter.Seq2[*NgfwRpfRuleRow, error] {
	return func(yield func(v *NgfwRpfRuleRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,IPV4,IPV6,LOG,INTERFACE_ID FROM NGFW_RPF_RULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwRpfRuleRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Ipv4, &r.Ipv6, &r.Log, &r.InterfaceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwSegmentRow struct represents rows of the NGFW_SEGMENT table.
type NgfwSegmentRow struct {
    ID	uint
    Version	uint
    Name	string
    Description	sql.NullString
    DeviceShortID	uint
    SegID	uint
    HaMode	string
    LinkdownMode	string
    WaitTime	uint
    DisplayName	sql.NullString
}

// IterateNgfwSegment provide access to all rows of the NGFW_SEGMENT matching given criteria.
func IterateNgfwSegment(db *sql.DB, where string, callback func(v *NgfwSegmentRow) error) error {
    query := "SELECT ID,VERSION,NAME,DESCRIPTION,DEVICE_SHORT_ID,SEG_ID,HA_MODE,LINKDOWN_MODE,WAIT_TIME,DISPLAY_NAME FROM NGFW_SEGMENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwSegmentRow
        err := rows.Scan(&r.ID, &r.Version, &r.Name, &r.Description, &r.DeviceShortID, &r.SegID, &r.HaMode, &r.LinkdownMode, &r.WaitTime, &r.DisplayName)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwSegment provide iterator to all rows of the NGFW_SEGMENT matching given criteria.
func RangeNgfwSegment(db *sql.DB, where string) iter.Seq2[*NgfwSegmentRow, error] {
	return func(yield func(v *NgfwSegmentRow, err error) bool) {
	    query := "SELECT ID,VERSION,NAME,DESCRIPTION,DEVICE_SHORT_ID,SEG_ID,HA_MODE,LINKDOWN_MODE,WAIT_TIME,DISPLAY_NAME FROM NGFW_SEGMENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwSegmentRow
	        err := rows.Scan(&r.ID, &r.Version, &r.Name, &r.Description, &r.DeviceShortID, &r.SegID, &r.HaMode, &r.LinkdownMode, &r.WaitTime, &r.DisplayName)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwSegmentIfaceMappingRow struct represents rows of the NGFW_SEGMENT_IFACE_MAPPING table.
type NgfwSegmentIfaceMappingRow struct {
    ID	uint
    SegmentID	uint
    SegmentInOut	int8
    InterfaceID	uint
}

// IterateNgfwSegmentIfaceMapping provide access to all rows of the NGFW_SEGMENT_IFACE_MAPPING matching given criteria.
func IterateNgfwSegmentIfaceMapping(db *sql.DB, where string, callback func(v *NgfwSegmentIfaceMappingRow) error) error {
    query := "SELECT ID,SEGMENT_ID,SEGMENT_IN_OUT,INTERFACE_ID FROM NGFW_SEGMENT_IFACE_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwSegmentIfaceMappingRow
        err := rows.Scan(&r.ID, &r.SegmentID, &r.SegmentInOut, &r.InterfaceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwSegmentIfaceMapping provide iterator to all rows of the NGFW_SEGMENT_IFACE_MAPPING matching given criteria.
func RangeNgfwSegmentIfaceMapping(db *sql.DB, where string) iter.Seq2[*NgfwSegmentIfaceMappingRow, error] {
	return func(yield func(v *NgfwSegmentIfaceMappingRow, err error) bool) {
	    query := "SELECT ID,SEGMENT_ID,SEGMENT_IN_OUT,INTERFACE_ID FROM NGFW_SEGMENT_IFACE_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwSegmentIfaceMappingRow
	        err := rows.Scan(&r.ID, &r.SegmentID, &r.SegmentInOut, &r.InterfaceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwSmrRow struct represents rows of the NGFW_SMR table.
type NgfwSmrRow struct {
    DeviceShortID	uint
    Version	uint
    TimerMsec	sql.NullInt32
    OutgoingPacketTtl	sql.NullInt32
    ExpectedReplyTtl	sql.NullInt32
    Dscp	sql.NullInt32
}

// IterateNgfwSmr provide access to all rows of the NGFW_SMR matching given criteria.
func IterateNgfwSmr(db *sql.DB, where string, callback func(v *NgfwSmrRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,VERSION,TIMER_MSEC,OUTGOING_PACKET_TTL,EXPECTED_REPLY_TTL,DSCP FROM NGFW_SMR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwSmrRow
        err := rows.Scan(&r.DeviceShortID, &r.Version, &r.TimerMsec, &r.OutgoingPacketTtl, &r.ExpectedReplyTtl, &r.Dscp)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwSmr provide iterator to all rows of the NGFW_SMR matching given criteria.
func RangeNgfwSmr(db *sql.DB, where string) iter.Seq2[*NgfwSmrRow, error] {
	return func(yield func(v *NgfwSmrRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,VERSION,TIMER_MSEC,OUTGOING_PACKET_TTL,EXPECTED_REPLY_TTL,DSCP FROM NGFW_SMR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwSmrRow
	        err := rows.Scan(&r.DeviceShortID, &r.Version, &r.TimerMsec, &r.OutgoingPacketTtl, &r.ExpectedReplyTtl, &r.Dscp)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwSmrRouteRow struct represents rows of the NGFW_SMR_ROUTE table.
type NgfwSmrRouteRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    DestSubnetIpaddr	sql.NullString
    DestMaskbits	sql.NullInt32
    Gateway	sql.NullString
    Distance	sql.NullInt32
    Multiplier	sql.NullInt32
    MaxFailure	sql.NullInt32
    Waypoint	sql.NullString
}

// IterateNgfwSmrRoute provide access to all rows of the NGFW_SMR_ROUTE matching given criteria.
func IterateNgfwSmrRoute(db *sql.DB, where string, callback func(v *NgfwSmrRouteRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,DEST_SUBNET_IPADDR,DEST_MASKBITS,GATEWAY,DISTANCE,MULTIPLIER,MAX_FAILURE,WAYPOINT FROM NGFW_SMR_ROUTE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwSmrRouteRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.DestSubnetIpaddr, &r.DestMaskbits, &r.Gateway, &r.Distance, &r.Multiplier, &r.MaxFailure, &r.Waypoint)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwSmrRoute provide iterator to all rows of the NGFW_SMR_ROUTE matching given criteria.
func RangeNgfwSmrRoute(db *sql.DB, where string) iter.Seq2[*NgfwSmrRouteRow, error] {
	return func(yield func(v *NgfwSmrRouteRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,DEST_SUBNET_IPADDR,DEST_MASKBITS,GATEWAY,DISTANCE,MULTIPLIER,MAX_FAILURE,WAYPOINT FROM NGFW_SMR_ROUTE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwSmrRouteRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.DestSubnetIpaddr, &r.DestMaskbits, &r.Gateway, &r.Distance, &r.Multiplier, &r.MaxFailure, &r.Waypoint)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwSnmpRow struct represents rows of the NGFW_SNMP table.
type NgfwSnmpRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Enable	int8
    EnableAuthTrap	int8
    EngineID	sql.NullString
}

// IterateNgfwSnmp provide access to all rows of the NGFW_SNMP matching given criteria.
func IterateNgfwSnmp(db *sql.DB, where string, callback func(v *NgfwSnmpRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLE,ENABLE_AUTH_TRAP,ENGINE_ID FROM NGFW_SNMP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwSnmpRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enable, &r.EnableAuthTrap, &r.EngineID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwSnmp provide iterator to all rows of the NGFW_SNMP matching given criteria.
func RangeNgfwSnmp(db *sql.DB, where string) iter.Seq2[*NgfwSnmpRow, error] {
	return func(yield func(v *NgfwSnmpRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,ENABLE,ENABLE_AUTH_TRAP,ENGINE_ID FROM NGFW_SNMP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwSnmpRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Enable, &r.EnableAuthTrap, &r.EngineID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwSnmpAuthRow struct represents rows of the NGFW_SNMP_AUTH table.
type NgfwSnmpAuthRow struct {
    ID	uint
    AuthType	string
    AuthPassPhrase	string
}

// IterateNgfwSnmpAuth provide access to all rows of the NGFW_SNMP_AUTH matching given criteria.
func IterateNgfwSnmpAuth(db *sql.DB, where string, callback func(v *NgfwSnmpAuthRow) error) error {
    query := "SELECT ID,AUTH_TYPE,AUTH_PASS_PHRASE FROM NGFW_SNMP_AUTH"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwSnmpAuthRow
        err := rows.Scan(&r.ID, &r.AuthType, &r.AuthPassPhrase)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwSnmpAuth provide iterator to all rows of the NGFW_SNMP_AUTH matching given criteria.
func RangeNgfwSnmpAuth(db *sql.DB, where string) iter.Seq2[*NgfwSnmpAuthRow, error] {
	return func(yield func(v *NgfwSnmpAuthRow, err error) bool) {
	    query := "SELECT ID,AUTH_TYPE,AUTH_PASS_PHRASE FROM NGFW_SNMP_AUTH"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwSnmpAuthRow
	        err := rows.Scan(&r.ID, &r.AuthType, &r.AuthPassPhrase)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwSnmpCommunityRow struct represents rows of the NGFW_SNMP_COMMUNITY table.
type NgfwSnmpCommunityRow struct {
    ID	uint
    Community	string
    DefaultCommunity	int8
    HostipNamedObjID	sql.NullInt32
    Hostname	sql.NullString
    SnmpID	uint
}

// IterateNgfwSnmpCommunity provide access to all rows of the NGFW_SNMP_COMMUNITY matching given criteria.
func IterateNgfwSnmpCommunity(db *sql.DB, where string, callback func(v *NgfwSnmpCommunityRow) error) error {
    query := "SELECT ID,COMMUNITY,DEFAULT_COMMUNITY,HOSTIP_NAMED_OBJ_ID,HOSTNAME,SNMP_ID FROM NGFW_SNMP_COMMUNITY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwSnmpCommunityRow
        err := rows.Scan(&r.ID, &r.Community, &r.DefaultCommunity, &r.HostipNamedObjID, &r.Hostname, &r.SnmpID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwSnmpCommunity provide iterator to all rows of the NGFW_SNMP_COMMUNITY matching given criteria.
func RangeNgfwSnmpCommunity(db *sql.DB, where string) iter.Seq2[*NgfwSnmpCommunityRow, error] {
	return func(yield func(v *NgfwSnmpCommunityRow, err error) bool) {
	    query := "SELECT ID,COMMUNITY,DEFAULT_COMMUNITY,HOSTIP_NAMED_OBJ_ID,HOSTNAME,SNMP_ID FROM NGFW_SNMP_COMMUNITY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwSnmpCommunityRow
	        err := rows.Scan(&r.ID, &r.Community, &r.DefaultCommunity, &r.HostipNamedObjID, &r.Hostname, &r.SnmpID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwSnmpPrivacyRow struct represents rows of the NGFW_SNMP_PRIVACY table.
type NgfwSnmpPrivacyRow struct {
    ID	uint
    PrivType	string
    PrivPassword	string
}

// IterateNgfwSnmpPrivacy provide access to all rows of the NGFW_SNMP_PRIVACY matching given criteria.
func IterateNgfwSnmpPrivacy(db *sql.DB, where string, callback func(v *NgfwSnmpPrivacyRow) error) error {
    query := "SELECT ID,PRIV_TYPE,PRIV_PASSWORD FROM NGFW_SNMP_PRIVACY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwSnmpPrivacyRow
        err := rows.Scan(&r.ID, &r.PrivType, &r.PrivPassword)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwSnmpPrivacy provide iterator to all rows of the NGFW_SNMP_PRIVACY matching given criteria.
func RangeNgfwSnmpPrivacy(db *sql.DB, where string) iter.Seq2[*NgfwSnmpPrivacyRow, error] {
	return func(yield func(v *NgfwSnmpPrivacyRow, err error) bool) {
	    query := "SELECT ID,PRIV_TYPE,PRIV_PASSWORD FROM NGFW_SNMP_PRIVACY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwSnmpPrivacyRow
	        err := rows.Scan(&r.ID, &r.PrivType, &r.PrivPassword)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwSnmpTrapDestinationRow struct represents rows of the NGFW_SNMP_TRAP_DESTINATION table.
type NgfwSnmpTrapDestinationRow struct {
    ID	uint
    Port	sql.NullInt32
    Community	sql.NullString
    HostipNamedObjID	sql.NullInt32
    Hostname	sql.NullString
    Version	string
    SecName	sql.NullString
    Inform	sql.NullByte
    SnmpID	sql.NullInt32
}

// IterateNgfwSnmpTrapDestination provide access to all rows of the NGFW_SNMP_TRAP_DESTINATION matching given criteria.
func IterateNgfwSnmpTrapDestination(db *sql.DB, where string, callback func(v *NgfwSnmpTrapDestinationRow) error) error {
    query := "SELECT ID,PORT,COMMUNITY,HOSTIP_NAMED_OBJ_ID,HOSTNAME,VERSION,SEC_NAME,INFORM,SNMP_ID FROM NGFW_SNMP_TRAP_DESTINATION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwSnmpTrapDestinationRow
        err := rows.Scan(&r.ID, &r.Port, &r.Community, &r.HostipNamedObjID, &r.Hostname, &r.Version, &r.SecName, &r.Inform, &r.SnmpID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwSnmpTrapDestination provide iterator to all rows of the NGFW_SNMP_TRAP_DESTINATION matching given criteria.
func RangeNgfwSnmpTrapDestination(db *sql.DB, where string) iter.Seq2[*NgfwSnmpTrapDestinationRow, error] {
	return func(yield func(v *NgfwSnmpTrapDestinationRow, err error) bool) {
	    query := "SELECT ID,PORT,COMMUNITY,HOSTIP_NAMED_OBJ_ID,HOSTNAME,VERSION,SEC_NAME,INFORM,SNMP_ID FROM NGFW_SNMP_TRAP_DESTINATION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwSnmpTrapDestinationRow
	        err := rows.Scan(&r.ID, &r.Port, &r.Community, &r.HostipNamedObjID, &r.Hostname, &r.Version, &r.SecName, &r.Inform, &r.SnmpID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwSnmpTrapDesAuthMappingRow struct represents rows of the NGFW_SNMP_TRAP_DES_AUTH_MAPPING table.
type NgfwSnmpTrapDesAuthMappingRow struct {
    ID	uint
    SnmpTrapDesID	uint
    AuthID	uint
}

// IterateNgfwSnmpTrapDesAuthMapping provide access to all rows of the NGFW_SNMP_TRAP_DES_AUTH_MAPPING matching given criteria.
func IterateNgfwSnmpTrapDesAuthMapping(db *sql.DB, where string, callback func(v *NgfwSnmpTrapDesAuthMappingRow) error) error {
    query := "SELECT ID,SNMP_TRAP_DES_ID,AUTH_ID FROM NGFW_SNMP_TRAP_DES_AUTH_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwSnmpTrapDesAuthMappingRow
        err := rows.Scan(&r.ID, &r.SnmpTrapDesID, &r.AuthID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwSnmpTrapDesAuthMapping provide iterator to all rows of the NGFW_SNMP_TRAP_DES_AUTH_MAPPING matching given criteria.
func RangeNgfwSnmpTrapDesAuthMapping(db *sql.DB, where string) iter.Seq2[*NgfwSnmpTrapDesAuthMappingRow, error] {
	return func(yield func(v *NgfwSnmpTrapDesAuthMappingRow, err error) bool) {
	    query := "SELECT ID,SNMP_TRAP_DES_ID,AUTH_ID FROM NGFW_SNMP_TRAP_DES_AUTH_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwSnmpTrapDesAuthMappingRow
	        err := rows.Scan(&r.ID, &r.SnmpTrapDesID, &r.AuthID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwSnmpTrapDesPrivacyMappingRow struct represents rows of the NGFW_SNMP_TRAP_DES_PRIVACY_MAPPING table.
type NgfwSnmpTrapDesPrivacyMappingRow struct {
    ID	uint
    SnmpTrapDesID	uint
    PrivacyID	uint
}

// IterateNgfwSnmpTrapDesPrivacyMapping provide access to all rows of the NGFW_SNMP_TRAP_DES_PRIVACY_MAPPING matching given criteria.
func IterateNgfwSnmpTrapDesPrivacyMapping(db *sql.DB, where string, callback func(v *NgfwSnmpTrapDesPrivacyMappingRow) error) error {
    query := "SELECT ID,SNMP_TRAP_DES_ID,PRIVACY_ID FROM NGFW_SNMP_TRAP_DES_PRIVACY_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwSnmpTrapDesPrivacyMappingRow
        err := rows.Scan(&r.ID, &r.SnmpTrapDesID, &r.PrivacyID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwSnmpTrapDesPrivacyMapping provide iterator to all rows of the NGFW_SNMP_TRAP_DES_PRIVACY_MAPPING matching given criteria.
func RangeNgfwSnmpTrapDesPrivacyMapping(db *sql.DB, where string) iter.Seq2[*NgfwSnmpTrapDesPrivacyMappingRow, error] {
	return func(yield func(v *NgfwSnmpTrapDesPrivacyMappingRow, err error) bool) {
	    query := "SELECT ID,SNMP_TRAP_DES_ID,PRIVACY_ID FROM NGFW_SNMP_TRAP_DES_PRIVACY_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwSnmpTrapDesPrivacyMappingRow
	        err := rows.Scan(&r.ID, &r.SnmpTrapDesID, &r.PrivacyID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwSnmpVacmUserRow struct represents rows of the NGFW_SNMP_VACM_USER table.
type NgfwSnmpVacmUserRow struct {
    ID	uint
    Name	string
    SnmpID	uint
}

// IterateNgfwSnmpVacmUser provide access to all rows of the NGFW_SNMP_VACM_USER matching given criteria.
func IterateNgfwSnmpVacmUser(db *sql.DB, where string, callback func(v *NgfwSnmpVacmUserRow) error) error {
    query := "SELECT ID,NAME,SNMP_ID FROM NGFW_SNMP_VACM_USER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwSnmpVacmUserRow
        err := rows.Scan(&r.ID, &r.Name, &r.SnmpID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwSnmpVacmUser provide iterator to all rows of the NGFW_SNMP_VACM_USER matching given criteria.
func RangeNgfwSnmpVacmUser(db *sql.DB, where string) iter.Seq2[*NgfwSnmpVacmUserRow, error] {
	return func(yield func(v *NgfwSnmpVacmUserRow, err error) bool) {
	    query := "SELECT ID,NAME,SNMP_ID FROM NGFW_SNMP_VACM_USER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwSnmpVacmUserRow
	        err := rows.Scan(&r.ID, &r.Name, &r.SnmpID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwSnmpVacmUserAuthMappingRow struct represents rows of the NGFW_SNMP_VACM_USER_AUTH_MAPPING table.
type NgfwSnmpVacmUserAuthMappingRow struct {
    ID	uint
    VacmUserID	uint
    AuthID	uint
}

// IterateNgfwSnmpVacmUserAuthMapping provide access to all rows of the NGFW_SNMP_VACM_USER_AUTH_MAPPING matching given criteria.
func IterateNgfwSnmpVacmUserAuthMapping(db *sql.DB, where string, callback func(v *NgfwSnmpVacmUserAuthMappingRow) error) error {
    query := "SELECT ID,VACM_USER_ID,AUTH_ID FROM NGFW_SNMP_VACM_USER_AUTH_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwSnmpVacmUserAuthMappingRow
        err := rows.Scan(&r.ID, &r.VacmUserID, &r.AuthID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwSnmpVacmUserAuthMapping provide iterator to all rows of the NGFW_SNMP_VACM_USER_AUTH_MAPPING matching given criteria.
func RangeNgfwSnmpVacmUserAuthMapping(db *sql.DB, where string) iter.Seq2[*NgfwSnmpVacmUserAuthMappingRow, error] {
	return func(yield func(v *NgfwSnmpVacmUserAuthMappingRow, err error) bool) {
	    query := "SELECT ID,VACM_USER_ID,AUTH_ID FROM NGFW_SNMP_VACM_USER_AUTH_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwSnmpVacmUserAuthMappingRow
	        err := rows.Scan(&r.ID, &r.VacmUserID, &r.AuthID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwSnmpVacmUserPrivacyMappingRow struct represents rows of the NGFW_SNMP_VACM_USER_PRIVACY_MAPPING table.
type NgfwSnmpVacmUserPrivacyMappingRow struct {
    ID	uint
    VacmUserID	uint
    PrivacyID	uint
}

// IterateNgfwSnmpVacmUserPrivacyMapping provide access to all rows of the NGFW_SNMP_VACM_USER_PRIVACY_MAPPING matching given criteria.
func IterateNgfwSnmpVacmUserPrivacyMapping(db *sql.DB, where string, callback func(v *NgfwSnmpVacmUserPrivacyMappingRow) error) error {
    query := "SELECT ID,VACM_USER_ID,PRIVACY_ID FROM NGFW_SNMP_VACM_USER_PRIVACY_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwSnmpVacmUserPrivacyMappingRow
        err := rows.Scan(&r.ID, &r.VacmUserID, &r.PrivacyID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwSnmpVacmUserPrivacyMapping provide iterator to all rows of the NGFW_SNMP_VACM_USER_PRIVACY_MAPPING matching given criteria.
func RangeNgfwSnmpVacmUserPrivacyMapping(db *sql.DB, where string) iter.Seq2[*NgfwSnmpVacmUserPrivacyMappingRow, error] {
	return func(yield func(v *NgfwSnmpVacmUserPrivacyMappingRow, err error) bool) {
	    query := "SELECT ID,VACM_USER_ID,PRIVACY_ID FROM NGFW_SNMP_VACM_USER_PRIVACY_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwSnmpVacmUserPrivacyMappingRow
	        err := rows.Scan(&r.ID, &r.VacmUserID, &r.PrivacyID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwStaticRouteRow struct represents rows of the NGFW_STATIC_ROUTE table.
type NgfwStaticRouteRow struct {
    ID	uint
    Version	uint
    DeviceShortID	sql.NullInt32
    SubnetIpaddr	string
    Maskbits	sql.NullInt32
    Nexthop	sql.NullString
    BlackholeFlag	sql.NullByte
    Distance	sql.NullInt32
    InterfaceBaseID	sql.NullInt32
}

// IterateNgfwStaticRoute provide access to all rows of the NGFW_STATIC_ROUTE matching given criteria.
func IterateNgfwStaticRoute(db *sql.DB, where string, callback func(v *NgfwStaticRouteRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,SUBNET_IPADDR,MASKBITS,NEXTHOP,BLACKHOLE_FLAG,DISTANCE,INTERFACE_BASE_ID FROM NGFW_STATIC_ROUTE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwStaticRouteRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.SubnetIpaddr, &r.Maskbits, &r.Nexthop, &r.BlackholeFlag, &r.Distance, &r.InterfaceBaseID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwStaticRoute provide iterator to all rows of the NGFW_STATIC_ROUTE matching given criteria.
func RangeNgfwStaticRoute(db *sql.DB, where string) iter.Seq2[*NgfwStaticRouteRow, error] {
	return func(yield func(v *NgfwStaticRouteRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,SUBNET_IPADDR,MASKBITS,NEXTHOP,BLACKHOLE_FLAG,DISTANCE,INTERFACE_BASE_ID FROM NGFW_STATIC_ROUTE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwStaticRouteRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.SubnetIpaddr, &r.Maskbits, &r.Nexthop, &r.BlackholeFlag, &r.Distance, &r.InterfaceBaseID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwTacacsGroupRow struct represents rows of the NGFW_TACACS_GROUP table.
type NgfwTacacsGroupRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Name	string
    DefaultUserGroup	string
    Uuid	sql.NullString
    AuthType	sql.NullString
    Retries	sql.NullInt32
}

// IterateNgfwTacacsGroup provide access to all rows of the NGFW_TACACS_GROUP matching given criteria.
func IterateNgfwTacacsGroup(db *sql.DB, where string, callback func(v *NgfwTacacsGroupRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME,DEFAULT_USER_GROUP,UUID,AUTH_TYPE,RETRIES FROM NGFW_TACACS_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwTacacsGroupRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Name, &r.DefaultUserGroup, &r.Uuid, &r.AuthType, &r.Retries)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwTacacsGroup provide iterator to all rows of the NGFW_TACACS_GROUP matching given criteria.
func RangeNgfwTacacsGroup(db *sql.DB, where string) iter.Seq2[*NgfwTacacsGroupRow, error] {
	return func(yield func(v *NgfwTacacsGroupRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME,DEFAULT_USER_GROUP,UUID,AUTH_TYPE,RETRIES FROM NGFW_TACACS_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwTacacsGroupRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Name, &r.DefaultUserGroup, &r.Uuid, &r.AuthType, &r.Retries)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwTacacsServerRow struct represents rows of the NGFW_TACACS_SERVER table.
type NgfwTacacsServerRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Priority	sql.NullInt32
    ServerPort	uint
    ServerName	sql.NullString
    Timeout	sql.NullInt32
    Password	sql.NullString
    ServerIPNamedObjID	sql.NullInt32
    ServerIPNamedObjBlock	sql.NullString
    NgfwTacacsGroupID	uint
}

// IterateNgfwTacacsServer provide access to all rows of the NGFW_TACACS_SERVER matching given criteria.
func IterateNgfwTacacsServer(db *sql.DB, where string, callback func(v *NgfwTacacsServerRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,PRIORITY,SERVER_PORT,SERVER_NAME,TIMEOUT,PASSWORD,SERVER_IP_NAMED_OBJ_ID,SERVER_IP_NAMED_OBJ_BLOCK,NGFW_TACACS_GROUP_ID FROM NGFW_TACACS_SERVER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwTacacsServerRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Priority, &r.ServerPort, &r.ServerName, &r.Timeout, &r.Password, &r.ServerIPNamedObjID, &r.ServerIPNamedObjBlock, &r.NgfwTacacsGroupID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwTacacsServer provide iterator to all rows of the NGFW_TACACS_SERVER matching given criteria.
func RangeNgfwTacacsServer(db *sql.DB, where string) iter.Seq2[*NgfwTacacsServerRow, error] {
	return func(yield func(v *NgfwTacacsServerRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,PRIORITY,SERVER_PORT,SERVER_NAME,TIMEOUT,PASSWORD,SERVER_IP_NAMED_OBJ_ID,SERVER_IP_NAMED_OBJ_BLOCK,NGFW_TACACS_GROUP_ID FROM NGFW_TACACS_SERVER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwTacacsServerRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Priority, &r.ServerPort, &r.ServerName, &r.Timeout, &r.Password, &r.ServerIPNamedObjID, &r.ServerIPNamedObjBlock, &r.NgfwTacacsGroupID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwUserCapabilityRow struct represents rows of the NGFW_USER_CAPABILITY table.
type NgfwUserCapabilityRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Name	string
    CapabilityID	uint
    Description	sql.NullString
    ParentID	sql.NullInt32
}

// IterateNgfwUserCapability provide access to all rows of the NGFW_USER_CAPABILITY matching given criteria.
func IterateNgfwUserCapability(db *sql.DB, where string, callback func(v *NgfwUserCapabilityRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME,CAPABILITY_ID,DESCRIPTION,PARENT_ID FROM NGFW_USER_CAPABILITY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwUserCapabilityRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Name, &r.CapabilityID, &r.Description, &r.ParentID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwUserCapability provide iterator to all rows of the NGFW_USER_CAPABILITY matching given criteria.
func RangeNgfwUserCapability(db *sql.DB, where string) iter.Seq2[*NgfwUserCapabilityRow, error] {
	return func(yield func(v *NgfwUserCapabilityRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME,CAPABILITY_ID,DESCRIPTION,PARENT_ID FROM NGFW_USER_CAPABILITY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwUserCapabilityRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Name, &r.CapabilityID, &r.Description, &r.ParentID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwUserCapabilitySettingRow struct represents rows of the NGFW_USER_CAPABILITY_SETTING table.
type NgfwUserCapabilitySettingRow struct {
    DbID	uint
    ID	sql.NullInt32
    State	sql.NullString
    NgfwUserRoleID	sql.NullInt32
}

// IterateNgfwUserCapabilitySetting provide access to all rows of the NGFW_USER_CAPABILITY_SETTING matching given criteria.
func IterateNgfwUserCapabilitySetting(db *sql.DB, where string, callback func(v *NgfwUserCapabilitySettingRow) error) error {
    query := "SELECT DB_ID,ID,STATE,NGFW_USER_ROLE_ID FROM NGFW_USER_CAPABILITY_SETTING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwUserCapabilitySettingRow
        err := rows.Scan(&r.DbID, &r.ID, &r.State, &r.NgfwUserRoleID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwUserCapabilitySetting provide iterator to all rows of the NGFW_USER_CAPABILITY_SETTING matching given criteria.
func RangeNgfwUserCapabilitySetting(db *sql.DB, where string) iter.Seq2[*NgfwUserCapabilitySettingRow, error] {
	return func(yield func(v *NgfwUserCapabilitySettingRow, err error) bool) {
	    query := "SELECT DB_ID,ID,STATE,NGFW_USER_ROLE_ID FROM NGFW_USER_CAPABILITY_SETTING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwUserCapabilitySettingRow
	        err := rows.Scan(&r.DbID, &r.ID, &r.State, &r.NgfwUserRoleID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwUserGroupRow struct represents rows of the NGFW_USER_GROUP table.
type NgfwUserGroupRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Name	string
    Uuid	string
    RoleID	sql.NullInt32
    LdapGroupDn	sql.NullString
    DefaultGroup	int8
    Description	sql.NullString
}

// IterateNgfwUserGroup provide access to all rows of the NGFW_USER_GROUP matching given criteria.
func IterateNgfwUserGroup(db *sql.DB, where string, callback func(v *NgfwUserGroupRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME,UUID,ROLE_ID,LDAP_GROUP_DN,DEFAULT_GROUP,DESCRIPTION FROM NGFW_USER_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwUserGroupRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Name, &r.Uuid, &r.RoleID, &r.LdapGroupDn, &r.DefaultGroup, &r.Description)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwUserGroup provide iterator to all rows of the NGFW_USER_GROUP matching given criteria.
func RangeNgfwUserGroup(db *sql.DB, where string) iter.Seq2[*NgfwUserGroupRow, error] {
	return func(yield func(v *NgfwUserGroupRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME,UUID,ROLE_ID,LDAP_GROUP_DN,DEFAULT_GROUP,DESCRIPTION FROM NGFW_USER_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwUserGroupRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Name, &r.Uuid, &r.RoleID, &r.LdapGroupDn, &r.DefaultGroup, &r.Description)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwUserGroupMappingRow struct represents rows of the NGFW_USER_GROUP_MAPPING table.
type NgfwUserGroupMappingRow struct {
    GroupID	uint
    UserID	uint
}

// IterateNgfwUserGroupMapping provide access to all rows of the NGFW_USER_GROUP_MAPPING matching given criteria.
func IterateNgfwUserGroupMapping(db *sql.DB, where string, callback func(v *NgfwUserGroupMappingRow) error) error {
    query := "SELECT GROUP_ID,USER_ID FROM NGFW_USER_GROUP_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwUserGroupMappingRow
        err := rows.Scan(&r.GroupID, &r.UserID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwUserGroupMapping provide iterator to all rows of the NGFW_USER_GROUP_MAPPING matching given criteria.
func RangeNgfwUserGroupMapping(db *sql.DB, where string) iter.Seq2[*NgfwUserGroupMappingRow, error] {
	return func(yield func(v *NgfwUserGroupMappingRow, err error) bool) {
	    query := "SELECT GROUP_ID,USER_ID FROM NGFW_USER_GROUP_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwUserGroupMappingRow
	        err := rows.Scan(&r.GroupID, &r.UserID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwUserRoleRow struct represents rows of the NGFW_USER_ROLE table.
type NgfwUserRoleRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    Name	string
    Uuid	string
    BaseUuid	sql.NullString
    Description	sql.NullString
    DefaultRole	sql.NullByte
}

// IterateNgfwUserRole provide access to all rows of the NGFW_USER_ROLE matching given criteria.
func IterateNgfwUserRole(db *sql.DB, where string, callback func(v *NgfwUserRoleRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME,UUID,BASE_UUID,DESCRIPTION,DEFAULT_ROLE FROM NGFW_USER_ROLE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwUserRoleRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Name, &r.Uuid, &r.BaseUuid, &r.Description, &r.DefaultRole)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwUserRole provide iterator to all rows of the NGFW_USER_ROLE matching given criteria.
func RangeNgfwUserRole(db *sql.DB, where string) iter.Seq2[*NgfwUserRoleRow, error] {
	return func(yield func(v *NgfwUserRoleRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,NAME,UUID,BASE_UUID,DESCRIPTION,DEFAULT_ROLE FROM NGFW_USER_ROLE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwUserRoleRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.Name, &r.Uuid, &r.BaseUuid, &r.Description, &r.DefaultRole)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwVpnRow struct represents rows of the NGFW_VPN table.
type NgfwVpnRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    VpnName	string
    VpnType	string
    KeyType	string
    Rekey	int8
    ExchangeMode	string
    P1ProposalID	sql.NullInt32
    P2ProposalID	sql.NullInt32
    LocalEndpointNamedObjID	sql.NullInt32
    RemoteEndpointNamedObjID	sql.NullInt32
    LocalIDType	string
    LocalIDValue	sql.NullString
    RemoteIDType	string
    RemoteIDValue	sql.NullString
    CertificateID	sql.NullInt32
    NatTraversal	int8
    CopyDscpBits	int8
    CopyDfBit	int8
    IPCompression	int8
    UserGroup	sql.NullString
    DeadPeerDetection	int8
    DeadPeerDetectiontime	uint
    DeadPeerDetectiontimeout	uint
    IPPoolNamedObjID	sql.NullInt32
}

// IterateNgfwVpn provide access to all rows of the NGFW_VPN matching given criteria.
func IterateNgfwVpn(db *sql.DB, where string, callback func(v *NgfwVpnRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,VPN_NAME,VPN_TYPE,KEY_TYPE,REKEY,EXCHANGE_MODE,P1_PROPOSAL_ID,P2_PROPOSAL_ID,LOCAL_ENDPOINT_NAMED_OBJ_ID,REMOTE_ENDPOINT_NAMED_OBJ_ID,LOCAL_ID_TYPE,LOCAL_ID_VALUE,REMOTE_ID_TYPE,REMOTE_ID_VALUE,CERTIFICATE_ID,NAT_TRAVERSAL,COPY_DSCP_BITS,COPY_DF_BIT,IP_COMPRESSION,USER_GROUP,DEAD_PEER_DETECTION,DEAD_PEER_DETECTIONTIME,DEAD_PEER_DETECTIONTIMEOUT,IP_POOL_NAMED_OBJ_ID FROM NGFW_VPN"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwVpnRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.VpnName, &r.VpnType, &r.KeyType, &r.Rekey, &r.ExchangeMode, &r.P1ProposalID, &r.P2ProposalID, &r.LocalEndpointNamedObjID, &r.RemoteEndpointNamedObjID, &r.LocalIDType, &r.LocalIDValue, &r.RemoteIDType, &r.RemoteIDValue, &r.CertificateID, &r.NatTraversal, &r.CopyDscpBits, &r.CopyDfBit, &r.IPCompression, &r.UserGroup, &r.DeadPeerDetection, &r.DeadPeerDetectiontime, &r.DeadPeerDetectiontimeout, &r.IPPoolNamedObjID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwVpn provide iterator to all rows of the NGFW_VPN matching given criteria.
func RangeNgfwVpn(db *sql.DB, where string) iter.Seq2[*NgfwVpnRow, error] {
	return func(yield func(v *NgfwVpnRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,VPN_NAME,VPN_TYPE,KEY_TYPE,REKEY,EXCHANGE_MODE,P1_PROPOSAL_ID,P2_PROPOSAL_ID,LOCAL_ENDPOINT_NAMED_OBJ_ID,REMOTE_ENDPOINT_NAMED_OBJ_ID,LOCAL_ID_TYPE,LOCAL_ID_VALUE,REMOTE_ID_TYPE,REMOTE_ID_VALUE,CERTIFICATE_ID,NAT_TRAVERSAL,COPY_DSCP_BITS,COPY_DF_BIT,IP_COMPRESSION,USER_GROUP,DEAD_PEER_DETECTION,DEAD_PEER_DETECTIONTIME,DEAD_PEER_DETECTIONTIMEOUT,IP_POOL_NAMED_OBJ_ID FROM NGFW_VPN"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwVpnRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.VpnName, &r.VpnType, &r.KeyType, &r.Rekey, &r.ExchangeMode, &r.P1ProposalID, &r.P2ProposalID, &r.LocalEndpointNamedObjID, &r.RemoteEndpointNamedObjID, &r.LocalIDType, &r.LocalIDValue, &r.RemoteIDType, &r.RemoteIDValue, &r.CertificateID, &r.NatTraversal, &r.CopyDscpBits, &r.CopyDfBit, &r.IPCompression, &r.UserGroup, &r.DeadPeerDetection, &r.DeadPeerDetectiontime, &r.DeadPeerDetectiontimeout, &r.IPPoolNamedObjID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwVpnMonitorRow struct represents rows of the NGFW_VPN_MONITOR table.
type NgfwVpnMonitorRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    VpnID	uint
    LocalAddrNamedObjID	int
    RemoteAddrNamedObjID	int
    ActionType	string
    Period	uint
    Warning	uint
    Down	uint
}

// IterateNgfwVpnMonitor provide access to all rows of the NGFW_VPN_MONITOR matching given criteria.
func IterateNgfwVpnMonitor(db *sql.DB, where string, callback func(v *NgfwVpnMonitorRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,VPN_ID,LOCAL_ADDR_NAMED_OBJ_ID,REMOTE_ADDR_NAMED_OBJ_ID,ACTION_TYPE,PERIOD,WARNING,DOWN FROM NGFW_VPN_MONITOR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwVpnMonitorRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.VpnID, &r.LocalAddrNamedObjID, &r.RemoteAddrNamedObjID, &r.ActionType, &r.Period, &r.Warning, &r.Down)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwVpnMonitor provide iterator to all rows of the NGFW_VPN_MONITOR matching given criteria.
func RangeNgfwVpnMonitor(db *sql.DB, where string) iter.Seq2[*NgfwVpnMonitorRow, error] {
	return func(yield func(v *NgfwVpnMonitorRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,VPN_ID,LOCAL_ADDR_NAMED_OBJ_ID,REMOTE_ADDR_NAMED_OBJ_ID,ACTION_TYPE,PERIOD,WARNING,DOWN FROM NGFW_VPN_MONITOR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwVpnMonitorRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.VpnID, &r.LocalAddrNamedObjID, &r.RemoteAddrNamedObjID, &r.ActionType, &r.Period, &r.Warning, &r.Down)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwX509crlSettingsRow struct represents rows of the NGFW_X509CRL_SETTINGS table.
type NgfwX509crlSettingsRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    ValidationRequired	sql.NullByte
    CacheEnabled	sql.NullByte
}

// IterateNgfwX509crlSettings provide access to all rows of the NGFW_X509CRL_SETTINGS matching given criteria.
func IterateNgfwX509crlSettings(db *sql.DB, where string, callback func(v *NgfwX509crlSettingsRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,VALIDATION_REQUIRED,CACHE_ENABLED FROM NGFW_X509CRL_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwX509crlSettingsRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.ValidationRequired, &r.CacheEnabled)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwX509crlSettings provide iterator to all rows of the NGFW_X509CRL_SETTINGS matching given criteria.
func RangeNgfwX509crlSettings(db *sql.DB, where string) iter.Seq2[*NgfwX509crlSettingsRow, error] {
	return func(yield func(v *NgfwX509crlSettingsRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,VALIDATION_REQUIRED,CACHE_ENABLED FROM NGFW_X509CRL_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwX509crlSettingsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.ValidationRequired, &r.CacheEnabled)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgfwX509crlUpdateSettingsRow struct represents rows of the NGFW_X509CRL_UPDATE_SETTINGS table.
type NgfwX509crlUpdateSettingsRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    UpdatePeriod	uint
    UpdatePeriodUnits	string
}

// IterateNgfwX509crlUpdateSettings provide access to all rows of the NGFW_X509CRL_UPDATE_SETTINGS matching given criteria.
func IterateNgfwX509crlUpdateSettings(db *sql.DB, where string, callback func(v *NgfwX509crlUpdateSettingsRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,UPDATE_PERIOD,UPDATE_PERIOD_UNITS FROM NGFW_X509CRL_UPDATE_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgfwX509crlUpdateSettingsRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.UpdatePeriod, &r.UpdatePeriodUnits)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgfwX509crlUpdateSettings provide iterator to all rows of the NGFW_X509CRL_UPDATE_SETTINGS matching given criteria.
func RangeNgfwX509crlUpdateSettings(db *sql.DB, where string) iter.Seq2[*NgfwX509crlUpdateSettingsRow, error] {
	return func(yield func(v *NgfwX509crlUpdateSettingsRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,UPDATE_PERIOD,UPDATE_PERIOD_UNITS FROM NGFW_X509CRL_UPDATE_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgfwX509crlUpdateSettingsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.UpdatePeriod, &r.UpdatePeriodUnits)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgAbstractFirewallProfileRow struct represents rows of the NG_ABSTRACT_FIREWALL_PROFILE table.
type NgAbstractFirewallProfileRow struct {
    ID	uint
    ProfileUuid	string
    Name	string
    Description	sql.NullString
    ProfileVersion	string
    LastModified	string
    LastDistributed	sql.NullTime
    Modified	int8
    ParentID	string
    Version	uint
}

// IterateNgAbstractFirewallProfile provide access to all rows of the NG_ABSTRACT_FIREWALL_PROFILE matching given criteria.
func IterateNgAbstractFirewallProfile(db *sql.DB, where string, callback func(v *NgAbstractFirewallProfileRow) error) error {
    query := "SELECT ID,PROFILE_UUID,NAME,DESCRIPTION,PROFILE_VERSION,LAST_MODIFIED,LAST_DISTRIBUTED,MODIFIED,PARENT_ID,VERSION FROM NG_ABSTRACT_FIREWALL_PROFILE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgAbstractFirewallProfileRow
        err := rows.Scan(&r.ID, &r.ProfileUuid, &r.Name, &r.Description, &r.ProfileVersion, &r.LastModified, &r.LastDistributed, &r.Modified, &r.ParentID, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgAbstractFirewallProfile provide iterator to all rows of the NG_ABSTRACT_FIREWALL_PROFILE matching given criteria.
func RangeNgAbstractFirewallProfile(db *sql.DB, where string) iter.Seq2[*NgAbstractFirewallProfileRow, error] {
	return func(yield func(v *NgAbstractFirewallProfileRow, err error) bool) {
	    query := "SELECT ID,PROFILE_UUID,NAME,DESCRIPTION,PROFILE_VERSION,LAST_MODIFIED,LAST_DISTRIBUTED,MODIFIED,PARENT_ID,VERSION FROM NG_ABSTRACT_FIREWALL_PROFILE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgAbstractFirewallProfileRow
	        err := rows.Scan(&r.ID, &r.ProfileUuid, &r.Name, &r.Description, &r.ProfileVersion, &r.LastModified, &r.LastDistributed, &r.Modified, &r.ParentID, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgAbstractFirewallProfileUserGroupsRow struct represents rows of the NG_ABSTRACT_FIREWALL_PROFILE_USER_GROUPS table.
type NgAbstractFirewallProfileUserGroupsRow struct {
    UserGroupsIDFk	uint
    AbstractProfileIDFk	uint
}

// IterateNgAbstractFirewallProfileUserGroups provide access to all rows of the NG_ABSTRACT_FIREWALL_PROFILE_USER_GROUPS matching given criteria.
func IterateNgAbstractFirewallProfileUserGroups(db *sql.DB, where string, callback func(v *NgAbstractFirewallProfileUserGroupsRow) error) error {
    query := "SELECT USER_GROUPS_ID_FK,ABSTRACT_PROFILE_ID_FK FROM NG_ABSTRACT_FIREWALL_PROFILE_USER_GROUPS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgAbstractFirewallProfileUserGroupsRow
        err := rows.Scan(&r.UserGroupsIDFk, &r.AbstractProfileIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgAbstractFirewallProfileUserGroups provide iterator to all rows of the NG_ABSTRACT_FIREWALL_PROFILE_USER_GROUPS matching given criteria.
func RangeNgAbstractFirewallProfileUserGroups(db *sql.DB, where string) iter.Seq2[*NgAbstractFirewallProfileUserGroupsRow, error] {
	return func(yield func(v *NgAbstractFirewallProfileUserGroupsRow, err error) bool) {
	    query := "SELECT USER_GROUPS_ID_FK,ABSTRACT_PROFILE_ID_FK FROM NG_ABSTRACT_FIREWALL_PROFILE_USER_GROUPS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgAbstractFirewallProfileUserGroupsRow
	        err := rows.Scan(&r.UserGroupsIDFk, &r.AbstractProfileIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgAbstractRuleRow struct represents rows of the NG_ABSTRACT_RULE table.
type NgAbstractRuleRow struct {
    ID	uint
    RuleUuid	string
    Name	string
    Description	sql.NullString
    RuleScope	string
    Discriminator	string
    PreviousRuleID	uint
    NextRuleID	uint
    RulesetID	uint
    LastUpdated	string
    IterationID	uint
    Enabled	int8
    Version	uint
    ContiguousRuleGroupID	sql.NullInt32
    ActionsetID	sql.NullString
    InspectionProfileGroupID	sql.NullInt32
    FirewallApplicationGroupID	sql.NullInt32
    NatTranslationType	string
    DstnatTranslationProtocol	string
    SrcnatXlatedSrcAddrID	sql.NullInt32
    DstnatXlatedDstAddrID	sql.NullInt32
    DstnatOrigDstPortRangeStart	sql.NullInt32
    DstnatOrigDstPortRangeEnd	sql.NullInt32
    DstnatXlatedDstPortRangeStart	sql.NullInt32
    DstnatXlatedDstPortRangeEnd	sql.NullInt32
}

// IterateNgAbstractRule provide access to all rows of the NG_ABSTRACT_RULE matching given criteria.
func IterateNgAbstractRule(db *sql.DB, where string, callback func(v *NgAbstractRuleRow) error) error {
    query := "SELECT ID,RULE_UUID,NAME,DESCRIPTION,RULE_SCOPE,DISCRIMINATOR,PREVIOUS_RULE_ID,NEXT_RULE_ID,RULESET_ID,LAST_UPDATED,ITERATION_ID,ENABLED,VERSION,CONTIGUOUS_RULE_GROUP_ID,ACTIONSET_ID,INSPECTION_PROFILE_GROUP_ID,FIREWALL_APPLICATION_GROUP_ID,NAT_TRANSLATION_TYPE,DSTNAT_TRANSLATION_PROTOCOL,SRCNAT_XLATED_SRC_ADDR_ID,DSTNAT_XLATED_DST_ADDR_ID,DSTNAT_ORIG_DST_PORT_RANGE_START,DSTNAT_ORIG_DST_PORT_RANGE_END,DSTNAT_XLATED_DST_PORT_RANGE_START,DSTNAT_XLATED_DST_PORT_RANGE_END FROM NG_ABSTRACT_RULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgAbstractRuleRow
        err := rows.Scan(&r.ID, &r.RuleUuid, &r.Name, &r.Description, &r.RuleScope, &r.Discriminator, &r.PreviousRuleID, &r.NextRuleID, &r.RulesetID, &r.LastUpdated, &r.IterationID, &r.Enabled, &r.Version, &r.ContiguousRuleGroupID, &r.ActionsetID, &r.InspectionProfileGroupID, &r.FirewallApplicationGroupID, &r.NatTranslationType, &r.DstnatTranslationProtocol, &r.SrcnatXlatedSrcAddrID, &r.DstnatXlatedDstAddrID, &r.DstnatOrigDstPortRangeStart, &r.DstnatOrigDstPortRangeEnd, &r.DstnatXlatedDstPortRangeStart, &r.DstnatXlatedDstPortRangeEnd)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgAbstractRule provide iterator to all rows of the NG_ABSTRACT_RULE matching given criteria.
func RangeNgAbstractRule(db *sql.DB, where string) iter.Seq2[*NgAbstractRuleRow, error] {
	return func(yield func(v *NgAbstractRuleRow, err error) bool) {
	    query := "SELECT ID,RULE_UUID,NAME,DESCRIPTION,RULE_SCOPE,DISCRIMINATOR,PREVIOUS_RULE_ID,NEXT_RULE_ID,RULESET_ID,LAST_UPDATED,ITERATION_ID,ENABLED,VERSION,CONTIGUOUS_RULE_GROUP_ID,ACTIONSET_ID,INSPECTION_PROFILE_GROUP_ID,FIREWALL_APPLICATION_GROUP_ID,NAT_TRANSLATION_TYPE,DSTNAT_TRANSLATION_PROTOCOL,SRCNAT_XLATED_SRC_ADDR_ID,DSTNAT_XLATED_DST_ADDR_ID,DSTNAT_ORIG_DST_PORT_RANGE_START,DSTNAT_ORIG_DST_PORT_RANGE_END,DSTNAT_XLATED_DST_PORT_RANGE_START,DSTNAT_XLATED_DST_PORT_RANGE_END FROM NG_ABSTRACT_RULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgAbstractRuleRow
	        err := rows.Scan(&r.ID, &r.RuleUuid, &r.Name, &r.Description, &r.RuleScope, &r.Discriminator, &r.PreviousRuleID, &r.NextRuleID, &r.RulesetID, &r.LastUpdated, &r.IterationID, &r.Enabled, &r.Version, &r.ContiguousRuleGroupID, &r.ActionsetID, &r.InspectionProfileGroupID, &r.FirewallApplicationGroupID, &r.NatTranslationType, &r.DstnatTranslationProtocol, &r.SrcnatXlatedSrcAddrID, &r.DstnatXlatedDstAddrID, &r.DstnatOrigDstPortRangeStart, &r.DstnatOrigDstPortRangeEnd, &r.DstnatXlatedDstPortRangeStart, &r.DstnatXlatedDstPortRangeEnd)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgComponentVersionRow struct represents rows of the NG_COMPONENT_VERSION table.
type NgComponentVersionRow struct {
    ID	uint
    DeviceVersion	uint
    Component	string
    ComponentVersion	uint
}

// IterateNgComponentVersion provide access to all rows of the NG_COMPONENT_VERSION matching given criteria.
func IterateNgComponentVersion(db *sql.DB, where string, callback func(v *NgComponentVersionRow) error) error {
    query := "SELECT ID,DEVICE_VERSION,COMPONENT,COMPONENT_VERSION FROM NG_COMPONENT_VERSION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgComponentVersionRow
        err := rows.Scan(&r.ID, &r.DeviceVersion, &r.Component, &r.ComponentVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgComponentVersion provide iterator to all rows of the NG_COMPONENT_VERSION matching given criteria.
func RangeNgComponentVersion(db *sql.DB, where string) iter.Seq2[*NgComponentVersionRow, error] {
	return func(yield func(v *NgComponentVersionRow, err error) bool) {
	    query := "SELECT ID,DEVICE_VERSION,COMPONENT,COMPONENT_VERSION FROM NG_COMPONENT_VERSION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgComponentVersionRow
	        err := rows.Scan(&r.ID, &r.DeviceVersion, &r.Component, &r.ComponentVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgContiguousRuleGroupRow struct represents rows of the NG_CONTIGUOUS_RULE_GROUP table.
type NgContiguousRuleGroupRow struct {
    ID	uint
    Uuid	string
    Name	string
    Description	sql.NullString
    FwProfileUuid	string
    RuleType	string
    Version	uint
}

// IterateNgContiguousRuleGroup provide access to all rows of the NG_CONTIGUOUS_RULE_GROUP matching given criteria.
func IterateNgContiguousRuleGroup(db *sql.DB, where string, callback func(v *NgContiguousRuleGroupRow) error) error {
    query := "SELECT ID,UUID,NAME,DESCRIPTION,FW_PROFILE_UUID,RULE_TYPE,VERSION FROM NG_CONTIGUOUS_RULE_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgContiguousRuleGroupRow
        err := rows.Scan(&r.ID, &r.Uuid, &r.Name, &r.Description, &r.FwProfileUuid, &r.RuleType, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgContiguousRuleGroup provide iterator to all rows of the NG_CONTIGUOUS_RULE_GROUP matching given criteria.
func RangeNgContiguousRuleGroup(db *sql.DB, where string) iter.Seq2[*NgContiguousRuleGroupRow, error] {
	return func(yield func(v *NgContiguousRuleGroupRow, err error) bool) {
	    query := "SELECT ID,UUID,NAME,DESCRIPTION,FW_PROFILE_UUID,RULE_TYPE,VERSION FROM NG_CONTIGUOUS_RULE_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgContiguousRuleGroupRow
	        err := rows.Scan(&r.ID, &r.Uuid, &r.Name, &r.Description, &r.FwProfileUuid, &r.RuleType, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgCpruleExcDstAddrRow struct represents rows of the NG_CPRULE_EXC_DST_ADDR table.
type NgCpruleExcDstAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgCpruleExcDstAddr provide access to all rows of the NG_CPRULE_EXC_DST_ADDR matching given criteria.
func IterateNgCpruleExcDstAddr(db *sql.DB, where string, callback func(v *NgCpruleExcDstAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_CPRULE_EXC_DST_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgCpruleExcDstAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgCpruleExcDstAddr provide iterator to all rows of the NG_CPRULE_EXC_DST_ADDR matching given criteria.
func RangeNgCpruleExcDstAddr(db *sql.DB, where string) iter.Seq2[*NgCpruleExcDstAddrRow, error] {
	return func(yield func(v *NgCpruleExcDstAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_CPRULE_EXC_DST_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgCpruleExcDstAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgCpruleExcInstallOnTargetRow struct represents rows of the NG_CPRULE_EXC_INSTALL_ON_TARGET table.
type NgCpruleExcInstallOnTargetRow struct {
    RuleID	uint
    InstallOnTargetID	uint
}

// IterateNgCpruleExcInstallOnTarget provide access to all rows of the NG_CPRULE_EXC_INSTALL_ON_TARGET matching given criteria.
func IterateNgCpruleExcInstallOnTarget(db *sql.DB, where string, callback func(v *NgCpruleExcInstallOnTargetRow) error) error {
    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_CPRULE_EXC_INSTALL_ON_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgCpruleExcInstallOnTargetRow
        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgCpruleExcInstallOnTarget provide iterator to all rows of the NG_CPRULE_EXC_INSTALL_ON_TARGET matching given criteria.
func RangeNgCpruleExcInstallOnTarget(db *sql.DB, where string) iter.Seq2[*NgCpruleExcInstallOnTargetRow, error] {
	return func(yield func(v *NgCpruleExcInstallOnTargetRow, err error) bool) {
	    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_CPRULE_EXC_INSTALL_ON_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgCpruleExcInstallOnTargetRow
	        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgCpruleExcSrcAddrRow struct represents rows of the NG_CPRULE_EXC_SRC_ADDR table.
type NgCpruleExcSrcAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgCpruleExcSrcAddr provide access to all rows of the NG_CPRULE_EXC_SRC_ADDR matching given criteria.
func IterateNgCpruleExcSrcAddr(db *sql.DB, where string, callback func(v *NgCpruleExcSrcAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_CPRULE_EXC_SRC_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgCpruleExcSrcAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgCpruleExcSrcAddr provide iterator to all rows of the NG_CPRULE_EXC_SRC_ADDR matching given criteria.
func RangeNgCpruleExcSrcAddr(db *sql.DB, where string) iter.Seq2[*NgCpruleExcSrcAddrRow, error] {
	return func(yield func(v *NgCpruleExcSrcAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_CPRULE_EXC_SRC_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgCpruleExcSrcAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgCpruleExcSrcZoneRow struct represents rows of the NG_CPRULE_EXC_SRC_ZONE table.
type NgCpruleExcSrcZoneRow struct {
    RuleID	uint
    ZoneID	uint
}

// IterateNgCpruleExcSrcZone provide access to all rows of the NG_CPRULE_EXC_SRC_ZONE matching given criteria.
func IterateNgCpruleExcSrcZone(db *sql.DB, where string, callback func(v *NgCpruleExcSrcZoneRow) error) error {
    query := "SELECT RULE_ID,ZONE_ID FROM NG_CPRULE_EXC_SRC_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgCpruleExcSrcZoneRow
        err := rows.Scan(&r.RuleID, &r.ZoneID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgCpruleExcSrcZone provide iterator to all rows of the NG_CPRULE_EXC_SRC_ZONE matching given criteria.
func RangeNgCpruleExcSrcZone(db *sql.DB, where string) iter.Seq2[*NgCpruleExcSrcZoneRow, error] {
	return func(yield func(v *NgCpruleExcSrcZoneRow, err error) bool) {
	    query := "SELECT RULE_ID,ZONE_ID FROM NG_CPRULE_EXC_SRC_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgCpruleExcSrcZoneRow
	        err := rows.Scan(&r.RuleID, &r.ZoneID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgCpruleIncDstAddrRow struct represents rows of the NG_CPRULE_INC_DST_ADDR table.
type NgCpruleIncDstAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgCpruleIncDstAddr provide access to all rows of the NG_CPRULE_INC_DST_ADDR matching given criteria.
func IterateNgCpruleIncDstAddr(db *sql.DB, where string, callback func(v *NgCpruleIncDstAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_CPRULE_INC_DST_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgCpruleIncDstAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgCpruleIncDstAddr provide iterator to all rows of the NG_CPRULE_INC_DST_ADDR matching given criteria.
func RangeNgCpruleIncDstAddr(db *sql.DB, where string) iter.Seq2[*NgCpruleIncDstAddrRow, error] {
	return func(yield func(v *NgCpruleIncDstAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_CPRULE_INC_DST_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgCpruleIncDstAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgCpruleIncInstallOnTargetRow struct represents rows of the NG_CPRULE_INC_INSTALL_ON_TARGET table.
type NgCpruleIncInstallOnTargetRow struct {
    RuleID	uint
    InstallOnTargetID	uint
}

// IterateNgCpruleIncInstallOnTarget provide access to all rows of the NG_CPRULE_INC_INSTALL_ON_TARGET matching given criteria.
func IterateNgCpruleIncInstallOnTarget(db *sql.DB, where string, callback func(v *NgCpruleIncInstallOnTargetRow) error) error {
    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_CPRULE_INC_INSTALL_ON_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgCpruleIncInstallOnTargetRow
        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgCpruleIncInstallOnTarget provide iterator to all rows of the NG_CPRULE_INC_INSTALL_ON_TARGET matching given criteria.
func RangeNgCpruleIncInstallOnTarget(db *sql.DB, where string) iter.Seq2[*NgCpruleIncInstallOnTargetRow, error] {
	return func(yield func(v *NgCpruleIncInstallOnTargetRow, err error) bool) {
	    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_CPRULE_INC_INSTALL_ON_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgCpruleIncInstallOnTargetRow
	        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgCpruleIncSrcAddrRow struct represents rows of the NG_CPRULE_INC_SRC_ADDR table.
type NgCpruleIncSrcAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgCpruleIncSrcAddr provide access to all rows of the NG_CPRULE_INC_SRC_ADDR matching given criteria.
func IterateNgCpruleIncSrcAddr(db *sql.DB, where string, callback func(v *NgCpruleIncSrcAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_CPRULE_INC_SRC_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgCpruleIncSrcAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgCpruleIncSrcAddr provide iterator to all rows of the NG_CPRULE_INC_SRC_ADDR matching given criteria.
func RangeNgCpruleIncSrcAddr(db *sql.DB, where string) iter.Seq2[*NgCpruleIncSrcAddrRow, error] {
	return func(yield func(v *NgCpruleIncSrcAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_CPRULE_INC_SRC_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgCpruleIncSrcAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgCpruleIncSrcZoneRow struct represents rows of the NG_CPRULE_INC_SRC_ZONE table.
type NgCpruleIncSrcZoneRow struct {
    RuleID	uint
    ZoneID	uint
}

// IterateNgCpruleIncSrcZone provide access to all rows of the NG_CPRULE_INC_SRC_ZONE matching given criteria.
func IterateNgCpruleIncSrcZone(db *sql.DB, where string, callback func(v *NgCpruleIncSrcZoneRow) error) error {
    query := "SELECT RULE_ID,ZONE_ID FROM NG_CPRULE_INC_SRC_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgCpruleIncSrcZoneRow
        err := rows.Scan(&r.RuleID, &r.ZoneID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgCpruleIncSrcZone provide iterator to all rows of the NG_CPRULE_INC_SRC_ZONE matching given criteria.
func RangeNgCpruleIncSrcZone(db *sql.DB, where string) iter.Seq2[*NgCpruleIncSrcZoneRow, error] {
	return func(yield func(v *NgCpruleIncSrcZoneRow, err error) bool) {
	    query := "SELECT RULE_ID,ZONE_ID FROM NG_CPRULE_INC_SRC_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgCpruleIncSrcZoneRow
	        err := rows.Scan(&r.RuleID, &r.ZoneID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgDashboardRow struct represents rows of the NG_DASHBOARD table.
type NgDashboardRow struct {
    ID	uint
    Username	string
    IsDefault	sql.NullByte
    LayoutXml	sql.NullString
}

// IterateNgDashboard provide access to all rows of the NG_DASHBOARD matching given criteria.
func IterateNgDashboard(db *sql.DB, where string, callback func(v *NgDashboardRow) error) error {
    query := "SELECT ID,USERNAME,IS_DEFAULT,LAYOUT_XML FROM NG_DASHBOARD"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgDashboardRow
        err := rows.Scan(&r.ID, &r.Username, &r.IsDefault, &r.LayoutXml)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgDashboard provide iterator to all rows of the NG_DASHBOARD matching given criteria.
func RangeNgDashboard(db *sql.DB, where string) iter.Seq2[*NgDashboardRow, error] {
	return func(yield func(v *NgDashboardRow, err error) bool) {
	    query := "SELECT ID,USERNAME,IS_DEFAULT,LAYOUT_XML FROM NG_DASHBOARD"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgDashboardRow
	        err := rows.Scan(&r.ID, &r.Username, &r.IsDefault, &r.LayoutXml)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgDashboardGadgetRow struct represents rows of the NG_DASHBOARD_GADGET table.
type NgDashboardGadgetRow struct {
    ID	uint
    Name	sql.NullString
    PaletteName	sql.NullString
    Description	sql.NullString
    Category	string
    PaletteIcon	sql.NullString
    TitleIcon	sql.NullString
    IsOnPalette	sql.NullByte
    Renderer	sql.NullString
    RendererData	sql.NullString
    Provider	sql.NullString
    ProviderData	sql.NullString
    ChartConfig	sql.NullString
}

// IterateNgDashboardGadget provide access to all rows of the NG_DASHBOARD_GADGET matching given criteria.
func IterateNgDashboardGadget(db *sql.DB, where string, callback func(v *NgDashboardGadgetRow) error) error {
    query := "SELECT ID,NAME,PALETTE_NAME,DESCRIPTION,CATEGORY,PALETTE_ICON,TITLE_ICON,IS_ON_PALETTE,RENDERER,RENDERER_DATA,PROVIDER,PROVIDER_DATA,CHART_CONFIG FROM NG_DASHBOARD_GADGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgDashboardGadgetRow
        err := rows.Scan(&r.ID, &r.Name, &r.PaletteName, &r.Description, &r.Category, &r.PaletteIcon, &r.TitleIcon, &r.IsOnPalette, &r.Renderer, &r.RendererData, &r.Provider, &r.ProviderData, &r.ChartConfig)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgDashboardGadget provide iterator to all rows of the NG_DASHBOARD_GADGET matching given criteria.
func RangeNgDashboardGadget(db *sql.DB, where string) iter.Seq2[*NgDashboardGadgetRow, error] {
	return func(yield func(v *NgDashboardGadgetRow, err error) bool) {
	    query := "SELECT ID,NAME,PALETTE_NAME,DESCRIPTION,CATEGORY,PALETTE_ICON,TITLE_ICON,IS_ON_PALETTE,RENDERER,RENDERER_DATA,PROVIDER,PROVIDER_DATA,CHART_CONFIG FROM NG_DASHBOARD_GADGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgDashboardGadgetRow
	        err := rows.Scan(&r.ID, &r.Name, &r.PaletteName, &r.Description, &r.Category, &r.PaletteIcon, &r.TitleIcon, &r.IsOnPalette, &r.Renderer, &r.RendererData, &r.Provider, &r.ProviderData, &r.ChartConfig)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgDashboardGadgetConfigRow struct represents rows of the NG_DASHBOARD_GADGET_CONFIG table.
type NgDashboardGadgetConfigRow struct {
    ID	int
    GadgetID	sql.NullInt32
    DashboardID	sql.NullInt32
    Name	sql.NullString
    IsDefault	sql.NullByte
    ConfigXml	sql.NullString
}

// IterateNgDashboardGadgetConfig provide access to all rows of the NG_DASHBOARD_GADGET_CONFIG matching given criteria.
func IterateNgDashboardGadgetConfig(db *sql.DB, where string, callback func(v *NgDashboardGadgetConfigRow) error) error {
    query := "SELECT ID,GADGET_ID,DASHBOARD_ID,NAME,IS_DEFAULT,CONFIG_XML FROM NG_DASHBOARD_GADGET_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgDashboardGadgetConfigRow
        err := rows.Scan(&r.ID, &r.GadgetID, &r.DashboardID, &r.Name, &r.IsDefault, &r.ConfigXml)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgDashboardGadgetConfig provide iterator to all rows of the NG_DASHBOARD_GADGET_CONFIG matching given criteria.
func RangeNgDashboardGadgetConfig(db *sql.DB, where string) iter.Seq2[*NgDashboardGadgetConfigRow, error] {
	return func(yield func(v *NgDashboardGadgetConfigRow, err error) bool) {
	    query := "SELECT ID,GADGET_ID,DASHBOARD_ID,NAME,IS_DEFAULT,CONFIG_XML FROM NG_DASHBOARD_GADGET_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgDashboardGadgetConfigRow
	        err := rows.Scan(&r.ID, &r.GadgetID, &r.DashboardID, &r.Name, &r.IsDefault, &r.ConfigXml)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgDeviceDistInspectionProfileRow struct represents rows of the NG_DEVICE_DIST_INSPECTION_PROFILE table.
type NgDeviceDistInspectionProfileRow struct {
    DeviceID	string
    ProfileUuid	string
    SnapshotVersion	string
    ProfileName	string
    IsRep	int8
    DeviceProfileUuid	string
    CompleteTime	int64
}

// IterateNgDeviceDistInspectionProfile provide access to all rows of the NG_DEVICE_DIST_INSPECTION_PROFILE matching given criteria.
func IterateNgDeviceDistInspectionProfile(db *sql.DB, where string, callback func(v *NgDeviceDistInspectionProfileRow) error) error {
    query := "SELECT DEVICE_ID,PROFILE_UUID,SNAPSHOT_VERSION,PROFILE_NAME,IS_REP,DEVICE_PROFILE_UUID,COMPLETE_TIME FROM NG_DEVICE_DIST_INSPECTION_PROFILE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgDeviceDistInspectionProfileRow
        err := rows.Scan(&r.DeviceID, &r.ProfileUuid, &r.SnapshotVersion, &r.ProfileName, &r.IsRep, &r.DeviceProfileUuid, &r.CompleteTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgDeviceDistInspectionProfile provide iterator to all rows of the NG_DEVICE_DIST_INSPECTION_PROFILE matching given criteria.
func RangeNgDeviceDistInspectionProfile(db *sql.DB, where string) iter.Seq2[*NgDeviceDistInspectionProfileRow, error] {
	return func(yield func(v *NgDeviceDistInspectionProfileRow, err error) bool) {
	    query := "SELECT DEVICE_ID,PROFILE_UUID,SNAPSHOT_VERSION,PROFILE_NAME,IS_REP,DEVICE_PROFILE_UUID,COMPLETE_TIME FROM NG_DEVICE_DIST_INSPECTION_PROFILE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgDeviceDistInspectionProfileRow
	        err := rows.Scan(&r.DeviceID, &r.ProfileUuid, &r.SnapshotVersion, &r.ProfileName, &r.IsRep, &r.DeviceProfileUuid, &r.CompleteTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgDomainNameRow struct represents rows of the NG_DOMAIN_NAME table.
type NgDomainNameRow struct {
    ID	uint
    Uuid	string
    DomainName	string
    Version	uint
}

// IterateNgDomainName provide access to all rows of the NG_DOMAIN_NAME matching given criteria.
func IterateNgDomainName(db *sql.DB, where string, callback func(v *NgDomainNameRow) error) error {
    query := "SELECT ID,UUID,DOMAIN_NAME,VERSION FROM NG_DOMAIN_NAME"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgDomainNameRow
        err := rows.Scan(&r.ID, &r.Uuid, &r.DomainName, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgDomainName provide iterator to all rows of the NG_DOMAIN_NAME matching given criteria.
func RangeNgDomainName(db *sql.DB, where string) iter.Seq2[*NgDomainNameRow, error] {
	return func(yield func(v *NgDomainNameRow, err error) bool) {
	    query := "SELECT ID,UUID,DOMAIN_NAME,VERSION FROM NG_DOMAIN_NAME"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgDomainNameRow
	        err := rows.Scan(&r.ID, &r.Uuid, &r.DomainName, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgDstNatruleExcDstAddrRow struct represents rows of the NG_DST_NATRULE_EXC_DST_ADDR table.
type NgDstNatruleExcDstAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgDstNatruleExcDstAddr provide access to all rows of the NG_DST_NATRULE_EXC_DST_ADDR matching given criteria.
func IterateNgDstNatruleExcDstAddr(db *sql.DB, where string, callback func(v *NgDstNatruleExcDstAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_DST_NATRULE_EXC_DST_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgDstNatruleExcDstAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgDstNatruleExcDstAddr provide iterator to all rows of the NG_DST_NATRULE_EXC_DST_ADDR matching given criteria.
func RangeNgDstNatruleExcDstAddr(db *sql.DB, where string) iter.Seq2[*NgDstNatruleExcDstAddrRow, error] {
	return func(yield func(v *NgDstNatruleExcDstAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_DST_NATRULE_EXC_DST_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgDstNatruleExcDstAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgDstNatruleExcInstallOnTargetRow struct represents rows of the NG_DST_NATRULE_EXC_INSTALL_ON_TARGET table.
type NgDstNatruleExcInstallOnTargetRow struct {
    RuleID	uint
    InstallOnTargetID	uint
}

// IterateNgDstNatruleExcInstallOnTarget provide access to all rows of the NG_DST_NATRULE_EXC_INSTALL_ON_TARGET matching given criteria.
func IterateNgDstNatruleExcInstallOnTarget(db *sql.DB, where string, callback func(v *NgDstNatruleExcInstallOnTargetRow) error) error {
    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_DST_NATRULE_EXC_INSTALL_ON_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgDstNatruleExcInstallOnTargetRow
        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgDstNatruleExcInstallOnTarget provide iterator to all rows of the NG_DST_NATRULE_EXC_INSTALL_ON_TARGET matching given criteria.
func RangeNgDstNatruleExcInstallOnTarget(db *sql.DB, where string) iter.Seq2[*NgDstNatruleExcInstallOnTargetRow, error] {
	return func(yield func(v *NgDstNatruleExcInstallOnTargetRow, err error) bool) {
	    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_DST_NATRULE_EXC_INSTALL_ON_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgDstNatruleExcInstallOnTargetRow
	        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgDstNatruleExcSrcAddrRow struct represents rows of the NG_DST_NATRULE_EXC_SRC_ADDR table.
type NgDstNatruleExcSrcAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgDstNatruleExcSrcAddr provide access to all rows of the NG_DST_NATRULE_EXC_SRC_ADDR matching given criteria.
func IterateNgDstNatruleExcSrcAddr(db *sql.DB, where string, callback func(v *NgDstNatruleExcSrcAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_DST_NATRULE_EXC_SRC_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgDstNatruleExcSrcAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgDstNatruleExcSrcAddr provide iterator to all rows of the NG_DST_NATRULE_EXC_SRC_ADDR matching given criteria.
func RangeNgDstNatruleExcSrcAddr(db *sql.DB, where string) iter.Seq2[*NgDstNatruleExcSrcAddrRow, error] {
	return func(yield func(v *NgDstNatruleExcSrcAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_DST_NATRULE_EXC_SRC_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgDstNatruleExcSrcAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgDstNatruleExcSrcZoneRow struct represents rows of the NG_DST_NATRULE_EXC_SRC_ZONE table.
type NgDstNatruleExcSrcZoneRow struct {
    RuleID	uint
    ZoneID	uint
}

// IterateNgDstNatruleExcSrcZone provide access to all rows of the NG_DST_NATRULE_EXC_SRC_ZONE matching given criteria.
func IterateNgDstNatruleExcSrcZone(db *sql.DB, where string, callback func(v *NgDstNatruleExcSrcZoneRow) error) error {
    query := "SELECT RULE_ID,ZONE_ID FROM NG_DST_NATRULE_EXC_SRC_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgDstNatruleExcSrcZoneRow
        err := rows.Scan(&r.RuleID, &r.ZoneID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgDstNatruleExcSrcZone provide iterator to all rows of the NG_DST_NATRULE_EXC_SRC_ZONE matching given criteria.
func RangeNgDstNatruleExcSrcZone(db *sql.DB, where string) iter.Seq2[*NgDstNatruleExcSrcZoneRow, error] {
	return func(yield func(v *NgDstNatruleExcSrcZoneRow, err error) bool) {
	    query := "SELECT RULE_ID,ZONE_ID FROM NG_DST_NATRULE_EXC_SRC_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgDstNatruleExcSrcZoneRow
	        err := rows.Scan(&r.RuleID, &r.ZoneID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgDstNatruleIncDstAddrRow struct represents rows of the NG_DST_NATRULE_INC_DST_ADDR table.
type NgDstNatruleIncDstAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgDstNatruleIncDstAddr provide access to all rows of the NG_DST_NATRULE_INC_DST_ADDR matching given criteria.
func IterateNgDstNatruleIncDstAddr(db *sql.DB, where string, callback func(v *NgDstNatruleIncDstAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_DST_NATRULE_INC_DST_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgDstNatruleIncDstAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgDstNatruleIncDstAddr provide iterator to all rows of the NG_DST_NATRULE_INC_DST_ADDR matching given criteria.
func RangeNgDstNatruleIncDstAddr(db *sql.DB, where string) iter.Seq2[*NgDstNatruleIncDstAddrRow, error] {
	return func(yield func(v *NgDstNatruleIncDstAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_DST_NATRULE_INC_DST_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgDstNatruleIncDstAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgDstNatruleIncInstallOnTargetRow struct represents rows of the NG_DST_NATRULE_INC_INSTALL_ON_TARGET table.
type NgDstNatruleIncInstallOnTargetRow struct {
    RuleID	uint
    InstallOnTargetID	uint
}

// IterateNgDstNatruleIncInstallOnTarget provide access to all rows of the NG_DST_NATRULE_INC_INSTALL_ON_TARGET matching given criteria.
func IterateNgDstNatruleIncInstallOnTarget(db *sql.DB, where string, callback func(v *NgDstNatruleIncInstallOnTargetRow) error) error {
    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_DST_NATRULE_INC_INSTALL_ON_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgDstNatruleIncInstallOnTargetRow
        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgDstNatruleIncInstallOnTarget provide iterator to all rows of the NG_DST_NATRULE_INC_INSTALL_ON_TARGET matching given criteria.
func RangeNgDstNatruleIncInstallOnTarget(db *sql.DB, where string) iter.Seq2[*NgDstNatruleIncInstallOnTargetRow, error] {
	return func(yield func(v *NgDstNatruleIncInstallOnTargetRow, err error) bool) {
	    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_DST_NATRULE_INC_INSTALL_ON_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgDstNatruleIncInstallOnTargetRow
	        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgDstNatruleIncSrcAddrRow struct represents rows of the NG_DST_NATRULE_INC_SRC_ADDR table.
type NgDstNatruleIncSrcAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgDstNatruleIncSrcAddr provide access to all rows of the NG_DST_NATRULE_INC_SRC_ADDR matching given criteria.
func IterateNgDstNatruleIncSrcAddr(db *sql.DB, where string, callback func(v *NgDstNatruleIncSrcAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_DST_NATRULE_INC_SRC_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgDstNatruleIncSrcAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgDstNatruleIncSrcAddr provide iterator to all rows of the NG_DST_NATRULE_INC_SRC_ADDR matching given criteria.
func RangeNgDstNatruleIncSrcAddr(db *sql.DB, where string) iter.Seq2[*NgDstNatruleIncSrcAddrRow, error] {
	return func(yield func(v *NgDstNatruleIncSrcAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_DST_NATRULE_INC_SRC_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgDstNatruleIncSrcAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgDstNatruleIncSrcZoneRow struct represents rows of the NG_DST_NATRULE_INC_SRC_ZONE table.
type NgDstNatruleIncSrcZoneRow struct {
    RuleID	uint
    ZoneID	uint
}

// IterateNgDstNatruleIncSrcZone provide access to all rows of the NG_DST_NATRULE_INC_SRC_ZONE matching given criteria.
func IterateNgDstNatruleIncSrcZone(db *sql.DB, where string, callback func(v *NgDstNatruleIncSrcZoneRow) error) error {
    query := "SELECT RULE_ID,ZONE_ID FROM NG_DST_NATRULE_INC_SRC_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgDstNatruleIncSrcZoneRow
        err := rows.Scan(&r.RuleID, &r.ZoneID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgDstNatruleIncSrcZone provide iterator to all rows of the NG_DST_NATRULE_INC_SRC_ZONE matching given criteria.
func RangeNgDstNatruleIncSrcZone(db *sql.DB, where string) iter.Seq2[*NgDstNatruleIncSrcZoneRow, error] {
	return func(yield func(v *NgDstNatruleIncSrcZoneRow, err error) bool) {
	    query := "SELECT RULE_ID,ZONE_ID FROM NG_DST_NATRULE_INC_SRC_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgDstNatruleIncSrcZoneRow
	        err := rows.Scan(&r.RuleID, &r.ZoneID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFirewallApplicationGroupRow struct represents rows of the NG_FIREWALL_APPLICATION_GROUP table.
type NgFirewallApplicationGroupRow struct {
    ID	uint
    CategoryID	string
    Version	uint
}

// IterateNgFirewallApplicationGroup provide access to all rows of the NG_FIREWALL_APPLICATION_GROUP matching given criteria.
func IterateNgFirewallApplicationGroup(db *sql.DB, where string, callback func(v *NgFirewallApplicationGroupRow) error) error {
    query := "SELECT ID,CATEGORY_ID,VERSION FROM NG_FIREWALL_APPLICATION_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFirewallApplicationGroupRow
        err := rows.Scan(&r.ID, &r.CategoryID, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFirewallApplicationGroup provide iterator to all rows of the NG_FIREWALL_APPLICATION_GROUP matching given criteria.
func RangeNgFirewallApplicationGroup(db *sql.DB, where string) iter.Seq2[*NgFirewallApplicationGroupRow, error] {
	return func(yield func(v *NgFirewallApplicationGroupRow, err error) bool) {
	    query := "SELECT ID,CATEGORY_ID,VERSION FROM NG_FIREWALL_APPLICATION_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFirewallApplicationGroupRow
	        err := rows.Scan(&r.ID, &r.CategoryID, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFirewallProfileRow struct represents rows of the NG_FIREWALL_PROFILE table.
type NgFirewallProfileRow struct {
    AbstractProfileID	uint
    DefaultFirewallRuleActionsetID	string
    UnclassifiedTrafficSecInspectionProfileUuid	sql.NullString
    UnclassifiedTrafficRepInspectionProfileUuid	sql.NullString
    UnclassifiedTrafficSecInspectionType	string
    UnclassifiedTrafficRepInspectionType	string
}

// IterateNgFirewallProfile provide access to all rows of the NG_FIREWALL_PROFILE matching given criteria.
func IterateNgFirewallProfile(db *sql.DB, where string, callback func(v *NgFirewallProfileRow) error) error {
    query := "SELECT ABSTRACT_PROFILE_ID,DEFAULT_FIREWALL_RULE_ACTIONSET_ID,UNCLASSIFIED_TRAFFIC_SEC_INSPECTION_PROFILE_UUID,UNCLASSIFIED_TRAFFIC_REP_INSPECTION_PROFILE_UUID,UNCLASSIFIED_TRAFFIC_SEC_INSPECTION_TYPE,UNCLASSIFIED_TRAFFIC_REP_INSPECTION_TYPE FROM NG_FIREWALL_PROFILE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFirewallProfileRow
        err := rows.Scan(&r.AbstractProfileID, &r.DefaultFirewallRuleActionsetID, &r.UnclassifiedTrafficSecInspectionProfileUuid, &r.UnclassifiedTrafficRepInspectionProfileUuid, &r.UnclassifiedTrafficSecInspectionType, &r.UnclassifiedTrafficRepInspectionType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFirewallProfile provide iterator to all rows of the NG_FIREWALL_PROFILE matching given criteria.
func RangeNgFirewallProfile(db *sql.DB, where string) iter.Seq2[*NgFirewallProfileRow, error] {
	return func(yield func(v *NgFirewallProfileRow, err error) bool) {
	    query := "SELECT ABSTRACT_PROFILE_ID,DEFAULT_FIREWALL_RULE_ACTIONSET_ID,UNCLASSIFIED_TRAFFIC_SEC_INSPECTION_PROFILE_UUID,UNCLASSIFIED_TRAFFIC_REP_INSPECTION_PROFILE_UUID,UNCLASSIFIED_TRAFFIC_SEC_INSPECTION_TYPE,UNCLASSIFIED_TRAFFIC_REP_INSPECTION_TYPE FROM NG_FIREWALL_PROFILE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFirewallProfileRow
	        err := rows.Scan(&r.AbstractProfileID, &r.DefaultFirewallRuleActionsetID, &r.UnclassifiedTrafficSecInspectionProfileUuid, &r.UnclassifiedTrafficRepInspectionProfileUuid, &r.UnclassifiedTrafficSecInspectionType, &r.UnclassifiedTrafficRepInspectionType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFirewallUserRow struct represents rows of the NG_FIREWALL_USER table.
type NgFirewallUserRow struct {
    ID	uint
    UserName	string
    UserType	string
    Uuid	string
    Version	uint
}

// IterateNgFirewallUser provide access to all rows of the NG_FIREWALL_USER matching given criteria.
func IterateNgFirewallUser(db *sql.DB, where string, callback func(v *NgFirewallUserRow) error) error {
    query := "SELECT ID,USER_NAME,USER_TYPE,UUID,VERSION FROM NG_FIREWALL_USER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFirewallUserRow
        err := rows.Scan(&r.ID, &r.UserName, &r.UserType, &r.Uuid, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFirewallUser provide iterator to all rows of the NG_FIREWALL_USER matching given criteria.
func RangeNgFirewallUser(db *sql.DB, where string) iter.Seq2[*NgFirewallUserRow, error] {
	return func(yield func(v *NgFirewallUserRow, err error) bool) {
	    query := "SELECT ID,USER_NAME,USER_TYPE,UUID,VERSION FROM NG_FIREWALL_USER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFirewallUserRow
	        err := rows.Scan(&r.ID, &r.UserName, &r.UserType, &r.Uuid, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleExcDstAddrRow struct represents rows of the NG_FWRULE_EXC_DST_ADDR table.
type NgFwruleExcDstAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgFwruleExcDstAddr provide access to all rows of the NG_FWRULE_EXC_DST_ADDR matching given criteria.
func IterateNgFwruleExcDstAddr(db *sql.DB, where string, callback func(v *NgFwruleExcDstAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_FWRULE_EXC_DST_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleExcDstAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleExcDstAddr provide iterator to all rows of the NG_FWRULE_EXC_DST_ADDR matching given criteria.
func RangeNgFwruleExcDstAddr(db *sql.DB, where string) iter.Seq2[*NgFwruleExcDstAddrRow, error] {
	return func(yield func(v *NgFwruleExcDstAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_FWRULE_EXC_DST_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleExcDstAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleExcDstZoneRow struct represents rows of the NG_FWRULE_EXC_DST_ZONE table.
type NgFwruleExcDstZoneRow struct {
    RuleID	uint
    ZoneID	uint
}

// IterateNgFwruleExcDstZone provide access to all rows of the NG_FWRULE_EXC_DST_ZONE matching given criteria.
func IterateNgFwruleExcDstZone(db *sql.DB, where string, callback func(v *NgFwruleExcDstZoneRow) error) error {
    query := "SELECT RULE_ID,ZONE_ID FROM NG_FWRULE_EXC_DST_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleExcDstZoneRow
        err := rows.Scan(&r.RuleID, &r.ZoneID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleExcDstZone provide iterator to all rows of the NG_FWRULE_EXC_DST_ZONE matching given criteria.
func RangeNgFwruleExcDstZone(db *sql.DB, where string) iter.Seq2[*NgFwruleExcDstZoneRow, error] {
	return func(yield func(v *NgFwruleExcDstZoneRow, err error) bool) {
	    query := "SELECT RULE_ID,ZONE_ID FROM NG_FWRULE_EXC_DST_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleExcDstZoneRow
	        err := rows.Scan(&r.RuleID, &r.ZoneID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleExcFirewallUserRow struct represents rows of the NG_FWRULE_EXC_FIREWALL_USER table.
type NgFwruleExcFirewallUserRow struct {
    RuleID	uint
    FwuserID	uint
}

// IterateNgFwruleExcFirewallUser provide access to all rows of the NG_FWRULE_EXC_FIREWALL_USER matching given criteria.
func IterateNgFwruleExcFirewallUser(db *sql.DB, where string, callback func(v *NgFwruleExcFirewallUserRow) error) error {
    query := "SELECT RULE_ID,FWUSER_ID FROM NG_FWRULE_EXC_FIREWALL_USER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleExcFirewallUserRow
        err := rows.Scan(&r.RuleID, &r.FwuserID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleExcFirewallUser provide iterator to all rows of the NG_FWRULE_EXC_FIREWALL_USER matching given criteria.
func RangeNgFwruleExcFirewallUser(db *sql.DB, where string) iter.Seq2[*NgFwruleExcFirewallUserRow, error] {
	return func(yield func(v *NgFwruleExcFirewallUserRow, err error) bool) {
	    query := "SELECT RULE_ID,FWUSER_ID FROM NG_FWRULE_EXC_FIREWALL_USER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleExcFirewallUserRow
	        err := rows.Scan(&r.RuleID, &r.FwuserID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleExcInstallOnTargetRow struct represents rows of the NG_FWRULE_EXC_INSTALL_ON_TARGET table.
type NgFwruleExcInstallOnTargetRow struct {
    RuleID	uint
    InstallOnTargetID	uint
}

// IterateNgFwruleExcInstallOnTarget provide access to all rows of the NG_FWRULE_EXC_INSTALL_ON_TARGET matching given criteria.
func IterateNgFwruleExcInstallOnTarget(db *sql.DB, where string, callback func(v *NgFwruleExcInstallOnTargetRow) error) error {
    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_FWRULE_EXC_INSTALL_ON_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleExcInstallOnTargetRow
        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleExcInstallOnTarget provide iterator to all rows of the NG_FWRULE_EXC_INSTALL_ON_TARGET matching given criteria.
func RangeNgFwruleExcInstallOnTarget(db *sql.DB, where string) iter.Seq2[*NgFwruleExcInstallOnTargetRow, error] {
	return func(yield func(v *NgFwruleExcInstallOnTargetRow, err error) bool) {
	    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_FWRULE_EXC_INSTALL_ON_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleExcInstallOnTargetRow
	        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleExcScheduleRow struct represents rows of the NG_FWRULE_EXC_SCHEDULE table.
type NgFwruleExcScheduleRow struct {
    RuleID	uint
    ScheduleID	uint
}

// IterateNgFwruleExcSchedule provide access to all rows of the NG_FWRULE_EXC_SCHEDULE matching given criteria.
func IterateNgFwruleExcSchedule(db *sql.DB, where string, callback func(v *NgFwruleExcScheduleRow) error) error {
    query := "SELECT RULE_ID,SCHEDULE_ID FROM NG_FWRULE_EXC_SCHEDULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleExcScheduleRow
        err := rows.Scan(&r.RuleID, &r.ScheduleID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleExcSchedule provide iterator to all rows of the NG_FWRULE_EXC_SCHEDULE matching given criteria.
func RangeNgFwruleExcSchedule(db *sql.DB, where string) iter.Seq2[*NgFwruleExcScheduleRow, error] {
	return func(yield func(v *NgFwruleExcScheduleRow, err error) bool) {
	    query := "SELECT RULE_ID,SCHEDULE_ID FROM NG_FWRULE_EXC_SCHEDULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleExcScheduleRow
	        err := rows.Scan(&r.RuleID, &r.ScheduleID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleExcServiceRow struct represents rows of the NG_FWRULE_EXC_SERVICE table.
type NgFwruleExcServiceRow struct {
    RuleID	uint
    NamedServiceID	uint
}

// IterateNgFwruleExcService provide access to all rows of the NG_FWRULE_EXC_SERVICE matching given criteria.
func IterateNgFwruleExcService(db *sql.DB, where string, callback func(v *NgFwruleExcServiceRow) error) error {
    query := "SELECT RULE_ID,NAMED_SERVICE_ID FROM NG_FWRULE_EXC_SERVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleExcServiceRow
        err := rows.Scan(&r.RuleID, &r.NamedServiceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleExcService provide iterator to all rows of the NG_FWRULE_EXC_SERVICE matching given criteria.
func RangeNgFwruleExcService(db *sql.DB, where string) iter.Seq2[*NgFwruleExcServiceRow, error] {
	return func(yield func(v *NgFwruleExcServiceRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_SERVICE_ID FROM NG_FWRULE_EXC_SERVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleExcServiceRow
	        err := rows.Scan(&r.RuleID, &r.NamedServiceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleExcSrcAddrRow struct represents rows of the NG_FWRULE_EXC_SRC_ADDR table.
type NgFwruleExcSrcAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgFwruleExcSrcAddr provide access to all rows of the NG_FWRULE_EXC_SRC_ADDR matching given criteria.
func IterateNgFwruleExcSrcAddr(db *sql.DB, where string, callback func(v *NgFwruleExcSrcAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_FWRULE_EXC_SRC_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleExcSrcAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleExcSrcAddr provide iterator to all rows of the NG_FWRULE_EXC_SRC_ADDR matching given criteria.
func RangeNgFwruleExcSrcAddr(db *sql.DB, where string) iter.Seq2[*NgFwruleExcSrcAddrRow, error] {
	return func(yield func(v *NgFwruleExcSrcAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_FWRULE_EXC_SRC_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleExcSrcAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleExcSrcZoneRow struct represents rows of the NG_FWRULE_EXC_SRC_ZONE table.
type NgFwruleExcSrcZoneRow struct {
    RuleID	uint
    ZoneID	uint
}

// IterateNgFwruleExcSrcZone provide access to all rows of the NG_FWRULE_EXC_SRC_ZONE matching given criteria.
func IterateNgFwruleExcSrcZone(db *sql.DB, where string, callback func(v *NgFwruleExcSrcZoneRow) error) error {
    query := "SELECT RULE_ID,ZONE_ID FROM NG_FWRULE_EXC_SRC_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleExcSrcZoneRow
        err := rows.Scan(&r.RuleID, &r.ZoneID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleExcSrcZone provide iterator to all rows of the NG_FWRULE_EXC_SRC_ZONE matching given criteria.
func RangeNgFwruleExcSrcZone(db *sql.DB, where string) iter.Seq2[*NgFwruleExcSrcZoneRow, error] {
	return func(yield func(v *NgFwruleExcSrcZoneRow, err error) bool) {
	    query := "SELECT RULE_ID,ZONE_ID FROM NG_FWRULE_EXC_SRC_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleExcSrcZoneRow
	        err := rows.Scan(&r.RuleID, &r.ZoneID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleIncDstAddrRow struct represents rows of the NG_FWRULE_INC_DST_ADDR table.
type NgFwruleIncDstAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgFwruleIncDstAddr provide access to all rows of the NG_FWRULE_INC_DST_ADDR matching given criteria.
func IterateNgFwruleIncDstAddr(db *sql.DB, where string, callback func(v *NgFwruleIncDstAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_FWRULE_INC_DST_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleIncDstAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleIncDstAddr provide iterator to all rows of the NG_FWRULE_INC_DST_ADDR matching given criteria.
func RangeNgFwruleIncDstAddr(db *sql.DB, where string) iter.Seq2[*NgFwruleIncDstAddrRow, error] {
	return func(yield func(v *NgFwruleIncDstAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_FWRULE_INC_DST_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleIncDstAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleIncDstZoneRow struct represents rows of the NG_FWRULE_INC_DST_ZONE table.
type NgFwruleIncDstZoneRow struct {
    RuleID	uint
    ZoneID	uint
}

// IterateNgFwruleIncDstZone provide access to all rows of the NG_FWRULE_INC_DST_ZONE matching given criteria.
func IterateNgFwruleIncDstZone(db *sql.DB, where string, callback func(v *NgFwruleIncDstZoneRow) error) error {
    query := "SELECT RULE_ID,ZONE_ID FROM NG_FWRULE_INC_DST_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleIncDstZoneRow
        err := rows.Scan(&r.RuleID, &r.ZoneID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleIncDstZone provide iterator to all rows of the NG_FWRULE_INC_DST_ZONE matching given criteria.
func RangeNgFwruleIncDstZone(db *sql.DB, where string) iter.Seq2[*NgFwruleIncDstZoneRow, error] {
	return func(yield func(v *NgFwruleIncDstZoneRow, err error) bool) {
	    query := "SELECT RULE_ID,ZONE_ID FROM NG_FWRULE_INC_DST_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleIncDstZoneRow
	        err := rows.Scan(&r.RuleID, &r.ZoneID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleIncFirewallUserRow struct represents rows of the NG_FWRULE_INC_FIREWALL_USER table.
type NgFwruleIncFirewallUserRow struct {
    RuleID	uint
    FwuserID	uint
}

// IterateNgFwruleIncFirewallUser provide access to all rows of the NG_FWRULE_INC_FIREWALL_USER matching given criteria.
func IterateNgFwruleIncFirewallUser(db *sql.DB, where string, callback func(v *NgFwruleIncFirewallUserRow) error) error {
    query := "SELECT RULE_ID,FWUSER_ID FROM NG_FWRULE_INC_FIREWALL_USER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleIncFirewallUserRow
        err := rows.Scan(&r.RuleID, &r.FwuserID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleIncFirewallUser provide iterator to all rows of the NG_FWRULE_INC_FIREWALL_USER matching given criteria.
func RangeNgFwruleIncFirewallUser(db *sql.DB, where string) iter.Seq2[*NgFwruleIncFirewallUserRow, error] {
	return func(yield func(v *NgFwruleIncFirewallUserRow, err error) bool) {
	    query := "SELECT RULE_ID,FWUSER_ID FROM NG_FWRULE_INC_FIREWALL_USER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleIncFirewallUserRow
	        err := rows.Scan(&r.RuleID, &r.FwuserID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleIncInstallOnTargetRow struct represents rows of the NG_FWRULE_INC_INSTALL_ON_TARGET table.
type NgFwruleIncInstallOnTargetRow struct {
    RuleID	uint
    InstallOnTargetID	uint
}

// IterateNgFwruleIncInstallOnTarget provide access to all rows of the NG_FWRULE_INC_INSTALL_ON_TARGET matching given criteria.
func IterateNgFwruleIncInstallOnTarget(db *sql.DB, where string, callback func(v *NgFwruleIncInstallOnTargetRow) error) error {
    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_FWRULE_INC_INSTALL_ON_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleIncInstallOnTargetRow
        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleIncInstallOnTarget provide iterator to all rows of the NG_FWRULE_INC_INSTALL_ON_TARGET matching given criteria.
func RangeNgFwruleIncInstallOnTarget(db *sql.DB, where string) iter.Seq2[*NgFwruleIncInstallOnTargetRow, error] {
	return func(yield func(v *NgFwruleIncInstallOnTargetRow, err error) bool) {
	    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_FWRULE_INC_INSTALL_ON_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleIncInstallOnTargetRow
	        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleIncScheduleRow struct represents rows of the NG_FWRULE_INC_SCHEDULE table.
type NgFwruleIncScheduleRow struct {
    RuleID	uint
    ScheduleID	uint
}

// IterateNgFwruleIncSchedule provide access to all rows of the NG_FWRULE_INC_SCHEDULE matching given criteria.
func IterateNgFwruleIncSchedule(db *sql.DB, where string, callback func(v *NgFwruleIncScheduleRow) error) error {
    query := "SELECT RULE_ID,SCHEDULE_ID FROM NG_FWRULE_INC_SCHEDULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleIncScheduleRow
        err := rows.Scan(&r.RuleID, &r.ScheduleID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleIncSchedule provide iterator to all rows of the NG_FWRULE_INC_SCHEDULE matching given criteria.
func RangeNgFwruleIncSchedule(db *sql.DB, where string) iter.Seq2[*NgFwruleIncScheduleRow, error] {
	return func(yield func(v *NgFwruleIncScheduleRow, err error) bool) {
	    query := "SELECT RULE_ID,SCHEDULE_ID FROM NG_FWRULE_INC_SCHEDULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleIncScheduleRow
	        err := rows.Scan(&r.RuleID, &r.ScheduleID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleIncServiceRow struct represents rows of the NG_FWRULE_INC_SERVICE table.
type NgFwruleIncServiceRow struct {
    RuleID	uint
    NamedServiceID	uint
}

// IterateNgFwruleIncService provide access to all rows of the NG_FWRULE_INC_SERVICE matching given criteria.
func IterateNgFwruleIncService(db *sql.DB, where string, callback func(v *NgFwruleIncServiceRow) error) error {
    query := "SELECT RULE_ID,NAMED_SERVICE_ID FROM NG_FWRULE_INC_SERVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleIncServiceRow
        err := rows.Scan(&r.RuleID, &r.NamedServiceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleIncService provide iterator to all rows of the NG_FWRULE_INC_SERVICE matching given criteria.
func RangeNgFwruleIncService(db *sql.DB, where string) iter.Seq2[*NgFwruleIncServiceRow, error] {
	return func(yield func(v *NgFwruleIncServiceRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_SERVICE_ID FROM NG_FWRULE_INC_SERVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleIncServiceRow
	        err := rows.Scan(&r.RuleID, &r.NamedServiceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleIncSrcAddrRow struct represents rows of the NG_FWRULE_INC_SRC_ADDR table.
type NgFwruleIncSrcAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgFwruleIncSrcAddr provide access to all rows of the NG_FWRULE_INC_SRC_ADDR matching given criteria.
func IterateNgFwruleIncSrcAddr(db *sql.DB, where string, callback func(v *NgFwruleIncSrcAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_FWRULE_INC_SRC_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleIncSrcAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleIncSrcAddr provide iterator to all rows of the NG_FWRULE_INC_SRC_ADDR matching given criteria.
func RangeNgFwruleIncSrcAddr(db *sql.DB, where string) iter.Seq2[*NgFwruleIncSrcAddrRow, error] {
	return func(yield func(v *NgFwruleIncSrcAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_FWRULE_INC_SRC_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleIncSrcAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgFwruleIncSrcZoneRow struct represents rows of the NG_FWRULE_INC_SRC_ZONE table.
type NgFwruleIncSrcZoneRow struct {
    RuleID	uint
    ZoneID	uint
}

// IterateNgFwruleIncSrcZone provide access to all rows of the NG_FWRULE_INC_SRC_ZONE matching given criteria.
func IterateNgFwruleIncSrcZone(db *sql.DB, where string, callback func(v *NgFwruleIncSrcZoneRow) error) error {
    query := "SELECT RULE_ID,ZONE_ID FROM NG_FWRULE_INC_SRC_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgFwruleIncSrcZoneRow
        err := rows.Scan(&r.RuleID, &r.ZoneID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgFwruleIncSrcZone provide iterator to all rows of the NG_FWRULE_INC_SRC_ZONE matching given criteria.
func RangeNgFwruleIncSrcZone(db *sql.DB, where string) iter.Seq2[*NgFwruleIncSrcZoneRow, error] {
	return func(yield func(v *NgFwruleIncSrcZoneRow, err error) bool) {
	    query := "SELECT RULE_ID,ZONE_ID FROM NG_FWRULE_INC_SRC_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgFwruleIncSrcZoneRow
	        err := rows.Scan(&r.RuleID, &r.ZoneID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgInspectionProfileGroupRow struct represents rows of the NG_INSPECTION_PROFILE_GROUP table.
type NgInspectionProfileGroupRow struct {
    ID	uint
    Uuid	string
    Name	sql.NullString
    Description	sql.NullString
    SecurityInspectionType	string
    ReputationInspectionType	string
    SecurityProfileUuid	sql.NullString
    ReputationProfileUuid	sql.NullString
    Version	uint
}

// IterateNgInspectionProfileGroup provide access to all rows of the NG_INSPECTION_PROFILE_GROUP matching given criteria.
func IterateNgInspectionProfileGroup(db *sql.DB, where string, callback func(v *NgInspectionProfileGroupRow) error) error {
    query := "SELECT ID,UUID,NAME,DESCRIPTION,SECURITY_INSPECTION_TYPE,REPUTATION_INSPECTION_TYPE,SECURITY_PROFILE_UUID,REPUTATION_PROFILE_UUID,VERSION FROM NG_INSPECTION_PROFILE_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgInspectionProfileGroupRow
        err := rows.Scan(&r.ID, &r.Uuid, &r.Name, &r.Description, &r.SecurityInspectionType, &r.ReputationInspectionType, &r.SecurityProfileUuid, &r.ReputationProfileUuid, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgInspectionProfileGroup provide iterator to all rows of the NG_INSPECTION_PROFILE_GROUP matching given criteria.
func RangeNgInspectionProfileGroup(db *sql.DB, where string) iter.Seq2[*NgInspectionProfileGroupRow, error] {
	return func(yield func(v *NgInspectionProfileGroupRow, err error) bool) {
	    query := "SELECT ID,UUID,NAME,DESCRIPTION,SECURITY_INSPECTION_TYPE,REPUTATION_INSPECTION_TYPE,SECURITY_PROFILE_UUID,REPUTATION_PROFILE_UUID,VERSION FROM NG_INSPECTION_PROFILE_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgInspectionProfileGroupRow
	        err := rows.Scan(&r.ID, &r.Uuid, &r.Name, &r.Description, &r.SecurityInspectionType, &r.ReputationInspectionType, &r.SecurityProfileUuid, &r.ReputationProfileUuid, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgPolicyLookupRow struct represents rows of the NG_POLICY_LOOKUP table.
type NgPolicyLookupRow struct {
    DevPolicyID	string
    SmsPolicyID	string
    ProfileID	sql.NullString
    DeviceID	string
    UpdateTime	uint64
    Deleted	uint16
}

// IterateNgPolicyLookup provide access to all rows of the NG_POLICY_LOOKUP matching given criteria.
func IterateNgPolicyLookup(db *sql.DB, where string, callback func(v *NgPolicyLookupRow) error) error {
    query := "SELECT DEV_POLICY_ID,SMS_POLICY_ID,PROFILE_ID,DEVICE_ID,UPDATE_TIME,DELETED FROM NG_POLICY_LOOKUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgPolicyLookupRow
        err := rows.Scan(&r.DevPolicyID, &r.SmsPolicyID, &r.ProfileID, &r.DeviceID, &r.UpdateTime, &r.Deleted)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgPolicyLookup provide iterator to all rows of the NG_POLICY_LOOKUP matching given criteria.
func RangeNgPolicyLookup(db *sql.DB, where string) iter.Seq2[*NgPolicyLookupRow, error] {
	return func(yield func(v *NgPolicyLookupRow, err error) bool) {
	    query := "SELECT DEV_POLICY_ID,SMS_POLICY_ID,PROFILE_ID,DEVICE_ID,UPDATE_TIME,DELETED FROM NG_POLICY_LOOKUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgPolicyLookupRow
	        err := rows.Scan(&r.DevPolicyID, &r.SmsPolicyID, &r.ProfileID, &r.DeviceID, &r.UpdateTime, &r.Deleted)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgProfileInstallInventoryRow struct represents rows of the NG_PROFILE_INSTALL_INVENTORY table.
type NgProfileInstallInventoryRow struct {
    DeviceShortID	uint
    ProfileUuid	string
    ProfileVersion	string
    Name	string
}

// IterateNgProfileInstallInventory provide access to all rows of the NG_PROFILE_INSTALL_INVENTORY matching given criteria.
func IterateNgProfileInstallInventory(db *sql.DB, where string, callback func(v *NgProfileInstallInventoryRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,PROFILE_UUID,PROFILE_VERSION,NAME FROM NG_PROFILE_INSTALL_INVENTORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgProfileInstallInventoryRow
        err := rows.Scan(&r.DeviceShortID, &r.ProfileUuid, &r.ProfileVersion, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgProfileInstallInventory provide iterator to all rows of the NG_PROFILE_INSTALL_INVENTORY matching given criteria.
func RangeNgProfileInstallInventory(db *sql.DB, where string) iter.Seq2[*NgProfileInstallInventoryRow, error] {
	return func(yield func(v *NgProfileInstallInventoryRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,PROFILE_UUID,PROFILE_VERSION,NAME FROM NG_PROFILE_INSTALL_INVENTORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgProfileInstallInventoryRow
	        err := rows.Scan(&r.DeviceShortID, &r.ProfileUuid, &r.ProfileVersion, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgProfileSnapshotRow struct represents rows of the NG_PROFILE_SNAPSHOT table.
type NgProfileSnapshotRow struct {
    ID	uint
    ProfileID	uint
    ProfileUuid	string
    Version	string
    Comments	sql.NullString
    CreationTime	string
    DistributionTime	sql.NullTime
    Data	[]byte
}

// IterateNgProfileSnapshot provide access to all rows of the NG_PROFILE_SNAPSHOT matching given criteria.
func IterateNgProfileSnapshot(db *sql.DB, where string, callback func(v *NgProfileSnapshotRow) error) error {
    query := "SELECT ID,PROFILE_ID,PROFILE_UUID,VERSION,COMMENTS,CREATION_TIME,DISTRIBUTION_TIME,DATA FROM NG_PROFILE_SNAPSHOT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgProfileSnapshotRow
        err := rows.Scan(&r.ID, &r.ProfileID, &r.ProfileUuid, &r.Version, &r.Comments, &r.CreationTime, &r.DistributionTime, &r.Data)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgProfileSnapshot provide iterator to all rows of the NG_PROFILE_SNAPSHOT matching given criteria.
func RangeNgProfileSnapshot(db *sql.DB, where string) iter.Seq2[*NgProfileSnapshotRow, error] {
	return func(yield func(v *NgProfileSnapshotRow, err error) bool) {
	    query := "SELECT ID,PROFILE_ID,PROFILE_UUID,VERSION,COMMENTS,CREATION_TIME,DISTRIBUTION_TIME,DATA FROM NG_PROFILE_SNAPSHOT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgProfileSnapshotRow
	        err := rows.Scan(&r.ID, &r.ProfileID, &r.ProfileUuid, &r.Version, &r.Comments, &r.CreationTime, &r.DistributionTime, &r.Data)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgReportRow struct represents rows of the NG_REPORT table.
type NgReportRow struct {
    ID	uint
    Name	sql.NullString
    Description	sql.NullString
    TemplateID	sql.NullInt32
    GroupID	sql.NullInt32
    Creator	sql.NullString
    QueryData	sql.NullString
    CreatedTime	sql.NullTime
}

// IterateNgReport provide access to all rows of the NG_REPORT matching given criteria.
func IterateNgReport(db *sql.DB, where string, callback func(v *NgReportRow) error) error {
    query := "SELECT ID,NAME,DESCRIPTION,TEMPLATE_ID,GROUP_ID,CREATOR,QUERY_DATA,CREATED_TIME FROM NG_REPORT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgReportRow
        err := rows.Scan(&r.ID, &r.Name, &r.Description, &r.TemplateID, &r.GroupID, &r.Creator, &r.QueryData, &r.CreatedTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgReport provide iterator to all rows of the NG_REPORT matching given criteria.
func RangeNgReport(db *sql.DB, where string) iter.Seq2[*NgReportRow, error] {
	return func(yield func(v *NgReportRow, err error) bool) {
	    query := "SELECT ID,NAME,DESCRIPTION,TEMPLATE_ID,GROUP_ID,CREATOR,QUERY_DATA,CREATED_TIME FROM NG_REPORT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgReportRow
	        err := rows.Scan(&r.ID, &r.Name, &r.Description, &r.TemplateID, &r.GroupID, &r.Creator, &r.QueryData, &r.CreatedTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgReportExportRow struct represents rows of the NG_REPORT_EXPORT table.
type NgReportExportRow struct {
    ID	uint
    EmailAddress	sql.NullInt32
    EmailLink	sql.NullByte
    EmailPdf	sql.NullByte
    EmailCsv	sql.NullByte
    EmailXml	sql.NullByte
    EmailHtmlAttached	sql.NullByte
    EmailEmbedded	sql.NullByte
    EmailDocx	sql.NullByte
    EmailXls	sql.NullByte
    ExportPdf	sql.NullByte
    ExportCsv	sql.NullByte
    ExportXml	sql.NullByte
    ExportHtml	sql.NullByte
    ExportDocx	sql.NullByte
    ExportXls	sql.NullByte
    Server	sql.NullString
    Directory	sql.NullString
    FilenamePattern	sql.NullString
    RemoteUser	sql.NullString
    RemotePassword	sql.NullString
    RemoteDomain	sql.NullString
    ExportType	sql.NullByte
}

// IterateNgReportExport provide access to all rows of the NG_REPORT_EXPORT matching given criteria.
func IterateNgReportExport(db *sql.DB, where string, callback func(v *NgReportExportRow) error) error {
    query := "SELECT ID,EMAIL_ADDRESS,EMAIL_LINK,EMAIL_PDF,EMAIL_CSV,EMAIL_XML,EMAIL_HTML_ATTACHED,EMAIL_EMBEDDED,EMAIL_DOCX,EMAIL_XLS,EXPORT_PDF,EXPORT_CSV,EXPORT_XML,EXPORT_HTML,EXPORT_DOCX,EXPORT_XLS,SERVER,DIRECTORY,FILENAME_PATTERN,REMOTE_USER,REMOTE_PASSWORD,REMOTE_DOMAIN,EXPORT_TYPE FROM NG_REPORT_EXPORT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgReportExportRow
        err := rows.Scan(&r.ID, &r.EmailAddress, &r.EmailLink, &r.EmailPdf, &r.EmailCsv, &r.EmailXml, &r.EmailHtmlAttached, &r.EmailEmbedded, &r.EmailDocx, &r.EmailXls, &r.ExportPdf, &r.ExportCsv, &r.ExportXml, &r.ExportHtml, &r.ExportDocx, &r.ExportXls, &r.Server, &r.Directory, &r.FilenamePattern, &r.RemoteUser, &r.RemotePassword, &r.RemoteDomain, &r.ExportType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgReportExport provide iterator to all rows of the NG_REPORT_EXPORT matching given criteria.
func RangeNgReportExport(db *sql.DB, where string) iter.Seq2[*NgReportExportRow, error] {
	return func(yield func(v *NgReportExportRow, err error) bool) {
	    query := "SELECT ID,EMAIL_ADDRESS,EMAIL_LINK,EMAIL_PDF,EMAIL_CSV,EMAIL_XML,EMAIL_HTML_ATTACHED,EMAIL_EMBEDDED,EMAIL_DOCX,EMAIL_XLS,EXPORT_PDF,EXPORT_CSV,EXPORT_XML,EXPORT_HTML,EXPORT_DOCX,EXPORT_XLS,SERVER,DIRECTORY,FILENAME_PATTERN,REMOTE_USER,REMOTE_PASSWORD,REMOTE_DOMAIN,EXPORT_TYPE FROM NG_REPORT_EXPORT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgReportExportRow
	        err := rows.Scan(&r.ID, &r.EmailAddress, &r.EmailLink, &r.EmailPdf, &r.EmailCsv, &r.EmailXml, &r.EmailHtmlAttached, &r.EmailEmbedded, &r.EmailDocx, &r.EmailXls, &r.ExportPdf, &r.ExportCsv, &r.ExportXml, &r.ExportHtml, &r.ExportDocx, &r.ExportXls, &r.Server, &r.Directory, &r.FilenamePattern, &r.RemoteUser, &r.RemotePassword, &r.RemoteDomain, &r.ExportType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgReportGroupRow struct represents rows of the NG_REPORT_GROUP table.
type NgReportGroupRow struct {
    ID	uint
    Name	sql.NullString
    ParentID	sql.NullInt32
    Creator	sql.NullString
    IsDeletable	int8
    CreatedTime	sql.NullTime
}

// IterateNgReportGroup provide access to all rows of the NG_REPORT_GROUP matching given criteria.
func IterateNgReportGroup(db *sql.DB, where string, callback func(v *NgReportGroupRow) error) error {
    query := "SELECT ID,NAME,PARENT_ID,CREATOR,IS_DELETABLE,CREATED_TIME FROM NG_REPORT_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgReportGroupRow
        err := rows.Scan(&r.ID, &r.Name, &r.ParentID, &r.Creator, &r.IsDeletable, &r.CreatedTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgReportGroup provide iterator to all rows of the NG_REPORT_GROUP matching given criteria.
func RangeNgReportGroup(db *sql.DB, where string) iter.Seq2[*NgReportGroupRow, error] {
	return func(yield func(v *NgReportGroupRow, err error) bool) {
	    query := "SELECT ID,NAME,PARENT_ID,CREATOR,IS_DELETABLE,CREATED_TIME FROM NG_REPORT_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgReportGroupRow
	        err := rows.Scan(&r.ID, &r.Name, &r.ParentID, &r.Creator, &r.IsDeletable, &r.CreatedTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgReportGroupUserGroupsRow struct represents rows of the NG_REPORT_GROUP_USER_GROUPS table.
type NgReportGroupUserGroupsRow struct {
    UserGroupsIDFk	uint
    NgReportGroupIDFk	uint
}

// IterateNgReportGroupUserGroups provide access to all rows of the NG_REPORT_GROUP_USER_GROUPS matching given criteria.
func IterateNgReportGroupUserGroups(db *sql.DB, where string, callback func(v *NgReportGroupUserGroupsRow) error) error {
    query := "SELECT USER_GROUPS_ID_FK,NG_REPORT_GROUP_ID_FK FROM NG_REPORT_GROUP_USER_GROUPS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgReportGroupUserGroupsRow
        err := rows.Scan(&r.UserGroupsIDFk, &r.NgReportGroupIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgReportGroupUserGroups provide iterator to all rows of the NG_REPORT_GROUP_USER_GROUPS matching given criteria.
func RangeNgReportGroupUserGroups(db *sql.DB, where string) iter.Seq2[*NgReportGroupUserGroupsRow, error] {
	return func(yield func(v *NgReportGroupUserGroupsRow, err error) bool) {
	    query := "SELECT USER_GROUPS_ID_FK,NG_REPORT_GROUP_ID_FK FROM NG_REPORT_GROUP_USER_GROUPS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgReportGroupUserGroupsRow
	        err := rows.Scan(&r.UserGroupsIDFk, &r.NgReportGroupIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgReportLogoRow struct represents rows of the NG_REPORT_LOGO table.
type NgReportLogoRow struct {
    ID	uint
    Name	string
    Readonly	sql.NullByte
}

// IterateNgReportLogo provide access to all rows of the NG_REPORT_LOGO matching given criteria.
func IterateNgReportLogo(db *sql.DB, where string, callback func(v *NgReportLogoRow) error) error {
    query := "SELECT ID,NAME,READONLY FROM NG_REPORT_LOGO"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgReportLogoRow
        err := rows.Scan(&r.ID, &r.Name, &r.Readonly)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgReportLogo provide iterator to all rows of the NG_REPORT_LOGO matching given criteria.
func RangeNgReportLogo(db *sql.DB, where string) iter.Seq2[*NgReportLogoRow, error] {
	return func(yield func(v *NgReportLogoRow, err error) bool) {
	    query := "SELECT ID,NAME,READONLY FROM NG_REPORT_LOGO"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgReportLogoRow
	        err := rows.Scan(&r.ID, &r.Name, &r.Readonly)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgReportResultRow struct represents rows of the NG_REPORT_RESULT table.
type NgReportResultRow struct {
    ID	uint
    Name	sql.NullString
    ReportID	sql.NullInt32
    Creator	sql.NullString
    CreatedTime	sql.NullTime
    KeepUntil	sql.NullTime
    AllowAnonymousView	sql.NullByte
    AllowAllUsersView	sql.NullByte
}

// IterateNgReportResult provide access to all rows of the NG_REPORT_RESULT matching given criteria.
func IterateNgReportResult(db *sql.DB, where string, callback func(v *NgReportResultRow) error) error {
    query := "SELECT ID,NAME,REPORT_ID,CREATOR,CREATED_TIME,KEEP_UNTIL,ALLOW_ANONYMOUS_VIEW,ALLOW_ALL_USERS_VIEW FROM NG_REPORT_RESULT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgReportResultRow
        err := rows.Scan(&r.ID, &r.Name, &r.ReportID, &r.Creator, &r.CreatedTime, &r.KeepUntil, &r.AllowAnonymousView, &r.AllowAllUsersView)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgReportResult provide iterator to all rows of the NG_REPORT_RESULT matching given criteria.
func RangeNgReportResult(db *sql.DB, where string) iter.Seq2[*NgReportResultRow, error] {
	return func(yield func(v *NgReportResultRow, err error) bool) {
	    query := "SELECT ID,NAME,REPORT_ID,CREATOR,CREATED_TIME,KEEP_UNTIL,ALLOW_ANONYMOUS_VIEW,ALLOW_ALL_USERS_VIEW FROM NG_REPORT_RESULT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgReportResultRow
	        err := rows.Scan(&r.ID, &r.Name, &r.ReportID, &r.Creator, &r.CreatedTime, &r.KeepUntil, &r.AllowAnonymousView, &r.AllowAllUsersView)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgReportResultDataRow struct represents rows of the NG_REPORT_RESULT_DATA table.
type NgReportResultDataRow struct {
    ResultID	uint
    Data	[]byte
}

// IterateNgReportResultData provide access to all rows of the NG_REPORT_RESULT_DATA matching given criteria.
func IterateNgReportResultData(db *sql.DB, where string, callback func(v *NgReportResultDataRow) error) error {
    query := "SELECT RESULT_ID,DATA FROM NG_REPORT_RESULT_DATA"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgReportResultDataRow
        err := rows.Scan(&r.ResultID, &r.Data)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgReportResultData provide iterator to all rows of the NG_REPORT_RESULT_DATA matching given criteria.
func RangeNgReportResultData(db *sql.DB, where string) iter.Seq2[*NgReportResultDataRow, error] {
	return func(yield func(v *NgReportResultDataRow, err error) bool) {
	    query := "SELECT RESULT_ID,DATA FROM NG_REPORT_RESULT_DATA"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgReportResultDataRow
	        err := rows.Scan(&r.ResultID, &r.Data)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgReportScheduleRow struct represents rows of the NG_REPORT_SCHEDULE table.
type NgReportScheduleRow struct {
    ID	uint
    ReportID	sql.NullInt32
    ExportID	sql.NullInt32
    ScheduleDetailID	sql.NullInt32
    RunNow	sql.NullByte
    AllowAnonymousView	sql.NullByte
    AllowAllUsersView	sql.NullByte
}

// IterateNgReportSchedule provide access to all rows of the NG_REPORT_SCHEDULE matching given criteria.
func IterateNgReportSchedule(db *sql.DB, where string, callback func(v *NgReportScheduleRow) error) error {
    query := "SELECT ID,REPORT_ID,EXPORT_ID,SCHEDULE_DETAIL_ID,RUN_NOW,ALLOW_ANONYMOUS_VIEW,ALLOW_ALL_USERS_VIEW FROM NG_REPORT_SCHEDULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgReportScheduleRow
        err := rows.Scan(&r.ID, &r.ReportID, &r.ExportID, &r.ScheduleDetailID, &r.RunNow, &r.AllowAnonymousView, &r.AllowAllUsersView)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgReportSchedule provide iterator to all rows of the NG_REPORT_SCHEDULE matching given criteria.
func RangeNgReportSchedule(db *sql.DB, where string) iter.Seq2[*NgReportScheduleRow, error] {
	return func(yield func(v *NgReportScheduleRow, err error) bool) {
	    query := "SELECT ID,REPORT_ID,EXPORT_ID,SCHEDULE_DETAIL_ID,RUN_NOW,ALLOW_ANONYMOUS_VIEW,ALLOW_ALL_USERS_VIEW FROM NG_REPORT_SCHEDULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgReportScheduleRow
	        err := rows.Scan(&r.ID, &r.ReportID, &r.ExportID, &r.ScheduleDetailID, &r.RunNow, &r.AllowAnonymousView, &r.AllowAllUsersView)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgReportTemplateRow struct represents rows of the NG_REPORT_TEMPLATE table.
type NgReportTemplateRow struct {
    ID	uint
    Name	sql.NullString
    Category	sql.NullInt16
    Type	sql.NullByte
    RequiredCriteria	sql.NullString
    DefaultCriteria	sql.NullString
    OutputFormat	sql.NullString
    HasChart	sql.NullByte
    HasDetails	sql.NullByte
    MaxRowLimit	sql.NullInt32
    IsTop	sql.NullByte
}

// IterateNgReportTemplate provide access to all rows of the NG_REPORT_TEMPLATE matching given criteria.
func IterateNgReportTemplate(db *sql.DB, where string, callback func(v *NgReportTemplateRow) error) error {
    query := "SELECT ID,NAME,CATEGORY,TYPE,REQUIRED_CRITERIA,DEFAULT_CRITERIA,OUTPUT_FORMAT,HAS_CHART,HAS_DETAILS,MAX_ROW_LIMIT,IS_TOP FROM NG_REPORT_TEMPLATE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgReportTemplateRow
        err := rows.Scan(&r.ID, &r.Name, &r.Category, &r.Type, &r.RequiredCriteria, &r.DefaultCriteria, &r.OutputFormat, &r.HasChart, &r.HasDetails, &r.MaxRowLimit, &r.IsTop)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgReportTemplate provide iterator to all rows of the NG_REPORT_TEMPLATE matching given criteria.
func RangeNgReportTemplate(db *sql.DB, where string) iter.Seq2[*NgReportTemplateRow, error] {
	return func(yield func(v *NgReportTemplateRow, err error) bool) {
	    query := "SELECT ID,NAME,CATEGORY,TYPE,REQUIRED_CRITERIA,DEFAULT_CRITERIA,OUTPUT_FORMAT,HAS_CHART,HAS_DETAILS,MAX_ROW_LIMIT,IS_TOP FROM NG_REPORT_TEMPLATE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgReportTemplateRow
	        err := rows.Scan(&r.ID, &r.Name, &r.Category, &r.Type, &r.RequiredCriteria, &r.DefaultCriteria, &r.OutputFormat, &r.HasChart, &r.HasDetails, &r.MaxRowLimit, &r.IsTop)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgReportUserGroupsRow struct represents rows of the NG_REPORT_USER_GROUPS table.
type NgReportUserGroupsRow struct {
    UserGroupsIDFk	uint
    NgReportIDFk	uint
}

// IterateNgReportUserGroups provide access to all rows of the NG_REPORT_USER_GROUPS matching given criteria.
func IterateNgReportUserGroups(db *sql.DB, where string, callback func(v *NgReportUserGroupsRow) error) error {
    query := "SELECT USER_GROUPS_ID_FK,NG_REPORT_ID_FK FROM NG_REPORT_USER_GROUPS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgReportUserGroupsRow
        err := rows.Scan(&r.UserGroupsIDFk, &r.NgReportIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgReportUserGroups provide iterator to all rows of the NG_REPORT_USER_GROUPS matching given criteria.
func RangeNgReportUserGroups(db *sql.DB, where string) iter.Seq2[*NgReportUserGroupsRow, error] {
	return func(yield func(v *NgReportUserGroupsRow, err error) bool) {
	    query := "SELECT USER_GROUPS_ID_FK,NG_REPORT_ID_FK FROM NG_REPORT_USER_GROUPS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgReportUserGroupsRow
	        err := rows.Scan(&r.UserGroupsIDFk, &r.NgReportIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgRulesetRow struct represents rows of the NG_RULESET table.
type NgRulesetRow struct {
    ID	uint
    RulesetUuid	string
    FirewallProfileID	uint
    RuleType	string
    Version	uint
}

// IterateNgRuleset provide access to all rows of the NG_RULESET matching given criteria.
func IterateNgRuleset(db *sql.DB, where string, callback func(v *NgRulesetRow) error) error {
    query := "SELECT ID,RULESET_UUID,FIREWALL_PROFILE_ID,RULE_TYPE,VERSION FROM NG_RULESET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgRulesetRow
        err := rows.Scan(&r.ID, &r.RulesetUuid, &r.FirewallProfileID, &r.RuleType, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgRuleset provide iterator to all rows of the NG_RULESET matching given criteria.
func RangeNgRuleset(db *sql.DB, where string) iter.Seq2[*NgRulesetRow, error] {
	return func(yield func(v *NgRulesetRow, err error) bool) {
	    query := "SELECT ID,RULESET_UUID,FIREWALL_PROFILE_ID,RULE_TYPE,VERSION FROM NG_RULESET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgRulesetRow
	        err := rows.Scan(&r.ID, &r.RulesetUuid, &r.FirewallProfileID, &r.RuleType, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgRuleHistoryRow struct represents rows of the NG_RULE_HISTORY table.
type NgRuleHistoryRow struct {
    ID	uint
    RuleID	uint
    CreateTime	string
    User	string
    Comment	sql.NullString
}

// IterateNgRuleHistory provide access to all rows of the NG_RULE_HISTORY matching given criteria.
func IterateNgRuleHistory(db *sql.DB, where string, callback func(v *NgRuleHistoryRow) error) error {
    query := "SELECT ID,RULE_ID,CREATE_TIME,USER,COMMENT FROM NG_RULE_HISTORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgRuleHistoryRow
        err := rows.Scan(&r.ID, &r.RuleID, &r.CreateTime, &r.User, &r.Comment)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgRuleHistory provide iterator to all rows of the NG_RULE_HISTORY matching given criteria.
func RangeNgRuleHistory(db *sql.DB, where string) iter.Seq2[*NgRuleHistoryRow, error] {
	return func(yield func(v *NgRuleHistoryRow, err error) bool) {
	    query := "SELECT ID,RULE_ID,CREATE_TIME,USER,COMMENT FROM NG_RULE_HISTORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgRuleHistoryRow
	        err := rows.Scan(&r.ID, &r.RuleID, &r.CreateTime, &r.User, &r.Comment)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgRuleInstallOnTargetRow struct represents rows of the NG_RULE_INSTALL_ON_TARGET table.
type NgRuleInstallOnTargetRow struct {
    ID	uint
    DeviceUuid	string
    TargetType	string
    Version	uint
}

// IterateNgRuleInstallOnTarget provide access to all rows of the NG_RULE_INSTALL_ON_TARGET matching given criteria.
func IterateNgRuleInstallOnTarget(db *sql.DB, where string, callback func(v *NgRuleInstallOnTargetRow) error) error {
    query := "SELECT ID,DEVICE_UUID,TARGET_TYPE,VERSION FROM NG_RULE_INSTALL_ON_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgRuleInstallOnTargetRow
        err := rows.Scan(&r.ID, &r.DeviceUuid, &r.TargetType, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgRuleInstallOnTarget provide iterator to all rows of the NG_RULE_INSTALL_ON_TARGET matching given criteria.
func RangeNgRuleInstallOnTarget(db *sql.DB, where string) iter.Seq2[*NgRuleInstallOnTargetRow, error] {
	return func(yield func(v *NgRuleInstallOnTargetRow, err error) bool) {
	    query := "SELECT ID,DEVICE_UUID,TARGET_TYPE,VERSION FROM NG_RULE_INSTALL_ON_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgRuleInstallOnTargetRow
	        err := rows.Scan(&r.ID, &r.DeviceUuid, &r.TargetType, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgRuleSecurityZoneRow struct represents rows of the NG_RULE_SECURITY_ZONE table.
type NgRuleSecurityZoneRow struct {
    ID	uint
    SecurityZoneUuid	string
    Version	uint
}

// IterateNgRuleSecurityZone provide access to all rows of the NG_RULE_SECURITY_ZONE matching given criteria.
func IterateNgRuleSecurityZone(db *sql.DB, where string, callback func(v *NgRuleSecurityZoneRow) error) error {
    query := "SELECT ID,SECURITY_ZONE_UUID,VERSION FROM NG_RULE_SECURITY_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgRuleSecurityZoneRow
        err := rows.Scan(&r.ID, &r.SecurityZoneUuid, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgRuleSecurityZone provide iterator to all rows of the NG_RULE_SECURITY_ZONE matching given criteria.
func RangeNgRuleSecurityZone(db *sql.DB, where string) iter.Seq2[*NgRuleSecurityZoneRow, error] {
	return func(yield func(v *NgRuleSecurityZoneRow, err error) bool) {
	    query := "SELECT ID,SECURITY_ZONE_UUID,VERSION FROM NG_RULE_SECURITY_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgRuleSecurityZoneRow
	        err := rows.Scan(&r.ID, &r.SecurityZoneUuid, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgSecurityZoneRow struct represents rows of the NG_SECURITY_ZONE table.
type NgSecurityZoneRow struct {
    ID	uint
    ZoneUuid	string
    Name	string
    Description	sql.NullString
    VisibilityStatus	int8
    IterationID	uint
    Version	uint
    ClientIPPolicyEnabled	sql.NullByte
    ClientIPLoggingEnabled	sql.NullByte
}

// IterateNgSecurityZone provide access to all rows of the NG_SECURITY_ZONE matching given criteria.
func IterateNgSecurityZone(db *sql.DB, where string, callback func(v *NgSecurityZoneRow) error) error {
    query := "SELECT ID,ZONE_UUID,NAME,DESCRIPTION,VISIBILITY_STATUS,ITERATION_ID,VERSION,CLIENT_IP_POLICY_ENABLED,CLIENT_IP_LOGGING_ENABLED FROM NG_SECURITY_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgSecurityZoneRow
        err := rows.Scan(&r.ID, &r.ZoneUuid, &r.Name, &r.Description, &r.VisibilityStatus, &r.IterationID, &r.Version, &r.ClientIPPolicyEnabled, &r.ClientIPLoggingEnabled)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgSecurityZone provide iterator to all rows of the NG_SECURITY_ZONE matching given criteria.
func RangeNgSecurityZone(db *sql.DB, where string) iter.Seq2[*NgSecurityZoneRow, error] {
	return func(yield func(v *NgSecurityZoneRow, err error) bool) {
	    query := "SELECT ID,ZONE_UUID,NAME,DESCRIPTION,VISIBILITY_STATUS,ITERATION_ID,VERSION,CLIENT_IP_POLICY_ENABLED,CLIENT_IP_LOGGING_ENABLED FROM NG_SECURITY_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgSecurityZoneRow
	        err := rows.Scan(&r.ID, &r.ZoneUuid, &r.Name, &r.Description, &r.VisibilityStatus, &r.IterationID, &r.Version, &r.ClientIPPolicyEnabled, &r.ClientIPLoggingEnabled)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgSrcNatruleExcDstAddrRow struct represents rows of the NG_SRC_NATRULE_EXC_DST_ADDR table.
type NgSrcNatruleExcDstAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgSrcNatruleExcDstAddr provide access to all rows of the NG_SRC_NATRULE_EXC_DST_ADDR matching given criteria.
func IterateNgSrcNatruleExcDstAddr(db *sql.DB, where string, callback func(v *NgSrcNatruleExcDstAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_SRC_NATRULE_EXC_DST_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgSrcNatruleExcDstAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgSrcNatruleExcDstAddr provide iterator to all rows of the NG_SRC_NATRULE_EXC_DST_ADDR matching given criteria.
func RangeNgSrcNatruleExcDstAddr(db *sql.DB, where string) iter.Seq2[*NgSrcNatruleExcDstAddrRow, error] {
	return func(yield func(v *NgSrcNatruleExcDstAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_SRC_NATRULE_EXC_DST_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgSrcNatruleExcDstAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgSrcNatruleExcDstZoneRow struct represents rows of the NG_SRC_NATRULE_EXC_DST_ZONE table.
type NgSrcNatruleExcDstZoneRow struct {
    RuleID	uint
    ZoneID	uint
}

// IterateNgSrcNatruleExcDstZone provide access to all rows of the NG_SRC_NATRULE_EXC_DST_ZONE matching given criteria.
func IterateNgSrcNatruleExcDstZone(db *sql.DB, where string, callback func(v *NgSrcNatruleExcDstZoneRow) error) error {
    query := "SELECT RULE_ID,ZONE_ID FROM NG_SRC_NATRULE_EXC_DST_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgSrcNatruleExcDstZoneRow
        err := rows.Scan(&r.RuleID, &r.ZoneID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgSrcNatruleExcDstZone provide iterator to all rows of the NG_SRC_NATRULE_EXC_DST_ZONE matching given criteria.
func RangeNgSrcNatruleExcDstZone(db *sql.DB, where string) iter.Seq2[*NgSrcNatruleExcDstZoneRow, error] {
	return func(yield func(v *NgSrcNatruleExcDstZoneRow, err error) bool) {
	    query := "SELECT RULE_ID,ZONE_ID FROM NG_SRC_NATRULE_EXC_DST_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgSrcNatruleExcDstZoneRow
	        err := rows.Scan(&r.RuleID, &r.ZoneID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgSrcNatruleExcInstallOnTargetRow struct represents rows of the NG_SRC_NATRULE_EXC_INSTALL_ON_TARGET table.
type NgSrcNatruleExcInstallOnTargetRow struct {
    RuleID	uint
    InstallOnTargetID	uint
}

// IterateNgSrcNatruleExcInstallOnTarget provide access to all rows of the NG_SRC_NATRULE_EXC_INSTALL_ON_TARGET matching given criteria.
func IterateNgSrcNatruleExcInstallOnTarget(db *sql.DB, where string, callback func(v *NgSrcNatruleExcInstallOnTargetRow) error) error {
    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_SRC_NATRULE_EXC_INSTALL_ON_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgSrcNatruleExcInstallOnTargetRow
        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgSrcNatruleExcInstallOnTarget provide iterator to all rows of the NG_SRC_NATRULE_EXC_INSTALL_ON_TARGET matching given criteria.
func RangeNgSrcNatruleExcInstallOnTarget(db *sql.DB, where string) iter.Seq2[*NgSrcNatruleExcInstallOnTargetRow, error] {
	return func(yield func(v *NgSrcNatruleExcInstallOnTargetRow, err error) bool) {
	    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_SRC_NATRULE_EXC_INSTALL_ON_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgSrcNatruleExcInstallOnTargetRow
	        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgSrcNatruleExcSrcAddrRow struct represents rows of the NG_SRC_NATRULE_EXC_SRC_ADDR table.
type NgSrcNatruleExcSrcAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgSrcNatruleExcSrcAddr provide access to all rows of the NG_SRC_NATRULE_EXC_SRC_ADDR matching given criteria.
func IterateNgSrcNatruleExcSrcAddr(db *sql.DB, where string, callback func(v *NgSrcNatruleExcSrcAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_SRC_NATRULE_EXC_SRC_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgSrcNatruleExcSrcAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgSrcNatruleExcSrcAddr provide iterator to all rows of the NG_SRC_NATRULE_EXC_SRC_ADDR matching given criteria.
func RangeNgSrcNatruleExcSrcAddr(db *sql.DB, where string) iter.Seq2[*NgSrcNatruleExcSrcAddrRow, error] {
	return func(yield func(v *NgSrcNatruleExcSrcAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_SRC_NATRULE_EXC_SRC_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgSrcNatruleExcSrcAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgSrcNatruleIncDstAddrRow struct represents rows of the NG_SRC_NATRULE_INC_DST_ADDR table.
type NgSrcNatruleIncDstAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgSrcNatruleIncDstAddr provide access to all rows of the NG_SRC_NATRULE_INC_DST_ADDR matching given criteria.
func IterateNgSrcNatruleIncDstAddr(db *sql.DB, where string, callback func(v *NgSrcNatruleIncDstAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_SRC_NATRULE_INC_DST_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgSrcNatruleIncDstAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgSrcNatruleIncDstAddr provide iterator to all rows of the NG_SRC_NATRULE_INC_DST_ADDR matching given criteria.
func RangeNgSrcNatruleIncDstAddr(db *sql.DB, where string) iter.Seq2[*NgSrcNatruleIncDstAddrRow, error] {
	return func(yield func(v *NgSrcNatruleIncDstAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_SRC_NATRULE_INC_DST_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgSrcNatruleIncDstAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgSrcNatruleIncDstZoneRow struct represents rows of the NG_SRC_NATRULE_INC_DST_ZONE table.
type NgSrcNatruleIncDstZoneRow struct {
    RuleID	uint
    ZoneID	uint
}

// IterateNgSrcNatruleIncDstZone provide access to all rows of the NG_SRC_NATRULE_INC_DST_ZONE matching given criteria.
func IterateNgSrcNatruleIncDstZone(db *sql.DB, where string, callback func(v *NgSrcNatruleIncDstZoneRow) error) error {
    query := "SELECT RULE_ID,ZONE_ID FROM NG_SRC_NATRULE_INC_DST_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgSrcNatruleIncDstZoneRow
        err := rows.Scan(&r.RuleID, &r.ZoneID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgSrcNatruleIncDstZone provide iterator to all rows of the NG_SRC_NATRULE_INC_DST_ZONE matching given criteria.
func RangeNgSrcNatruleIncDstZone(db *sql.DB, where string) iter.Seq2[*NgSrcNatruleIncDstZoneRow, error] {
	return func(yield func(v *NgSrcNatruleIncDstZoneRow, err error) bool) {
	    query := "SELECT RULE_ID,ZONE_ID FROM NG_SRC_NATRULE_INC_DST_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgSrcNatruleIncDstZoneRow
	        err := rows.Scan(&r.RuleID, &r.ZoneID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgSrcNatruleIncInstallOnTargetRow struct represents rows of the NG_SRC_NATRULE_INC_INSTALL_ON_TARGET table.
type NgSrcNatruleIncInstallOnTargetRow struct {
    RuleID	uint
    InstallOnTargetID	uint
}

// IterateNgSrcNatruleIncInstallOnTarget provide access to all rows of the NG_SRC_NATRULE_INC_INSTALL_ON_TARGET matching given criteria.
func IterateNgSrcNatruleIncInstallOnTarget(db *sql.DB, where string, callback func(v *NgSrcNatruleIncInstallOnTargetRow) error) error {
    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_SRC_NATRULE_INC_INSTALL_ON_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgSrcNatruleIncInstallOnTargetRow
        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgSrcNatruleIncInstallOnTarget provide iterator to all rows of the NG_SRC_NATRULE_INC_INSTALL_ON_TARGET matching given criteria.
func RangeNgSrcNatruleIncInstallOnTarget(db *sql.DB, where string) iter.Seq2[*NgSrcNatruleIncInstallOnTargetRow, error] {
	return func(yield func(v *NgSrcNatruleIncInstallOnTargetRow, err error) bool) {
	    query := "SELECT RULE_ID,INSTALL_ON_TARGET_ID FROM NG_SRC_NATRULE_INC_INSTALL_ON_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgSrcNatruleIncInstallOnTargetRow
	        err := rows.Scan(&r.RuleID, &r.InstallOnTargetID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgSrcNatruleIncSrcAddrRow struct represents rows of the NG_SRC_NATRULE_INC_SRC_ADDR table.
type NgSrcNatruleIncSrcAddrRow struct {
    RuleID	uint
    NamedAddressID	int
}

// IterateNgSrcNatruleIncSrcAddr provide access to all rows of the NG_SRC_NATRULE_INC_SRC_ADDR matching given criteria.
func IterateNgSrcNatruleIncSrcAddr(db *sql.DB, where string, callback func(v *NgSrcNatruleIncSrcAddrRow) error) error {
    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_SRC_NATRULE_INC_SRC_ADDR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgSrcNatruleIncSrcAddrRow
        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgSrcNatruleIncSrcAddr provide iterator to all rows of the NG_SRC_NATRULE_INC_SRC_ADDR matching given criteria.
func RangeNgSrcNatruleIncSrcAddr(db *sql.DB, where string) iter.Seq2[*NgSrcNatruleIncSrcAddrRow, error] {
	return func(yield func(v *NgSrcNatruleIncSrcAddrRow, err error) bool) {
	    query := "SELECT RULE_ID,NAMED_ADDRESS_ID FROM NG_SRC_NATRULE_INC_SRC_ADDR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgSrcNatruleIncSrcAddrRow
	        err := rows.Scan(&r.RuleID, &r.NamedAddressID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NgZoneInterfaceRow struct represents rows of the NG_ZONE_INTERFACE table.
type NgZoneInterfaceRow struct {
    ZoneID	uint
    IfaceID	uint
}

// IterateNgZoneInterface provide access to all rows of the NG_ZONE_INTERFACE matching given criteria.
func IterateNgZoneInterface(db *sql.DB, where string, callback func(v *NgZoneInterfaceRow) error) error {
    query := "SELECT ZONE_ID,IFACE_ID FROM NG_ZONE_INTERFACE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NgZoneInterfaceRow
        err := rows.Scan(&r.ZoneID, &r.IfaceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNgZoneInterface provide iterator to all rows of the NG_ZONE_INTERFACE matching given criteria.
func RangeNgZoneInterface(db *sql.DB, where string) iter.Seq2[*NgZoneInterfaceRow, error] {
	return func(yield func(v *NgZoneInterfaceRow, err error) bool) {
	    query := "SELECT ZONE_ID,IFACE_ID FROM NG_ZONE_INTERFACE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NgZoneInterfaceRow
	        err := rows.Scan(&r.ZoneID, &r.IfaceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NoticeActionRow struct represents rows of the NOTICE_ACTION table.
type NoticeActionRow struct {
    ID	uint64
    Name	sql.NullString
}

// IterateNoticeAction provide access to all rows of the NOTICE_ACTION matching given criteria.
func IterateNoticeAction(db *sql.DB, where string, callback func(v *NoticeActionRow) error) error {
    query := "SELECT ID,NAME FROM NOTICE_ACTION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NoticeActionRow
        err := rows.Scan(&r.ID, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNoticeAction provide iterator to all rows of the NOTICE_ACTION matching given criteria.
func RangeNoticeAction(db *sql.DB, where string) iter.Seq2[*NoticeActionRow, error] {
	return func(yield func(v *NoticeActionRow, err error) bool) {
	    query := "SELECT ID,NAME FROM NOTICE_ACTION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NoticeActionRow
	        err := rows.Scan(&r.ID, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NotificationsRow struct represents rows of the NOTIFICATIONS table.
type NotificationsRow struct {
    ID	uint
    Source	sql.NullString
    MessageCode	sql.NullString
    NotificationTime	sql.NullInt64
}

// IterateNotifications provide access to all rows of the NOTIFICATIONS matching given criteria.
func IterateNotifications(db *sql.DB, where string, callback func(v *NotificationsRow) error) error {
    query := "SELECT ID,SOURCE,MESSAGE_CODE,NOTIFICATION_TIME FROM NOTIFICATIONS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NotificationsRow
        err := rows.Scan(&r.ID, &r.Source, &r.MessageCode, &r.NotificationTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNotifications provide iterator to all rows of the NOTIFICATIONS matching given criteria.
func RangeNotifications(db *sql.DB, where string) iter.Seq2[*NotificationsRow, error] {
	return func(yield func(v *NotificationsRow, err error) bool) {
	    query := "SELECT ID,SOURCE,MESSAGE_CODE,NOTIFICATION_TIME FROM NOTIFICATIONS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NotificationsRow
	        err := rows.Scan(&r.ID, &r.Source, &r.MessageCode, &r.NotificationTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NotificationDataRow struct represents rows of the NOTIFICATION_DATA table.
type NotificationDataRow struct {
    ID	uint
    NotificationID	uint
    NotificationData	sql.NullString
    IsResourceCode	sql.NullByte
}

// IterateNotificationData provide access to all rows of the NOTIFICATION_DATA matching given criteria.
func IterateNotificationData(db *sql.DB, where string, callback func(v *NotificationDataRow) error) error {
    query := "SELECT ID,NOTIFICATION_ID,NOTIFICATION_DATA,IS_RESOURCE_CODE FROM NOTIFICATION_DATA"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NotificationDataRow
        err := rows.Scan(&r.ID, &r.NotificationID, &r.NotificationData, &r.IsResourceCode)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNotificationData provide iterator to all rows of the NOTIFICATION_DATA matching given criteria.
func RangeNotificationData(db *sql.DB, where string) iter.Seq2[*NotificationDataRow, error] {
	return func(yield func(v *NotificationDataRow, err error) bool) {
	    query := "SELECT ID,NOTIFICATION_ID,NOTIFICATION_DATA,IS_RESOURCE_CODE FROM NOTIFICATION_DATA"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NotificationDataRow
	        err := rows.Scan(&r.ID, &r.NotificationID, &r.NotificationData, &r.IsResourceCode)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NtpConfigRow struct represents rows of the NTP_CONFIG table.
type NtpConfigRow struct {
    DeviceShortID	uint
    Enabled	sql.NullByte
    Duration	sql.NullInt64
    Offset	sql.NullInt64
    FastSync	sql.NullByte
}

// IterateNtpConfig provide access to all rows of the NTP_CONFIG matching given criteria.
func IterateNtpConfig(db *sql.DB, where string, callback func(v *NtpConfigRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,ENABLED,DURATION,OFFSET,FAST_SYNC FROM NTP_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NtpConfigRow
        err := rows.Scan(&r.DeviceShortID, &r.Enabled, &r.Duration, &r.Offset, &r.FastSync)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNtpConfig provide iterator to all rows of the NTP_CONFIG matching given criteria.
func RangeNtpConfig(db *sql.DB, where string) iter.Seq2[*NtpConfigRow, error] {
	return func(yield func(v *NtpConfigRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,ENABLED,DURATION,OFFSET,FAST_SYNC FROM NTP_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NtpConfigRow
	        err := rows.Scan(&r.DeviceShortID, &r.Enabled, &r.Duration, &r.Offset, &r.FastSync)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// NtpServerRow struct represents rows of the NTP_SERVER table.
type NtpServerRow struct {
    ID	uint
    Name	sql.NullString
    NtpType	sql.NullInt32
    DeviceShortID	sql.NullInt32
    Port	sql.NullInt32
}

// IterateNtpServer provide access to all rows of the NTP_SERVER matching given criteria.
func IterateNtpServer(db *sql.DB, where string, callback func(v *NtpServerRow) error) error {
    query := "SELECT ID,NAME,NTP_TYPE,DEVICE_SHORT_ID,PORT FROM NTP_SERVER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r NtpServerRow
        err := rows.Scan(&r.ID, &r.Name, &r.NtpType, &r.DeviceShortID, &r.Port)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeNtpServer provide iterator to all rows of the NTP_SERVER matching given criteria.
func RangeNtpServer(db *sql.DB, where string) iter.Seq2[*NtpServerRow, error] {
	return func(yield func(v *NtpServerRow, err error) bool) {
	    query := "SELECT ID,NAME,NTP_TYPE,DEVICE_SHORT_ID,PORT FROM NTP_SERVER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r NtpServerRow
	        err := rows.Scan(&r.ID, &r.Name, &r.NtpType, &r.DeviceShortID, &r.Port)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// OcspConfigRow struct represents rows of the OCSP_CONFIG table.
type OcspConfigRow struct {
    NamedCertificateID	int
    Uri	string
}

// IterateOcspConfig provide access to all rows of the OCSP_CONFIG matching given criteria.
func IterateOcspConfig(db *sql.DB, where string, callback func(v *OcspConfigRow) error) error {
    query := "SELECT NAMED_CERTIFICATE_ID,URI FROM OCSP_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r OcspConfigRow
        err := rows.Scan(&r.NamedCertificateID, &r.Uri)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeOcspConfig provide iterator to all rows of the OCSP_CONFIG matching given criteria.
func RangeOcspConfig(db *sql.DB, where string) iter.Seq2[*OcspConfigRow, error] {
	return func(yield func(v *OcspConfigRow, err error) bool) {
	    query := "SELECT NAMED_CERTIFICATE_ID,URI FROM OCSP_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r OcspConfigRow
	        err := rows.Scan(&r.NamedCertificateID, &r.Uri)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// OfflineDeviceRow struct represents rows of the OFFLINE_DEVICE table.
type OfflineDeviceRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    IPAddress	sql.NullString
    SerialNumber	sql.NullString
    User	sql.NullString
    Password	sql.NullString
    SyncSmsTime	sql.NullByte
    DeviceGroupID	sql.NullInt32
    UseConfigFile	sql.NullByte
    DeviceProvisionConfigID	sql.NullInt32
}

// IterateOfflineDevice provide access to all rows of the OFFLINE_DEVICE matching given criteria.
func IterateOfflineDevice(db *sql.DB, where string, callback func(v *OfflineDeviceRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,IP_ADDRESS,SERIAL_NUMBER,USER,PASSWORD,SYNC_SMS_TIME,DEVICE_GROUP_ID,USE_CONFIG_FILE,DEVICE_PROVISION_CONFIG_ID FROM OFFLINE_DEVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r OfflineDeviceRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.IPAddress, &r.SerialNumber, &r.User, &r.Password, &r.SyncSmsTime, &r.DeviceGroupID, &r.UseConfigFile, &r.DeviceProvisionConfigID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeOfflineDevice provide iterator to all rows of the OFFLINE_DEVICE matching given criteria.
func RangeOfflineDevice(db *sql.DB, where string) iter.Seq2[*OfflineDeviceRow, error] {
	return func(yield func(v *OfflineDeviceRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,IP_ADDRESS,SERIAL_NUMBER,USER,PASSWORD,SYNC_SMS_TIME,DEVICE_GROUP_ID,USE_CONFIG_FILE,DEVICE_PROVISION_CONFIG_ID FROM OFFLINE_DEVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r OfflineDeviceRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.IPAddress, &r.SerialNumber, &r.User, &r.Password, &r.SyncSmsTime, &r.DeviceGroupID, &r.UseConfigFile, &r.DeviceProvisionConfigID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// P2pGlobalSettingsRow struct represents rows of the P2P_GLOBAL_SETTINGS table.
type P2pGlobalSettingsRow struct {
    ProfileID	string
    ID	string
    AddrPairsGroupID	sql.NullString
    Deleted	string
    IterationID	string
    Version	string
    PkgDir	string
    UpdateTime	int64
}

// IterateP2pGlobalSettings provide access to all rows of the P2P_GLOBAL_SETTINGS matching given criteria.
func IterateP2pGlobalSettings(db *sql.DB, where string, callback func(v *P2pGlobalSettingsRow) error) error {
    query := "SELECT PROFILE_ID,ID,ADDR_PAIRS_GROUP_ID,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME FROM P2P_GLOBAL_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r P2pGlobalSettingsRow
        err := rows.Scan(&r.ProfileID, &r.ID, &r.AddrPairsGroupID, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeP2pGlobalSettings provide iterator to all rows of the P2P_GLOBAL_SETTINGS matching given criteria.
func RangeP2pGlobalSettings(db *sql.DB, where string) iter.Seq2[*P2pGlobalSettingsRow, error] {
	return func(yield func(v *P2pGlobalSettingsRow, err error) bool) {
	    query := "SELECT PROFILE_ID,ID,ADDR_PAIRS_GROUP_ID,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME FROM P2P_GLOBAL_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r P2pGlobalSettingsRow
	        err := rows.Scan(&r.ProfileID, &r.ID, &r.AddrPairsGroupID, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PackageRow struct represents rows of the PACKAGE table.
type PackageRow struct {
    ID	string
    Ver	int
    Dir	string
    ReleasedDt	string
}

// IteratePackage provide access to all rows of the PACKAGE matching given criteria.
func IteratePackage(db *sql.DB, where string, callback func(v *PackageRow) error) error {
    query := "SELECT ID,VER,DIR,RELEASED_DT FROM PACKAGE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PackageRow
        err := rows.Scan(&r.ID, &r.Ver, &r.Dir, &r.ReleasedDt)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePackage provide iterator to all rows of the PACKAGE matching given criteria.
func RangePackage(db *sql.DB, where string) iter.Seq2[*PackageRow, error] {
	return func(yield func(v *PackageRow, err error) bool) {
	    query := "SELECT ID,VER,DIR,RELEASED_DT FROM PACKAGE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PackageRow
	        err := rows.Scan(&r.ID, &r.Ver, &r.Dir, &r.ReleasedDt)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PasswordHistoryRow struct represents rows of the PASSWORD_HISTORY table.
type PasswordHistoryRow struct {
    ID	int
    UserID	int
    Password	sql.NullString
}

// IteratePasswordHistory provide access to all rows of the PASSWORD_HISTORY matching given criteria.
func IteratePasswordHistory(db *sql.DB, where string, callback func(v *PasswordHistoryRow) error) error {
    query := "SELECT ID,USER_ID,PASSWORD FROM PASSWORD_HISTORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PasswordHistoryRow
        err := rows.Scan(&r.ID, &r.UserID, &r.Password)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePasswordHistory provide iterator to all rows of the PASSWORD_HISTORY matching given criteria.
func RangePasswordHistory(db *sql.DB, where string) iter.Seq2[*PasswordHistoryRow, error] {
	return func(yield func(v *PasswordHistoryRow, err error) bool) {
	    query := "SELECT ID,USER_ID,PASSWORD FROM PASSWORD_HISTORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PasswordHistoryRow
	        err := rows.Scan(&r.ID, &r.UserID, &r.Password)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PermissionsRow struct represents rows of the PERMISSIONS table.
type PermissionsRow struct {
    Descr	string
    Task	string
    Name	string
    Type	string
    Rights	string
}

// IteratePermissions provide access to all rows of the PERMISSIONS matching given criteria.
func IteratePermissions(db *sql.DB, where string, callback func(v *PermissionsRow) error) error {
    query := "SELECT DESCR,TASK,NAME,TYPE,RIGHTS FROM PERMISSIONS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PermissionsRow
        err := rows.Scan(&r.Descr, &r.Task, &r.Name, &r.Type, &r.Rights)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePermissions provide iterator to all rows of the PERMISSIONS matching given criteria.
func RangePermissions(db *sql.DB, where string) iter.Seq2[*PermissionsRow, error] {
	return func(yield func(v *PermissionsRow, err error) bool) {
	    query := "SELECT DESCR,TASK,NAME,TYPE,RIGHTS FROM PERMISSIONS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PermissionsRow
	        err := rows.Scan(&r.Descr, &r.Task, &r.Name, &r.Type, &r.Rights)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PolicyRow struct represents rows of the POLICY table.
type PolicyRow struct {
    ProfileID	string
    Policyid	string
    Displayname	sql.NullString
    Sigid	sql.NullString
    Message	sql.NullString
    Active	int
    Severity	sql.NullInt32
    Precedence	sql.NullInt16
    ActionsetID	sql.NullString
    Direction	sql.NullString
    ReqCapabilities	sql.NullString
    RecommendedActionsetID	sql.NullString
    RecommendedState	sql.NullInt32
    AdaptiveState	sql.NullInt32
    MultipartGroupID	sql.NullString
    GroupOrderNumber	sql.NullInt32
    UserDefined	string
    Deleted	string
    IterationID	string
    Version	sql.NullString
    PkgDir	string
    UpdateTime	int64
    RepFilterUuid	sql.NullString
    FilterType	uint8
    NgfwVersion	sql.NullString
    PkgID	sql.NullString
    SslServerID	sql.NullString
    SslClientProxyID	sql.NullString
    SslClientDecryptID	sql.NullString
    SslClientTruststoreID	sql.NullString
}

// IteratePolicy provide access to all rows of the POLICY matching given criteria.
func IteratePolicy(db *sql.DB, where string, callback func(v *PolicyRow) error) error {
    query := "SELECT PROFILE_ID,POLICYID,DISPLAYNAME,SIGID,MESSAGE,ACTIVE,SEVERITY,PRECEDENCE,ACTIONSET_ID,DIRECTION,REQ_CAPABILITIES,RECOMMENDED_ACTIONSET_ID,RECOMMENDED_STATE,ADAPTIVE_STATE,MULTIPART_GROUP_ID,GROUP_ORDER_NUMBER,USER_DEFINED,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME,REP_FILTER_UUID,FILTER_TYPE,NGFW_VERSION,PKG_ID,SSL_SERVER_ID,SSL_CLIENT_PROXY_ID,SSL_CLIENT_DECRYPT_ID,SSL_CLIENT_TRUSTSTORE_ID FROM POLICY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PolicyRow
        err := rows.Scan(&r.ProfileID, &r.Policyid, &r.Displayname, &r.Sigid, &r.Message, &r.Active, &r.Severity, &r.Precedence, &r.ActionsetID, &r.Direction, &r.ReqCapabilities, &r.RecommendedActionsetID, &r.RecommendedState, &r.AdaptiveState, &r.MultipartGroupID, &r.GroupOrderNumber, &r.UserDefined, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime, &r.RepFilterUuid, &r.FilterType, &r.NgfwVersion, &r.PkgID, &r.SslServerID, &r.SslClientProxyID, &r.SslClientDecryptID, &r.SslClientTruststoreID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePolicy provide iterator to all rows of the POLICY matching given criteria.
func RangePolicy(db *sql.DB, where string) iter.Seq2[*PolicyRow, error] {
	return func(yield func(v *PolicyRow, err error) bool) {
	    query := "SELECT PROFILE_ID,POLICYID,DISPLAYNAME,SIGID,MESSAGE,ACTIVE,SEVERITY,PRECEDENCE,ACTIONSET_ID,DIRECTION,REQ_CAPABILITIES,RECOMMENDED_ACTIONSET_ID,RECOMMENDED_STATE,ADAPTIVE_STATE,MULTIPART_GROUP_ID,GROUP_ORDER_NUMBER,USER_DEFINED,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME,REP_FILTER_UUID,FILTER_TYPE,NGFW_VERSION,PKG_ID,SSL_SERVER_ID,SSL_CLIENT_PROXY_ID,SSL_CLIENT_DECRYPT_ID,SSL_CLIENT_TRUSTSTORE_ID FROM POLICY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PolicyRow
	        err := rows.Scan(&r.ProfileID, &r.Policyid, &r.Displayname, &r.Sigid, &r.Message, &r.Active, &r.Severity, &r.Precedence, &r.ActionsetID, &r.Direction, &r.ReqCapabilities, &r.RecommendedActionsetID, &r.RecommendedState, &r.AdaptiveState, &r.MultipartGroupID, &r.GroupOrderNumber, &r.UserDefined, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime, &r.RepFilterUuid, &r.FilterType, &r.NgfwVersion, &r.PkgID, &r.SslServerID, &r.SslClientProxyID, &r.SslClientDecryptID, &r.SslClientTruststoreID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PolicyDeploymentRow struct represents rows of the POLICY_DEPLOYMENT table.
type PolicyDeploymentRow struct {
    ID	string
    Name	string
    Summary	sql.NullString
    Description	sql.NullString
    IsDefault	sql.NullByte
    TptPkgID	string
}

// IteratePolicyDeployment provide access to all rows of the POLICY_DEPLOYMENT matching given criteria.
func IteratePolicyDeployment(db *sql.DB, where string, callback func(v *PolicyDeploymentRow) error) error {
    query := "SELECT ID,NAME,SUMMARY,DESCRIPTION,IS_DEFAULT,TPT_PKG_ID FROM POLICY_DEPLOYMENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PolicyDeploymentRow
        err := rows.Scan(&r.ID, &r.Name, &r.Summary, &r.Description, &r.IsDefault, &r.TptPkgID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePolicyDeployment provide iterator to all rows of the POLICY_DEPLOYMENT matching given criteria.
func RangePolicyDeployment(db *sql.DB, where string) iter.Seq2[*PolicyDeploymentRow, error] {
	return func(yield func(v *PolicyDeploymentRow, err error) bool) {
	    query := "SELECT ID,NAME,SUMMARY,DESCRIPTION,IS_DEFAULT,TPT_PKG_ID FROM POLICY_DEPLOYMENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PolicyDeploymentRow
	        err := rows.Scan(&r.ID, &r.Name, &r.Summary, &r.Description, &r.IsDefault, &r.TptPkgID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PolicyDistribPackageRow struct represents rows of the POLICY_DISTRIB_PACKAGE table.
type PolicyDistribPackageRow struct {
    PkgIndex	int
    SecPkgVersion	sql.NullString
    SecPkgFile	sql.NullString
    SecPkgTimestamp	string
    FilterPkgVersion	sql.NullString
    FilterPkgFile	sql.NullString
    FilterPkgTimestamp	string
    SecPkgTime	sql.NullInt64
    FilterPkgTime	sql.NullInt64
}

// IteratePolicyDistribPackage provide access to all rows of the POLICY_DISTRIB_PACKAGE matching given criteria.
func IteratePolicyDistribPackage(db *sql.DB, where string, callback func(v *PolicyDistribPackageRow) error) error {
    query := "SELECT PKG_INDEX,SEC_PKG_VERSION,SEC_PKG_FILE,SEC_PKG_TIMESTAMP,FILTER_PKG_VERSION,FILTER_PKG_FILE,FILTER_PKG_TIMESTAMP,SEC_PKG_TIME,FILTER_PKG_TIME FROM POLICY_DISTRIB_PACKAGE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PolicyDistribPackageRow
        err := rows.Scan(&r.PkgIndex, &r.SecPkgVersion, &r.SecPkgFile, &r.SecPkgTimestamp, &r.FilterPkgVersion, &r.FilterPkgFile, &r.FilterPkgTimestamp, &r.SecPkgTime, &r.FilterPkgTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePolicyDistribPackage provide iterator to all rows of the POLICY_DISTRIB_PACKAGE matching given criteria.
func RangePolicyDistribPackage(db *sql.DB, where string) iter.Seq2[*PolicyDistribPackageRow, error] {
	return func(yield func(v *PolicyDistribPackageRow, err error) bool) {
	    query := "SELECT PKG_INDEX,SEC_PKG_VERSION,SEC_PKG_FILE,SEC_PKG_TIMESTAMP,FILTER_PKG_VERSION,FILTER_PKG_FILE,FILTER_PKG_TIMESTAMP,SEC_PKG_TIME,FILTER_PKG_TIME FROM POLICY_DISTRIB_PACKAGE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PolicyDistribPackageRow
	        err := rows.Scan(&r.PkgIndex, &r.SecPkgVersion, &r.SecPkgFile, &r.SecPkgTimestamp, &r.FilterPkgVersion, &r.FilterPkgFile, &r.FilterPkgTimestamp, &r.SecPkgTime, &r.FilterPkgTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PolicyExceptionRow struct represents rows of the POLICY_EXCEPTION table.
type PolicyExceptionRow struct {
    ProfileID	string
    ID	string
    Policyid	string
    ParentID	sql.NullString
    Protocol	string
    SslExceptionType	sql.NullString
    Name	sql.NullString
    SaddrNamedObjID	sql.NullInt32
    DaddrNamedObjID	sql.NullInt32
    UpdateTime	int64
}

// IteratePolicyException provide access to all rows of the POLICY_EXCEPTION matching given criteria.
func IteratePolicyException(db *sql.DB, where string, callback func(v *PolicyExceptionRow) error) error {
    query := "SELECT PROFILE_ID,ID,POLICYID,PARENT_ID,PROTOCOL,SSL_EXCEPTION_TYPE,NAME,SADDR_NAMED_OBJ_ID,DADDR_NAMED_OBJ_ID,UPDATE_TIME FROM POLICY_EXCEPTION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PolicyExceptionRow
        err := rows.Scan(&r.ProfileID, &r.ID, &r.Policyid, &r.ParentID, &r.Protocol, &r.SslExceptionType, &r.Name, &r.SaddrNamedObjID, &r.DaddrNamedObjID, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePolicyException provide iterator to all rows of the POLICY_EXCEPTION matching given criteria.
func RangePolicyException(db *sql.DB, where string) iter.Seq2[*PolicyExceptionRow, error] {
	return func(yield func(v *PolicyExceptionRow, err error) bool) {
	    query := "SELECT PROFILE_ID,ID,POLICYID,PARENT_ID,PROTOCOL,SSL_EXCEPTION_TYPE,NAME,SADDR_NAMED_OBJ_ID,DADDR_NAMED_OBJ_ID,UPDATE_TIME FROM POLICY_EXCEPTION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PolicyExceptionRow
	        err := rows.Scan(&r.ProfileID, &r.ID, &r.Policyid, &r.ParentID, &r.Protocol, &r.SslExceptionType, &r.Name, &r.SaddrNamedObjID, &r.DaddrNamedObjID, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PolicyGroupRow struct represents rows of the POLICY_GROUP table.
type PolicyGroupRow struct {
    ProfileID	string
    Policyid	string
    Name	sql.NullString
    Type	sql.NullString
    UserDefined	string
    Deleted	string
    IterationID	string
    Version	sql.NullString
    PkgDir	string
    UpdateTime	int64
    NgfwVersion	sql.NullString
}

// IteratePolicyGroup provide access to all rows of the POLICY_GROUP matching given criteria.
func IteratePolicyGroup(db *sql.DB, where string, callback func(v *PolicyGroupRow) error) error {
    query := "SELECT PROFILE_ID,POLICYID,NAME,TYPE,USER_DEFINED,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME,NGFW_VERSION FROM POLICY_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PolicyGroupRow
        err := rows.Scan(&r.ProfileID, &r.Policyid, &r.Name, &r.Type, &r.UserDefined, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime, &r.NgfwVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePolicyGroup provide iterator to all rows of the POLICY_GROUP matching given criteria.
func RangePolicyGroup(db *sql.DB, where string) iter.Seq2[*PolicyGroupRow, error] {
	return func(yield func(v *PolicyGroupRow, err error) bool) {
	    query := "SELECT PROFILE_ID,POLICYID,NAME,TYPE,USER_DEFINED,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME,NGFW_VERSION FROM POLICY_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PolicyGroupRow
	        err := rows.Scan(&r.ProfileID, &r.Policyid, &r.Name, &r.Type, &r.UserDefined, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime, &r.NgfwVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PolicyGroupLookupRow struct represents rows of the POLICY_GROUP_LOOKUP table.
type PolicyGroupLookupRow struct {
    DevGroupID	string
    SmsGroupID	string
    ProfileID	string
    VirtualSegmentID	uint
    DeviceID	string
    Deleted	sql.NullInt32
    State	sql.NullInt32
    UpdateTime	sql.NullInt64
}

// IteratePolicyGroupLookup provide access to all rows of the POLICY_GROUP_LOOKUP matching given criteria.
func IteratePolicyGroupLookup(db *sql.DB, where string, callback func(v *PolicyGroupLookupRow) error) error {
    query := "SELECT DEV_GROUP_ID,SMS_GROUP_ID,PROFILE_ID,VIRTUAL_SEGMENT_ID,DEVICE_ID,DELETED,STATE,UPDATE_TIME FROM POLICY_GROUP_LOOKUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PolicyGroupLookupRow
        err := rows.Scan(&r.DevGroupID, &r.SmsGroupID, &r.ProfileID, &r.VirtualSegmentID, &r.DeviceID, &r.Deleted, &r.State, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePolicyGroupLookup provide iterator to all rows of the POLICY_GROUP_LOOKUP matching given criteria.
func RangePolicyGroupLookup(db *sql.DB, where string) iter.Seq2[*PolicyGroupLookupRow, error] {
	return func(yield func(v *PolicyGroupLookupRow, err error) bool) {
	    query := "SELECT DEV_GROUP_ID,SMS_GROUP_ID,PROFILE_ID,VIRTUAL_SEGMENT_ID,DEVICE_ID,DELETED,STATE,UPDATE_TIME FROM POLICY_GROUP_LOOKUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PolicyGroupLookupRow
	        err := rows.Scan(&r.DevGroupID, &r.SmsGroupID, &r.ProfileID, &r.VirtualSegmentID, &r.DeviceID, &r.Deleted, &r.State, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PolicyLookupRow struct represents rows of the POLICY_LOOKUP table.
type PolicyLookupRow struct {
    DevPolicyID	string
    SmsPolicyID	string
    ProfileID	sql.NullString
    DeviceID	string
    VirtualSegmentID	uint
    UpdateTime	uint64
    Deleted	uint16
}

// IteratePolicyLookup provide access to all rows of the POLICY_LOOKUP matching given criteria.
func IteratePolicyLookup(db *sql.DB, where string, callback func(v *PolicyLookupRow) error) error {
    query := "SELECT DEV_POLICY_ID,SMS_POLICY_ID,PROFILE_ID,DEVICE_ID,VIRTUAL_SEGMENT_ID,UPDATE_TIME,DELETED FROM POLICY_LOOKUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PolicyLookupRow
        err := rows.Scan(&r.DevPolicyID, &r.SmsPolicyID, &r.ProfileID, &r.DeviceID, &r.VirtualSegmentID, &r.UpdateTime, &r.Deleted)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePolicyLookup provide iterator to all rows of the POLICY_LOOKUP matching given criteria.
func RangePolicyLookup(db *sql.DB, where string) iter.Seq2[*PolicyLookupRow, error] {
	return func(yield func(v *PolicyLookupRow, err error) bool) {
	    query := "SELECT DEV_POLICY_ID,SMS_POLICY_ID,PROFILE_ID,DEVICE_ID,VIRTUAL_SEGMENT_ID,UPDATE_TIME,DELETED FROM POLICY_LOOKUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PolicyLookupRow
	        err := rows.Scan(&r.DevPolicyID, &r.SmsPolicyID, &r.ProfileID, &r.DeviceID, &r.VirtualSegmentID, &r.UpdateTime, &r.Deleted)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PolicyParamRow struct represents rows of the POLICY_PARAM table.
type PolicyParamRow struct {
    ProfileID	string
    Policyid	string
    Name	string
    Value	sql.NullString
    Type	sql.NullString
}

// IteratePolicyParam provide access to all rows of the POLICY_PARAM matching given criteria.
func IteratePolicyParam(db *sql.DB, where string, callback func(v *PolicyParamRow) error) error {
    query := "SELECT PROFILE_ID,POLICYID,NAME,VALUE,TYPE FROM POLICY_PARAM"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PolicyParamRow
        err := rows.Scan(&r.ProfileID, &r.Policyid, &r.Name, &r.Value, &r.Type)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePolicyParam provide iterator to all rows of the POLICY_PARAM matching given criteria.
func RangePolicyParam(db *sql.DB, where string) iter.Seq2[*PolicyParamRow, error] {
	return func(yield func(v *PolicyParamRow, err error) bool) {
	    query := "SELECT PROFILE_ID,POLICYID,NAME,VALUE,TYPE FROM POLICY_PARAM"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PolicyParamRow
	        err := rows.Scan(&r.ProfileID, &r.Policyid, &r.Name, &r.Value, &r.Type)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PolicyRecommendedActionRow struct represents rows of the POLICY_RECOMMENDED_ACTION table.
type PolicyRecommendedActionRow struct {
    PolicyID	string
    Capability	string
    DeploymentID	string
    Version	string
    NgfwVersion	string
    ActionsetID	sql.NullString
    State	sql.NullInt32
}

// IteratePolicyRecommendedAction provide access to all rows of the POLICY_RECOMMENDED_ACTION matching given criteria.
func IteratePolicyRecommendedAction(db *sql.DB, where string, callback func(v *PolicyRecommendedActionRow) error) error {
    query := "SELECT POLICY_ID,CAPABILITY,DEPLOYMENT_ID,VERSION,NGFW_VERSION,ACTIONSET_ID,STATE FROM POLICY_RECOMMENDED_ACTION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PolicyRecommendedActionRow
        err := rows.Scan(&r.PolicyID, &r.Capability, &r.DeploymentID, &r.Version, &r.NgfwVersion, &r.ActionsetID, &r.State)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePolicyRecommendedAction provide iterator to all rows of the POLICY_RECOMMENDED_ACTION matching given criteria.
func RangePolicyRecommendedAction(db *sql.DB, where string) iter.Seq2[*PolicyRecommendedActionRow, error] {
	return func(yield func(v *PolicyRecommendedActionRow, err error) bool) {
	    query := "SELECT POLICY_ID,CAPABILITY,DEPLOYMENT_ID,VERSION,NGFW_VERSION,ACTIONSET_ID,STATE FROM POLICY_RECOMMENDED_ACTION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PolicyRecommendedActionRow
	        err := rows.Scan(&r.PolicyID, &r.Capability, &r.DeploymentID, &r.Version, &r.NgfwVersion, &r.ActionsetID, &r.State)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PolicySettingsRow struct represents rows of the POLICY_SETTINGS table.
type PolicySettingsRow struct {
    ProfileID	string
    Policyid	string
    Locked	int8
    UseParentSettings	sql.NullByte
    Comment	sql.NullString
}

// IteratePolicySettings provide access to all rows of the POLICY_SETTINGS matching given criteria.
func IteratePolicySettings(db *sql.DB, where string, callback func(v *PolicySettingsRow) error) error {
    query := "SELECT PROFILE_ID,POLICYID,LOCKED,USE_PARENT_SETTINGS,COMMENT FROM POLICY_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PolicySettingsRow
        err := rows.Scan(&r.ProfileID, &r.Policyid, &r.Locked, &r.UseParentSettings, &r.Comment)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePolicySettings provide iterator to all rows of the POLICY_SETTINGS matching given criteria.
func RangePolicySettings(db *sql.DB, where string) iter.Seq2[*PolicySettingsRow, error] {
	return func(yield func(v *PolicySettingsRow, err error) bool) {
	    query := "SELECT PROFILE_ID,POLICYID,LOCKED,USE_PARENT_SETTINGS,COMMENT FROM POLICY_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PolicySettingsRow
	        err := rows.Scan(&r.ProfileID, &r.Policyid, &r.Locked, &r.UseParentSettings, &r.Comment)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PolicyVersionRow struct represents rows of the POLICY_VERSION table.
type PolicyVersionRow struct {
    PolicyID	string
    Version	string
    Sigid	string
    ReqCapabilities	sql.NullString
    RecommendedActionsetID	sql.NullString
    RecommendedState	sql.NullInt32
    IterationID	string
    UpdateTime	int64
    NgfwVersion	string
}

// IteratePolicyVersion provide access to all rows of the POLICY_VERSION matching given criteria.
func IteratePolicyVersion(db *sql.DB, where string, callback func(v *PolicyVersionRow) error) error {
    query := "SELECT POLICY_ID,VERSION,SIGID,REQ_CAPABILITIES,RECOMMENDED_ACTIONSET_ID,RECOMMENDED_STATE,ITERATION_ID,UPDATE_TIME,NGFW_VERSION FROM POLICY_VERSION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PolicyVersionRow
        err := rows.Scan(&r.PolicyID, &r.Version, &r.Sigid, &r.ReqCapabilities, &r.RecommendedActionsetID, &r.RecommendedState, &r.IterationID, &r.UpdateTime, &r.NgfwVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePolicyVersion provide iterator to all rows of the POLICY_VERSION matching given criteria.
func RangePolicyVersion(db *sql.DB, where string) iter.Seq2[*PolicyVersionRow, error] {
	return func(yield func(v *PolicyVersionRow, err error) bool) {
	    query := "SELECT POLICY_ID,VERSION,SIGID,REQ_CAPABILITIES,RECOMMENDED_ACTIONSET_ID,RECOMMENDED_STATE,ITERATION_ID,UPDATE_TIME,NGFW_VERSION FROM POLICY_VERSION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PolicyVersionRow
	        err := rows.Scan(&r.PolicyID, &r.Version, &r.Sigid, &r.ReqCapabilities, &r.RecommendedActionsetID, &r.RecommendedState, &r.IterationID, &r.UpdateTime, &r.NgfwVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PptpConfigRow struct represents rows of the PPTP_CONFIG table.
type PptpConfigRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    Enable	sql.NullByte
    RequireEncryption	sql.NullByte
    DnsProxy	sql.NullByte
    DnsServer1	sql.NullString
    DnsServer2	sql.NullString
    WinsServer1	sql.NullString
    WinsServer2	sql.NullString
    UseRadius	sql.NullByte
    SecurityZoneID	sql.NullInt32
    NamedIPGroupID	sql.NullInt32
}

// IteratePptpConfig provide access to all rows of the PPTP_CONFIG matching given criteria.
func IteratePptpConfig(db *sql.DB, where string, callback func(v *PptpConfigRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,ENABLE,REQUIRE_ENCRYPTION,DNS_PROXY,DNS_SERVER1,DNS_SERVER2,WINS_SERVER1,WINS_SERVER2,USE_RADIUS,SECURITY_ZONE_ID,NAMED_IP_GROUP_ID FROM PPTP_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PptpConfigRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Enable, &r.RequireEncryption, &r.DnsProxy, &r.DnsServer1, &r.DnsServer2, &r.WinsServer1, &r.WinsServer2, &r.UseRadius, &r.SecurityZoneID, &r.NamedIPGroupID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePptpConfig provide iterator to all rows of the PPTP_CONFIG matching given criteria.
func RangePptpConfig(db *sql.DB, where string) iter.Seq2[*PptpConfigRow, error] {
	return func(yield func(v *PptpConfigRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,ENABLE,REQUIRE_ENCRYPTION,DNS_PROXY,DNS_SERVER1,DNS_SERVER2,WINS_SERVER1,WINS_SERVER2,USE_RADIUS,SECURITY_ZONE_ID,NAMED_IP_GROUP_ID FROM PPTP_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PptpConfigRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Enable, &r.RequireEncryption, &r.DnsProxy, &r.DnsServer1, &r.DnsServer2, &r.WinsServer1, &r.WinsServer2, &r.UseRadius, &r.SecurityZoneID, &r.NamedIPGroupID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// PrivilegeGroupRow struct represents rows of the PRIVILEGE_GROUP table.
type PrivilegeGroupRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    Name	sql.NullString
    VpnClientAccess	sql.NullByte
    PolicyAuth	sql.NullByte
    ContentFilteringBypass	sql.NullInt32
}

// IteratePrivilegeGroup provide access to all rows of the PRIVILEGE_GROUP matching given criteria.
func IteratePrivilegeGroup(db *sql.DB, where string, callback func(v *PrivilegeGroupRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,NAME,VPN_CLIENT_ACCESS,POLICY_AUTH,CONTENT_FILTERING_BYPASS FROM PRIVILEGE_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r PrivilegeGroupRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Name, &r.VpnClientAccess, &r.PolicyAuth, &r.ContentFilteringBypass)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangePrivilegeGroup provide iterator to all rows of the PRIVILEGE_GROUP matching given criteria.
func RangePrivilegeGroup(db *sql.DB, where string) iter.Seq2[*PrivilegeGroupRow, error] {
	return func(yield func(v *PrivilegeGroupRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,NAME,VPN_CLIENT_ACCESS,POLICY_AUTH,CONTENT_FILTERING_BYPASS FROM PRIVILEGE_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r PrivilegeGroupRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.Name, &r.VpnClientAccess, &r.PolicyAuth, &r.ContentFilteringBypass)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ProfileRow struct represents rows of the PROFILE table.
type ProfileRow struct {
    ID	string
    Version	string
    Name	string
    Description	sql.NullString
    UpdateTime	int64
    Modified	string
    NextVersion	sql.NullString
    DeploymentID	string
    ParentID	string
    MetadataEnabled	sql.NullByte
    UrimetaEnabled	sql.NullByte
}

// IterateProfile provide access to all rows of the PROFILE matching given criteria.
func IterateProfile(db *sql.DB, where string, callback func(v *ProfileRow) error) error {
    query := "SELECT ID,VERSION,NAME,DESCRIPTION,UPDATE_TIME,MODIFIED,NEXT_VERSION,DEPLOYMENT_ID,PARENT_ID,METADATA_ENABLED,URIMETA_ENABLED FROM PROFILE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ProfileRow
        err := rows.Scan(&r.ID, &r.Version, &r.Name, &r.Description, &r.UpdateTime, &r.Modified, &r.NextVersion, &r.DeploymentID, &r.ParentID, &r.MetadataEnabled, &r.UrimetaEnabled)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeProfile provide iterator to all rows of the PROFILE matching given criteria.
func RangeProfile(db *sql.DB, where string) iter.Seq2[*ProfileRow, error] {
	return func(yield func(v *ProfileRow, err error) bool) {
	    query := "SELECT ID,VERSION,NAME,DESCRIPTION,UPDATE_TIME,MODIFIED,NEXT_VERSION,DEPLOYMENT_ID,PARENT_ID,METADATA_ENABLED,URIMETA_ENABLED FROM PROFILE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ProfileRow
	        err := rows.Scan(&r.ID, &r.Version, &r.Name, &r.Description, &r.UpdateTime, &r.Modified, &r.NextVersion, &r.DeploymentID, &r.ParentID, &r.MetadataEnabled, &r.UrimetaEnabled)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ProfileCveIgnoreRow struct represents rows of the PROFILE_CVE_IGNORE table.
type ProfileCveIgnoreRow struct {
    ID	uint
    ProfileID	string
    CveID	string
}

// IterateProfileCveIgnore provide access to all rows of the PROFILE_CVE_IGNORE matching given criteria.
func IterateProfileCveIgnore(db *sql.DB, where string, callback func(v *ProfileCveIgnoreRow) error) error {
    query := "SELECT ID,PROFILE_ID,CVE_ID FROM PROFILE_CVE_IGNORE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ProfileCveIgnoreRow
        err := rows.Scan(&r.ID, &r.ProfileID, &r.CveID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeProfileCveIgnore provide iterator to all rows of the PROFILE_CVE_IGNORE matching given criteria.
func RangeProfileCveIgnore(db *sql.DB, where string) iter.Seq2[*ProfileCveIgnoreRow, error] {
	return func(yield func(v *ProfileCveIgnoreRow, err error) bool) {
	    query := "SELECT ID,PROFILE_ID,CVE_ID FROM PROFILE_CVE_IGNORE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ProfileCveIgnoreRow
	        err := rows.Scan(&r.ID, &r.ProfileID, &r.CveID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ProfileFilterVulnIgnoreRow struct represents rows of the PROFILE_FILTER_VULN_IGNORE table.
type ProfileFilterVulnIgnoreRow struct {
    ID	uint
    ProfileID	string
    PolicyID	string
}

// IterateProfileFilterVulnIgnore provide access to all rows of the PROFILE_FILTER_VULN_IGNORE matching given criteria.
func IterateProfileFilterVulnIgnore(db *sql.DB, where string, callback func(v *ProfileFilterVulnIgnoreRow) error) error {
    query := "SELECT ID,PROFILE_ID,POLICY_ID FROM PROFILE_FILTER_VULN_IGNORE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ProfileFilterVulnIgnoreRow
        err := rows.Scan(&r.ID, &r.ProfileID, &r.PolicyID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeProfileFilterVulnIgnore provide iterator to all rows of the PROFILE_FILTER_VULN_IGNORE matching given criteria.
func RangeProfileFilterVulnIgnore(db *sql.DB, where string) iter.Seq2[*ProfileFilterVulnIgnoreRow, error] {
	return func(yield func(v *ProfileFilterVulnIgnoreRow, err error) bool) {
	    query := "SELECT ID,PROFILE_ID,POLICY_ID FROM PROFILE_FILTER_VULN_IGNORE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ProfileFilterVulnIgnoreRow
	        err := rows.Scan(&r.ID, &r.ProfileID, &r.PolicyID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ProfileHistoryRow struct represents rows of the PROFILE_HISTORY table.
type ProfileHistoryRow struct {
    ProfileID	string
    HistoryID	int64
    Version	string
    ProfileType	string
    SmsUserID	sql.NullString
    Details	sql.NullString
    UpdateTime	int64
}

// IterateProfileHistory provide access to all rows of the PROFILE_HISTORY matching given criteria.
func IterateProfileHistory(db *sql.DB, where string, callback func(v *ProfileHistoryRow) error) error {
    query := "SELECT PROFILE_ID,HISTORY_ID,VERSION,PROFILE_TYPE,SMS_USER_ID,DETAILS,UPDATE_TIME FROM PROFILE_HISTORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ProfileHistoryRow
        err := rows.Scan(&r.ProfileID, &r.HistoryID, &r.Version, &r.ProfileType, &r.SmsUserID, &r.Details, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeProfileHistory provide iterator to all rows of the PROFILE_HISTORY matching given criteria.
func RangeProfileHistory(db *sql.DB, where string) iter.Seq2[*ProfileHistoryRow, error] {
	return func(yield func(v *ProfileHistoryRow, err error) bool) {
	    query := "SELECT PROFILE_ID,HISTORY_ID,VERSION,PROFILE_TYPE,SMS_USER_ID,DETAILS,UPDATE_TIME FROM PROFILE_HISTORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ProfileHistoryRow
	        err := rows.Scan(&r.ProfileID, &r.HistoryID, &r.Version, &r.ProfileType, &r.SmsUserID, &r.Details, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ProfileInstallInventoryRow struct represents rows of the PROFILE_INSTALL_INVENTORY table.
type ProfileInstallInventoryRow struct {
    ProfileID	string
    ProfileVersion	string
    ObjectType	int
    ObjectID	string
    VirtualSegmentID	sql.NullInt32
    DistributeID	string
    CompleteTime	int64
}

// IterateProfileInstallInventory provide access to all rows of the PROFILE_INSTALL_INVENTORY matching given criteria.
func IterateProfileInstallInventory(db *sql.DB, where string, callback func(v *ProfileInstallInventoryRow) error) error {
    query := "SELECT PROFILE_ID,PROFILE_VERSION,OBJECT_TYPE,OBJECT_ID,VIRTUAL_SEGMENT_ID,DISTRIBUTE_ID,COMPLETE_TIME FROM PROFILE_INSTALL_INVENTORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ProfileInstallInventoryRow
        err := rows.Scan(&r.ProfileID, &r.ProfileVersion, &r.ObjectType, &r.ObjectID, &r.VirtualSegmentID, &r.DistributeID, &r.CompleteTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeProfileInstallInventory provide iterator to all rows of the PROFILE_INSTALL_INVENTORY matching given criteria.
func RangeProfileInstallInventory(db *sql.DB, where string) iter.Seq2[*ProfileInstallInventoryRow, error] {
	return func(yield func(v *ProfileInstallInventoryRow, err error) bool) {
	    query := "SELECT PROFILE_ID,PROFILE_VERSION,OBJECT_TYPE,OBJECT_ID,VIRTUAL_SEGMENT_ID,DISTRIBUTE_ID,COMPLETE_TIME FROM PROFILE_INSTALL_INVENTORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ProfileInstallInventoryRow
	        err := rows.Scan(&r.ProfileID, &r.ProfileVersion, &r.ObjectType, &r.ObjectID, &r.VirtualSegmentID, &r.DistributeID, &r.CompleteTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ProfileQuerySpecRow struct represents rows of the PROFILE_QUERY_SPEC table.
type ProfileQuerySpecRow struct {
    ID	uint
    Name	string
    SearchSettings	sql.NullString
}

// IterateProfileQuerySpec provide access to all rows of the PROFILE_QUERY_SPEC matching given criteria.
func IterateProfileQuerySpec(db *sql.DB, where string, callback func(v *ProfileQuerySpecRow) error) error {
    query := "SELECT ID,NAME,SEARCH_SETTINGS FROM PROFILE_QUERY_SPEC"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ProfileQuerySpecRow
        err := rows.Scan(&r.ID, &r.Name, &r.SearchSettings)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeProfileQuerySpec provide iterator to all rows of the PROFILE_QUERY_SPEC matching given criteria.
func RangeProfileQuerySpec(db *sql.DB, where string) iter.Seq2[*ProfileQuerySpecRow, error] {
	return func(yield func(v *ProfileQuerySpecRow, err error) bool) {
	    query := "SELECT ID,NAME,SEARCH_SETTINGS FROM PROFILE_QUERY_SPEC"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ProfileQuerySpecRow
	        err := rows.Scan(&r.ID, &r.Name, &r.SearchSettings)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ProfileRepSettingsRow struct represents rows of the PROFILE_REP_SETTINGS table.
type ProfileRepSettingsRow struct {
    ID	uint
    ProfileID	string
    PendingAction	string
    TargetAddress	string
    UseParentSettings	int8
    Locked	int8
}

// IterateProfileRepSettings provide access to all rows of the PROFILE_REP_SETTINGS matching given criteria.
func IterateProfileRepSettings(db *sql.DB, where string, callback func(v *ProfileRepSettingsRow) error) error {
    query := "SELECT ID,PROFILE_ID,PENDING_ACTION,TARGET_ADDRESS,USE_PARENT_SETTINGS,LOCKED FROM PROFILE_REP_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ProfileRepSettingsRow
        err := rows.Scan(&r.ID, &r.ProfileID, &r.PendingAction, &r.TargetAddress, &r.UseParentSettings, &r.Locked)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeProfileRepSettings provide iterator to all rows of the PROFILE_REP_SETTINGS matching given criteria.
func RangeProfileRepSettings(db *sql.DB, where string) iter.Seq2[*ProfileRepSettingsRow, error] {
	return func(yield func(v *ProfileRepSettingsRow, err error) bool) {
	    query := "SELECT ID,PROFILE_ID,PENDING_ACTION,TARGET_ADDRESS,USE_PARENT_SETTINGS,LOCKED FROM PROFILE_REP_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ProfileRepSettingsRow
	        err := rows.Scan(&r.ID, &r.ProfileID, &r.PendingAction, &r.TargetAddress, &r.UseParentSettings, &r.Locked)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ProfileSnapshotRow struct represents rows of the PROFILE_SNAPSHOT table.
type ProfileSnapshotRow struct {
    ProfileID	string
    Version	string
    Filename	sql.NullString
    Comments	sql.NullString
    CreationTime	int64
    DeploymentID	string
    ParentID	string
}

// IterateProfileSnapshot provide access to all rows of the PROFILE_SNAPSHOT matching given criteria.
func IterateProfileSnapshot(db *sql.DB, where string, callback func(v *ProfileSnapshotRow) error) error {
    query := "SELECT PROFILE_ID,VERSION,FILENAME,COMMENTS,CREATION_TIME,DEPLOYMENT_ID,PARENT_ID FROM PROFILE_SNAPSHOT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ProfileSnapshotRow
        err := rows.Scan(&r.ProfileID, &r.Version, &r.Filename, &r.Comments, &r.CreationTime, &r.DeploymentID, &r.ParentID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeProfileSnapshot provide iterator to all rows of the PROFILE_SNAPSHOT matching given criteria.
func RangeProfileSnapshot(db *sql.DB, where string) iter.Seq2[*ProfileSnapshotRow, error] {
	return func(yield func(v *ProfileSnapshotRow, err error) bool) {
	    query := "SELECT PROFILE_ID,VERSION,FILENAME,COMMENTS,CREATION_TIME,DEPLOYMENT_ID,PARENT_ID FROM PROFILE_SNAPSHOT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ProfileSnapshotRow
	        err := rows.Scan(&r.ProfileID, &r.Version, &r.Filename, &r.Comments, &r.CreationTime, &r.DeploymentID, &r.ParentID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ProfileUserGroupsRow struct represents rows of the PROFILE_USER_GROUPS table.
type ProfileUserGroupsRow struct {
    UserGroupsIDFk	uint
    ProfileIDFk	string
}

// IterateProfileUserGroups provide access to all rows of the PROFILE_USER_GROUPS matching given criteria.
func IterateProfileUserGroups(db *sql.DB, where string, callback func(v *ProfileUserGroupsRow) error) error {
    query := "SELECT USER_GROUPS_ID_FK,PROFILE_ID_FK FROM PROFILE_USER_GROUPS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ProfileUserGroupsRow
        err := rows.Scan(&r.UserGroupsIDFk, &r.ProfileIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeProfileUserGroups provide iterator to all rows of the PROFILE_USER_GROUPS matching given criteria.
func RangeProfileUserGroups(db *sql.DB, where string) iter.Seq2[*ProfileUserGroupsRow, error] {
	return func(yield func(v *ProfileUserGroupsRow, err error) bool) {
	    query := "SELECT USER_GROUPS_ID_FK,PROFILE_ID_FK FROM PROFILE_USER_GROUPS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ProfileUserGroupsRow
	        err := rows.Scan(&r.UserGroupsIDFk, &r.ProfileIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ProtocolServiceEntryRow struct represents rows of the PROTOCOL_SERVICE_ENTRY table.
type ProtocolServiceEntryRow struct {
    ID	uint
    EntryUuid	string
    EntryType	string
    ProtocolType	string
    PortStart	sql.NullInt32
    PortEnd	sql.NullInt32
    IPProtocolNumber	sql.NullInt32
    IcmpType	sql.NullInt32
    IcmpCode	sql.NullInt32
    IpsLegacyEntryUuid	sql.NullString
    Version	uint
}

// IterateProtocolServiceEntry provide access to all rows of the PROTOCOL_SERVICE_ENTRY matching given criteria.
func IterateProtocolServiceEntry(db *sql.DB, where string, callback func(v *ProtocolServiceEntryRow) error) error {
    query := "SELECT ID,ENTRY_UUID,ENTRY_TYPE,PROTOCOL_TYPE,PORT_START,PORT_END,IP_PROTOCOL_NUMBER,ICMP_TYPE,ICMP_CODE,IPS_LEGACY_ENTRY_UUID,VERSION FROM PROTOCOL_SERVICE_ENTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ProtocolServiceEntryRow
        err := rows.Scan(&r.ID, &r.EntryUuid, &r.EntryType, &r.ProtocolType, &r.PortStart, &r.PortEnd, &r.IPProtocolNumber, &r.IcmpType, &r.IcmpCode, &r.IpsLegacyEntryUuid, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeProtocolServiceEntry provide iterator to all rows of the PROTOCOL_SERVICE_ENTRY matching given criteria.
func RangeProtocolServiceEntry(db *sql.DB, where string) iter.Seq2[*ProtocolServiceEntryRow, error] {
	return func(yield func(v *ProtocolServiceEntryRow, err error) bool) {
	    query := "SELECT ID,ENTRY_UUID,ENTRY_TYPE,PROTOCOL_TYPE,PORT_START,PORT_END,IP_PROTOCOL_NUMBER,ICMP_TYPE,ICMP_CODE,IPS_LEGACY_ENTRY_UUID,VERSION FROM PROTOCOL_SERVICE_ENTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ProtocolServiceEntryRow
	        err := rows.Scan(&r.ID, &r.EntryUuid, &r.EntryType, &r.ProtocolType, &r.PortStart, &r.PortEnd, &r.IPProtocolNumber, &r.IcmpType, &r.IcmpCode, &r.IpsLegacyEntryUuid, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ProtocolServiceEntryMapRow struct represents rows of the PROTOCOL_SERVICE_ENTRY_MAP table.
type ProtocolServiceEntryMapRow struct {
    NamedServiceID	uint
    ServiceEntryID	uint
}

// IterateProtocolServiceEntryMap provide access to all rows of the PROTOCOL_SERVICE_ENTRY_MAP matching given criteria.
func IterateProtocolServiceEntryMap(db *sql.DB, where string, callback func(v *ProtocolServiceEntryMapRow) error) error {
    query := "SELECT NAMED_SERVICE_ID,SERVICE_ENTRY_ID FROM PROTOCOL_SERVICE_ENTRY_MAP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ProtocolServiceEntryMapRow
        err := rows.Scan(&r.NamedServiceID, &r.ServiceEntryID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeProtocolServiceEntryMap provide iterator to all rows of the PROTOCOL_SERVICE_ENTRY_MAP matching given criteria.
func RangeProtocolServiceEntryMap(db *sql.DB, where string) iter.Seq2[*ProtocolServiceEntryMapRow, error] {
	return func(yield func(v *ProtocolServiceEntryMapRow, err error) bool) {
	    query := "SELECT NAMED_SERVICE_ID,SERVICE_ENTRY_ID FROM PROTOCOL_SERVICE_ENTRY_MAP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ProtocolServiceEntryMapRow
	        err := rows.Scan(&r.NamedServiceID, &r.ServiceEntryID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QpePolicyRow struct represents rows of the QPE_POLICY table.
type QpePolicyRow struct {
    ID	uint
    PolicyName	sql.NullString
    AllowManual	sql.NullByte
    AllowExternal	sql.NullByte
    EscalateIpsQtine	sql.NullByte
    EnableAuto	sql.NullByte
    OriginatingDeviceOnly	sql.NullByte
    HitThresholdCount	sql.NullInt32
    HitThresholdPeriod	sql.NullInt32
    QuietPeriod	sql.NullInt32
    QuarantineTimeout	sql.NullInt32
    ApplyList	sql.NullInt32
    IgnoreList	sql.NullInt32
    SysLogID	sql.NullInt32
    SnmpDestID	sql.NullInt32
    IeeCompositeActionID	sql.NullInt32
}

// IterateQpePolicy provide access to all rows of the QPE_POLICY matching given criteria.
func IterateQpePolicy(db *sql.DB, where string, callback func(v *QpePolicyRow) error) error {
    query := "SELECT ID,POLICY_NAME,ALLOW_MANUAL,ALLOW_EXTERNAL,ESCALATE_IPS_QTINE,ENABLE_AUTO,ORIGINATING_DEVICE_ONLY,HIT_THRESHOLD_COUNT,HIT_THRESHOLD_PERIOD,QUIET_PERIOD,QUARANTINE_TIMEOUT,APPLY_LIST,IGNORE_LIST,SYS_LOG_ID,SNMP_DEST_ID,IEE_COMPOSITE_ACTION_ID FROM QPE_POLICY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QpePolicyRow
        err := rows.Scan(&r.ID, &r.PolicyName, &r.AllowManual, &r.AllowExternal, &r.EscalateIpsQtine, &r.EnableAuto, &r.OriginatingDeviceOnly, &r.HitThresholdCount, &r.HitThresholdPeriod, &r.QuietPeriod, &r.QuarantineTimeout, &r.ApplyList, &r.IgnoreList, &r.SysLogID, &r.SnmpDestID, &r.IeeCompositeActionID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQpePolicy provide iterator to all rows of the QPE_POLICY matching given criteria.
func RangeQpePolicy(db *sql.DB, where string) iter.Seq2[*QpePolicyRow, error] {
	return func(yield func(v *QpePolicyRow, err error) bool) {
	    query := "SELECT ID,POLICY_NAME,ALLOW_MANUAL,ALLOW_EXTERNAL,ESCALATE_IPS_QTINE,ENABLE_AUTO,ORIGINATING_DEVICE_ONLY,HIT_THRESHOLD_COUNT,HIT_THRESHOLD_PERIOD,QUIET_PERIOD,QUARANTINE_TIMEOUT,APPLY_LIST,IGNORE_LIST,SYS_LOG_ID,SNMP_DEST_ID,IEE_COMPOSITE_ACTION_ID FROM QPE_POLICY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QpePolicyRow
	        err := rows.Scan(&r.ID, &r.PolicyName, &r.AllowManual, &r.AllowExternal, &r.EscalateIpsQtine, &r.EnableAuto, &r.OriginatingDeviceOnly, &r.HitThresholdCount, &r.HitThresholdPeriod, &r.QuietPeriod, &r.QuarantineTimeout, &r.ApplyList, &r.IgnoreList, &r.SysLogID, &r.SnmpDestID, &r.IeeCompositeActionID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QpePolicyDeviceRow struct represents rows of the QPE_POLICY_DEVICE table.
type QpePolicyDeviceRow struct {
    QpePolicyID	uint
    TptDeviceID	string
}

// IterateQpePolicyDevice provide access to all rows of the QPE_POLICY_DEVICE matching given criteria.
func IterateQpePolicyDevice(db *sql.DB, where string, callback func(v *QpePolicyDeviceRow) error) error {
    query := "SELECT QPE_POLICY_ID,TPT_DEVICE_ID FROM QPE_POLICY_DEVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QpePolicyDeviceRow
        err := rows.Scan(&r.QpePolicyID, &r.TptDeviceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQpePolicyDevice provide iterator to all rows of the QPE_POLICY_DEVICE matching given criteria.
func RangeQpePolicyDevice(db *sql.DB, where string) iter.Seq2[*QpePolicyDeviceRow, error] {
	return func(yield func(v *QpePolicyDeviceRow, err error) bool) {
	    query := "SELECT QPE_POLICY_ID,TPT_DEVICE_ID FROM QPE_POLICY_DEVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QpePolicyDeviceRow
	        err := rows.Scan(&r.QpePolicyID, &r.TptDeviceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QpePolicyDeviceGroupRow struct represents rows of the QPE_POLICY_DEVICE_GROUP table.
type QpePolicyDeviceGroupRow struct {
    QpePolicyID	uint
    DeviceGroupID	uint
}

// IterateQpePolicyDeviceGroup provide access to all rows of the QPE_POLICY_DEVICE_GROUP matching given criteria.
func IterateQpePolicyDeviceGroup(db *sql.DB, where string, callback func(v *QpePolicyDeviceGroupRow) error) error {
    query := "SELECT QPE_POLICY_ID,DEVICE_GROUP_ID FROM QPE_POLICY_DEVICE_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QpePolicyDeviceGroupRow
        err := rows.Scan(&r.QpePolicyID, &r.DeviceGroupID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQpePolicyDeviceGroup provide iterator to all rows of the QPE_POLICY_DEVICE_GROUP matching given criteria.
func RangeQpePolicyDeviceGroup(db *sql.DB, where string) iter.Seq2[*QpePolicyDeviceGroupRow, error] {
	return func(yield func(v *QpePolicyDeviceGroupRow, err error) bool) {
	    query := "SELECT QPE_POLICY_ID,DEVICE_GROUP_ID FROM QPE_POLICY_DEVICE_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QpePolicyDeviceGroupRow
	        err := rows.Scan(&r.QpePolicyID, &r.DeviceGroupID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QrtzBlobTriggersRow struct represents rows of the QRTZ_BLOB_TRIGGERS table.
type QrtzBlobTriggersRow struct {
    TriggerName	string
    TriggerGroup	string
    BlobData	[]byte
}

// IterateQrtzBlobTriggers provide access to all rows of the QRTZ_BLOB_TRIGGERS matching given criteria.
func IterateQrtzBlobTriggers(db *sql.DB, where string, callback func(v *QrtzBlobTriggersRow) error) error {
    query := "SELECT TRIGGER_NAME,TRIGGER_GROUP,BLOB_DATA FROM QRTZ_BLOB_TRIGGERS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QrtzBlobTriggersRow
        err := rows.Scan(&r.TriggerName, &r.TriggerGroup, &r.BlobData)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQrtzBlobTriggers provide iterator to all rows of the QRTZ_BLOB_TRIGGERS matching given criteria.
func RangeQrtzBlobTriggers(db *sql.DB, where string) iter.Seq2[*QrtzBlobTriggersRow, error] {
	return func(yield func(v *QrtzBlobTriggersRow, err error) bool) {
	    query := "SELECT TRIGGER_NAME,TRIGGER_GROUP,BLOB_DATA FROM QRTZ_BLOB_TRIGGERS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QrtzBlobTriggersRow
	        err := rows.Scan(&r.TriggerName, &r.TriggerGroup, &r.BlobData)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QrtzCalendarsRow struct represents rows of the QRTZ_CALENDARS table.
type QrtzCalendarsRow struct {
    CalendarName	string
    Calendar	[]byte
}

// IterateQrtzCalendars provide access to all rows of the QRTZ_CALENDARS matching given criteria.
func IterateQrtzCalendars(db *sql.DB, where string, callback func(v *QrtzCalendarsRow) error) error {
    query := "SELECT CALENDAR_NAME,CALENDAR FROM QRTZ_CALENDARS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QrtzCalendarsRow
        err := rows.Scan(&r.CalendarName, &r.Calendar)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQrtzCalendars provide iterator to all rows of the QRTZ_CALENDARS matching given criteria.
func RangeQrtzCalendars(db *sql.DB, where string) iter.Seq2[*QrtzCalendarsRow, error] {
	return func(yield func(v *QrtzCalendarsRow, err error) bool) {
	    query := "SELECT CALENDAR_NAME,CALENDAR FROM QRTZ_CALENDARS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QrtzCalendarsRow
	        err := rows.Scan(&r.CalendarName, &r.Calendar)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QrtzCronTriggersRow struct represents rows of the QRTZ_CRON_TRIGGERS table.
type QrtzCronTriggersRow struct {
    TriggerName	string
    TriggerGroup	string
    CronExpression	string
    TimeZoneID	sql.NullString
}

// IterateQrtzCronTriggers provide access to all rows of the QRTZ_CRON_TRIGGERS matching given criteria.
func IterateQrtzCronTriggers(db *sql.DB, where string, callback func(v *QrtzCronTriggersRow) error) error {
    query := "SELECT TRIGGER_NAME,TRIGGER_GROUP,CRON_EXPRESSION,TIME_ZONE_ID FROM QRTZ_CRON_TRIGGERS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QrtzCronTriggersRow
        err := rows.Scan(&r.TriggerName, &r.TriggerGroup, &r.CronExpression, &r.TimeZoneID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQrtzCronTriggers provide iterator to all rows of the QRTZ_CRON_TRIGGERS matching given criteria.
func RangeQrtzCronTriggers(db *sql.DB, where string) iter.Seq2[*QrtzCronTriggersRow, error] {
	return func(yield func(v *QrtzCronTriggersRow, err error) bool) {
	    query := "SELECT TRIGGER_NAME,TRIGGER_GROUP,CRON_EXPRESSION,TIME_ZONE_ID FROM QRTZ_CRON_TRIGGERS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QrtzCronTriggersRow
	        err := rows.Scan(&r.TriggerName, &r.TriggerGroup, &r.CronExpression, &r.TimeZoneID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QrtzFiredTriggersRow struct represents rows of the QRTZ_FIRED_TRIGGERS table.
type QrtzFiredTriggersRow struct {
    EntryID	string
    TriggerName	string
    TriggerGroup	string
    IsVolatile	string
    InstanceName	string
    FiredTime	int64
    Priority	int
    State	string
    JobName	sql.NullString
    JobGroup	sql.NullString
    IsStateful	sql.NullString
    RequestsRecovery	sql.NullString
}

// IterateQrtzFiredTriggers provide access to all rows of the QRTZ_FIRED_TRIGGERS matching given criteria.
func IterateQrtzFiredTriggers(db *sql.DB, where string, callback func(v *QrtzFiredTriggersRow) error) error {
    query := "SELECT ENTRY_ID,TRIGGER_NAME,TRIGGER_GROUP,IS_VOLATILE,INSTANCE_NAME,FIRED_TIME,PRIORITY,STATE,JOB_NAME,JOB_GROUP,IS_STATEFUL,REQUESTS_RECOVERY FROM QRTZ_FIRED_TRIGGERS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QrtzFiredTriggersRow
        err := rows.Scan(&r.EntryID, &r.TriggerName, &r.TriggerGroup, &r.IsVolatile, &r.InstanceName, &r.FiredTime, &r.Priority, &r.State, &r.JobName, &r.JobGroup, &r.IsStateful, &r.RequestsRecovery)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQrtzFiredTriggers provide iterator to all rows of the QRTZ_FIRED_TRIGGERS matching given criteria.
func RangeQrtzFiredTriggers(db *sql.DB, where string) iter.Seq2[*QrtzFiredTriggersRow, error] {
	return func(yield func(v *QrtzFiredTriggersRow, err error) bool) {
	    query := "SELECT ENTRY_ID,TRIGGER_NAME,TRIGGER_GROUP,IS_VOLATILE,INSTANCE_NAME,FIRED_TIME,PRIORITY,STATE,JOB_NAME,JOB_GROUP,IS_STATEFUL,REQUESTS_RECOVERY FROM QRTZ_FIRED_TRIGGERS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QrtzFiredTriggersRow
	        err := rows.Scan(&r.EntryID, &r.TriggerName, &r.TriggerGroup, &r.IsVolatile, &r.InstanceName, &r.FiredTime, &r.Priority, &r.State, &r.JobName, &r.JobGroup, &r.IsStateful, &r.RequestsRecovery)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QrtzJobDetailsRow struct represents rows of the QRTZ_JOB_DETAILS table.
type QrtzJobDetailsRow struct {
    JobName	string
    JobGroup	string
    Description	sql.NullString
    JobClassName	string
    IsDurable	string
    IsVolatile	string
    IsStateful	string
    RequestsRecovery	string
    JobData	[]byte
}

// IterateQrtzJobDetails provide access to all rows of the QRTZ_JOB_DETAILS matching given criteria.
func IterateQrtzJobDetails(db *sql.DB, where string, callback func(v *QrtzJobDetailsRow) error) error {
    query := "SELECT JOB_NAME,JOB_GROUP,DESCRIPTION,JOB_CLASS_NAME,IS_DURABLE,IS_VOLATILE,IS_STATEFUL,REQUESTS_RECOVERY,JOB_DATA FROM QRTZ_JOB_DETAILS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QrtzJobDetailsRow
        err := rows.Scan(&r.JobName, &r.JobGroup, &r.Description, &r.JobClassName, &r.IsDurable, &r.IsVolatile, &r.IsStateful, &r.RequestsRecovery, &r.JobData)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQrtzJobDetails provide iterator to all rows of the QRTZ_JOB_DETAILS matching given criteria.
func RangeQrtzJobDetails(db *sql.DB, where string) iter.Seq2[*QrtzJobDetailsRow, error] {
	return func(yield func(v *QrtzJobDetailsRow, err error) bool) {
	    query := "SELECT JOB_NAME,JOB_GROUP,DESCRIPTION,JOB_CLASS_NAME,IS_DURABLE,IS_VOLATILE,IS_STATEFUL,REQUESTS_RECOVERY,JOB_DATA FROM QRTZ_JOB_DETAILS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QrtzJobDetailsRow
	        err := rows.Scan(&r.JobName, &r.JobGroup, &r.Description, &r.JobClassName, &r.IsDurable, &r.IsVolatile, &r.IsStateful, &r.RequestsRecovery, &r.JobData)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QrtzJobListenersRow struct represents rows of the QRTZ_JOB_LISTENERS table.
type QrtzJobListenersRow struct {
    JobName	string
    JobGroup	string
    JobListener	string
}

// IterateQrtzJobListeners provide access to all rows of the QRTZ_JOB_LISTENERS matching given criteria.
func IterateQrtzJobListeners(db *sql.DB, where string, callback func(v *QrtzJobListenersRow) error) error {
    query := "SELECT JOB_NAME,JOB_GROUP,JOB_LISTENER FROM QRTZ_JOB_LISTENERS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QrtzJobListenersRow
        err := rows.Scan(&r.JobName, &r.JobGroup, &r.JobListener)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQrtzJobListeners provide iterator to all rows of the QRTZ_JOB_LISTENERS matching given criteria.
func RangeQrtzJobListeners(db *sql.DB, where string) iter.Seq2[*QrtzJobListenersRow, error] {
	return func(yield func(v *QrtzJobListenersRow, err error) bool) {
	    query := "SELECT JOB_NAME,JOB_GROUP,JOB_LISTENER FROM QRTZ_JOB_LISTENERS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QrtzJobListenersRow
	        err := rows.Scan(&r.JobName, &r.JobGroup, &r.JobListener)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QrtzLocksRow struct represents rows of the QRTZ_LOCKS table.
type QrtzLocksRow struct {
    LockName	string
}

// IterateQrtzLocks provide access to all rows of the QRTZ_LOCKS matching given criteria.
func IterateQrtzLocks(db *sql.DB, where string, callback func(v *QrtzLocksRow) error) error {
    query := "SELECT LOCK_NAME FROM QRTZ_LOCKS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QrtzLocksRow
        err := rows.Scan(&r.LockName)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQrtzLocks provide iterator to all rows of the QRTZ_LOCKS matching given criteria.
func RangeQrtzLocks(db *sql.DB, where string) iter.Seq2[*QrtzLocksRow, error] {
	return func(yield func(v *QrtzLocksRow, err error) bool) {
	    query := "SELECT LOCK_NAME FROM QRTZ_LOCKS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QrtzLocksRow
	        err := rows.Scan(&r.LockName)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QrtzPausedTriggerGrpsRow struct represents rows of the QRTZ_PAUSED_TRIGGER_GRPS table.
type QrtzPausedTriggerGrpsRow struct {
    TriggerGroup	string
}

// IterateQrtzPausedTriggerGrps provide access to all rows of the QRTZ_PAUSED_TRIGGER_GRPS matching given criteria.
func IterateQrtzPausedTriggerGrps(db *sql.DB, where string, callback func(v *QrtzPausedTriggerGrpsRow) error) error {
    query := "SELECT TRIGGER_GROUP FROM QRTZ_PAUSED_TRIGGER_GRPS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QrtzPausedTriggerGrpsRow
        err := rows.Scan(&r.TriggerGroup)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQrtzPausedTriggerGrps provide iterator to all rows of the QRTZ_PAUSED_TRIGGER_GRPS matching given criteria.
func RangeQrtzPausedTriggerGrps(db *sql.DB, where string) iter.Seq2[*QrtzPausedTriggerGrpsRow, error] {
	return func(yield func(v *QrtzPausedTriggerGrpsRow, err error) bool) {
	    query := "SELECT TRIGGER_GROUP FROM QRTZ_PAUSED_TRIGGER_GRPS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QrtzPausedTriggerGrpsRow
	        err := rows.Scan(&r.TriggerGroup)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QrtzSchedulerStateRow struct represents rows of the QRTZ_SCHEDULER_STATE table.
type QrtzSchedulerStateRow struct {
    InstanceName	string
    LastCheckinTime	int64
    CheckinInterval	int64
}

// IterateQrtzSchedulerState provide access to all rows of the QRTZ_SCHEDULER_STATE matching given criteria.
func IterateQrtzSchedulerState(db *sql.DB, where string, callback func(v *QrtzSchedulerStateRow) error) error {
    query := "SELECT INSTANCE_NAME,LAST_CHECKIN_TIME,CHECKIN_INTERVAL FROM QRTZ_SCHEDULER_STATE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QrtzSchedulerStateRow
        err := rows.Scan(&r.InstanceName, &r.LastCheckinTime, &r.CheckinInterval)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQrtzSchedulerState provide iterator to all rows of the QRTZ_SCHEDULER_STATE matching given criteria.
func RangeQrtzSchedulerState(db *sql.DB, where string) iter.Seq2[*QrtzSchedulerStateRow, error] {
	return func(yield func(v *QrtzSchedulerStateRow, err error) bool) {
	    query := "SELECT INSTANCE_NAME,LAST_CHECKIN_TIME,CHECKIN_INTERVAL FROM QRTZ_SCHEDULER_STATE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QrtzSchedulerStateRow
	        err := rows.Scan(&r.InstanceName, &r.LastCheckinTime, &r.CheckinInterval)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QrtzSimpleTriggersRow struct represents rows of the QRTZ_SIMPLE_TRIGGERS table.
type QrtzSimpleTriggersRow struct {
    TriggerName	string
    TriggerGroup	string
    RepeatCount	int64
    RepeatInterval	int64
    TimesTriggered	int64
}

// IterateQrtzSimpleTriggers provide access to all rows of the QRTZ_SIMPLE_TRIGGERS matching given criteria.
func IterateQrtzSimpleTriggers(db *sql.DB, where string, callback func(v *QrtzSimpleTriggersRow) error) error {
    query := "SELECT TRIGGER_NAME,TRIGGER_GROUP,REPEAT_COUNT,REPEAT_INTERVAL,TIMES_TRIGGERED FROM QRTZ_SIMPLE_TRIGGERS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QrtzSimpleTriggersRow
        err := rows.Scan(&r.TriggerName, &r.TriggerGroup, &r.RepeatCount, &r.RepeatInterval, &r.TimesTriggered)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQrtzSimpleTriggers provide iterator to all rows of the QRTZ_SIMPLE_TRIGGERS matching given criteria.
func RangeQrtzSimpleTriggers(db *sql.DB, where string) iter.Seq2[*QrtzSimpleTriggersRow, error] {
	return func(yield func(v *QrtzSimpleTriggersRow, err error) bool) {
	    query := "SELECT TRIGGER_NAME,TRIGGER_GROUP,REPEAT_COUNT,REPEAT_INTERVAL,TIMES_TRIGGERED FROM QRTZ_SIMPLE_TRIGGERS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QrtzSimpleTriggersRow
	        err := rows.Scan(&r.TriggerName, &r.TriggerGroup, &r.RepeatCount, &r.RepeatInterval, &r.TimesTriggered)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QrtzTriggersRow struct represents rows of the QRTZ_TRIGGERS table.
type QrtzTriggersRow struct {
    TriggerName	string
    TriggerGroup	string
    JobName	string
    JobGroup	string
    IsVolatile	string
    Description	sql.NullString
    NextFireTime	sql.NullInt64
    PrevFireTime	sql.NullInt64
    Priority	sql.NullInt32
    TriggerState	string
    TriggerType	string
    StartTime	int64
    EndTime	sql.NullInt64
    CalendarName	sql.NullString
    MisfireInstr	sql.NullInt16
    JobData	[]byte
}

// IterateQrtzTriggers provide access to all rows of the QRTZ_TRIGGERS matching given criteria.
func IterateQrtzTriggers(db *sql.DB, where string, callback func(v *QrtzTriggersRow) error) error {
    query := "SELECT TRIGGER_NAME,TRIGGER_GROUP,JOB_NAME,JOB_GROUP,IS_VOLATILE,DESCRIPTION,NEXT_FIRE_TIME,PREV_FIRE_TIME,PRIORITY,TRIGGER_STATE,TRIGGER_TYPE,START_TIME,END_TIME,CALENDAR_NAME,MISFIRE_INSTR,JOB_DATA FROM QRTZ_TRIGGERS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QrtzTriggersRow
        err := rows.Scan(&r.TriggerName, &r.TriggerGroup, &r.JobName, &r.JobGroup, &r.IsVolatile, &r.Description, &r.NextFireTime, &r.PrevFireTime, &r.Priority, &r.TriggerState, &r.TriggerType, &r.StartTime, &r.EndTime, &r.CalendarName, &r.MisfireInstr, &r.JobData)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQrtzTriggers provide iterator to all rows of the QRTZ_TRIGGERS matching given criteria.
func RangeQrtzTriggers(db *sql.DB, where string) iter.Seq2[*QrtzTriggersRow, error] {
	return func(yield func(v *QrtzTriggersRow, err error) bool) {
	    query := "SELECT TRIGGER_NAME,TRIGGER_GROUP,JOB_NAME,JOB_GROUP,IS_VOLATILE,DESCRIPTION,NEXT_FIRE_TIME,PREV_FIRE_TIME,PRIORITY,TRIGGER_STATE,TRIGGER_TYPE,START_TIME,END_TIME,CALENDAR_NAME,MISFIRE_INSTR,JOB_DATA FROM QRTZ_TRIGGERS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QrtzTriggersRow
	        err := rows.Scan(&r.TriggerName, &r.TriggerGroup, &r.JobName, &r.JobGroup, &r.IsVolatile, &r.Description, &r.NextFireTime, &r.PrevFireTime, &r.Priority, &r.TriggerState, &r.TriggerType, &r.StartTime, &r.EndTime, &r.CalendarName, &r.MisfireInstr, &r.JobData)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QrtzTriggerListenersRow struct represents rows of the QRTZ_TRIGGER_LISTENERS table.
type QrtzTriggerListenersRow struct {
    TriggerName	string
    TriggerGroup	string
    TriggerListener	string
}

// IterateQrtzTriggerListeners provide access to all rows of the QRTZ_TRIGGER_LISTENERS matching given criteria.
func IterateQrtzTriggerListeners(db *sql.DB, where string, callback func(v *QrtzTriggerListenersRow) error) error {
    query := "SELECT TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_LISTENER FROM QRTZ_TRIGGER_LISTENERS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QrtzTriggerListenersRow
        err := rows.Scan(&r.TriggerName, &r.TriggerGroup, &r.TriggerListener)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQrtzTriggerListeners provide iterator to all rows of the QRTZ_TRIGGER_LISTENERS matching given criteria.
func RangeQrtzTriggerListeners(db *sql.DB, where string) iter.Seq2[*QrtzTriggerListenersRow, error] {
	return func(yield func(v *QrtzTriggerListenersRow, err error) bool) {
	    query := "SELECT TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_LISTENER FROM QRTZ_TRIGGER_LISTENERS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QrtzTriggerListenersRow
	        err := rows.Scan(&r.TriggerName, &r.TriggerGroup, &r.TriggerListener)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QuarantineActionRow struct represents rows of the QUARANTINE_ACTION table.
type QuarantineActionRow struct {
    ActionsetID	string
    NonHttpTrafficSetting	sql.NullInt32
    HttpTrafficSetting	sql.NullInt32
    RedirectUrl	sql.NullString
    DisplayFilterName	sql.NullInt32
    DisplayFilterDesc	sql.NullInt32
    DisplayCustomHtml	sql.NullInt32
    CustomHtml	sql.NullString
    Threshold	int
    ThresholdPeriod	int
    ExceptionThreshold	sql.NullByte
    ApplyAddrPairsGroupID	sql.NullString
    ExceptionAddrPairsGroupID	sql.NullString
    AllowedAddrPairsGroupID	sql.NullString
}

// IterateQuarantineAction provide access to all rows of the QUARANTINE_ACTION matching given criteria.
func IterateQuarantineAction(db *sql.DB, where string, callback func(v *QuarantineActionRow) error) error {
    query := "SELECT ACTIONSET_ID,NON_HTTP_TRAFFIC_SETTING,HTTP_TRAFFIC_SETTING,REDIRECT_URL,DISPLAY_FILTER_NAME,DISPLAY_FILTER_DESC,DISPLAY_CUSTOM_HTML,CUSTOM_HTML,THRESHOLD,THRESHOLD_PERIOD,EXCEPTION_THRESHOLD,APPLY_ADDR_PAIRS_GROUP_ID,EXCEPTION_ADDR_PAIRS_GROUP_ID,ALLOWED_ADDR_PAIRS_GROUP_ID FROM QUARANTINE_ACTION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QuarantineActionRow
        err := rows.Scan(&r.ActionsetID, &r.NonHttpTrafficSetting, &r.HttpTrafficSetting, &r.RedirectUrl, &r.DisplayFilterName, &r.DisplayFilterDesc, &r.DisplayCustomHtml, &r.CustomHtml, &r.Threshold, &r.ThresholdPeriod, &r.ExceptionThreshold, &r.ApplyAddrPairsGroupID, &r.ExceptionAddrPairsGroupID, &r.AllowedAddrPairsGroupID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQuarantineAction provide iterator to all rows of the QUARANTINE_ACTION matching given criteria.
func RangeQuarantineAction(db *sql.DB, where string) iter.Seq2[*QuarantineActionRow, error] {
	return func(yield func(v *QuarantineActionRow, err error) bool) {
	    query := "SELECT ACTIONSET_ID,NON_HTTP_TRAFFIC_SETTING,HTTP_TRAFFIC_SETTING,REDIRECT_URL,DISPLAY_FILTER_NAME,DISPLAY_FILTER_DESC,DISPLAY_CUSTOM_HTML,CUSTOM_HTML,THRESHOLD,THRESHOLD_PERIOD,EXCEPTION_THRESHOLD,APPLY_ADDR_PAIRS_GROUP_ID,EXCEPTION_ADDR_PAIRS_GROUP_ID,ALLOWED_ADDR_PAIRS_GROUP_ID FROM QUARANTINE_ACTION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QuarantineActionRow
	        err := rows.Scan(&r.ActionsetID, &r.NonHttpTrafficSetting, &r.HttpTrafficSetting, &r.RedirectUrl, &r.DisplayFilterName, &r.DisplayFilterDesc, &r.DisplayCustomHtml, &r.CustomHtml, &r.Threshold, &r.ThresholdPeriod, &r.ExceptionThreshold, &r.ApplyAddrPairsGroupID, &r.ExceptionAddrPairsGroupID, &r.AllowedAddrPairsGroupID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QuarantineAuthtypeRefRow struct represents rows of the QUARANTINE_AUTHTYPE_REF table.
type QuarantineAuthtypeRefRow struct {
    ID	uint16
    Name	sql.NullString
}

// IterateQuarantineAuthtypeRef provide access to all rows of the QUARANTINE_AUTHTYPE_REF matching given criteria.
func IterateQuarantineAuthtypeRef(db *sql.DB, where string, callback func(v *QuarantineAuthtypeRefRow) error) error {
    query := "SELECT ID,NAME FROM QUARANTINE_AUTHTYPE_REF"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QuarantineAuthtypeRefRow
        err := rows.Scan(&r.ID, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQuarantineAuthtypeRef provide iterator to all rows of the QUARANTINE_AUTHTYPE_REF matching given criteria.
func RangeQuarantineAuthtypeRef(db *sql.DB, where string) iter.Seq2[*QuarantineAuthtypeRefRow, error] {
	return func(yield func(v *QuarantineAuthtypeRefRow, err error) bool) {
	    query := "SELECT ID,NAME FROM QUARANTINE_AUTHTYPE_REF"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QuarantineAuthtypeRefRow
	        err := rows.Scan(&r.ID, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QuarantineEventRow struct represents rows of the QUARANTINE_EVENT table.
type QuarantineEventRow struct {
    ID	uint
    QuarantineHostID	uint
    Type	uint16
    QuarantineAuthtypeID	uint16
    Authname	sql.NullString
    IPAddr1	int64
    IPAddr2	int64
    MacAddr	uint64
    CreateTime	string
    ApplyTime	string
    Properties	sql.NullString
}

// IterateQuarantineEvent provide access to all rows of the QUARANTINE_EVENT matching given criteria.
func IterateQuarantineEvent(db *sql.DB, where string, callback func(v *QuarantineEventRow) error) error {
    query := "SELECT ID,QUARANTINE_HOST_ID,TYPE,QUARANTINE_AUTHTYPE_ID,AUTHNAME,IP_ADDR_1,IP_ADDR_2,MAC_ADDR,CREATE_TIME,APPLY_TIME,PROPERTIES FROM QUARANTINE_EVENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QuarantineEventRow
        err := rows.Scan(&r.ID, &r.QuarantineHostID, &r.Type, &r.QuarantineAuthtypeID, &r.Authname, &r.IPAddr1, &r.IPAddr2, &r.MacAddr, &r.CreateTime, &r.ApplyTime, &r.Properties)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQuarantineEvent provide iterator to all rows of the QUARANTINE_EVENT matching given criteria.
func RangeQuarantineEvent(db *sql.DB, where string) iter.Seq2[*QuarantineEventRow, error] {
	return func(yield func(v *QuarantineEventRow, err error) bool) {
	    query := "SELECT ID,QUARANTINE_HOST_ID,TYPE,QUARANTINE_AUTHTYPE_ID,AUTHNAME,IP_ADDR_1,IP_ADDR_2,MAC_ADDR,CREATE_TIME,APPLY_TIME,PROPERTIES FROM QUARANTINE_EVENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QuarantineEventRow
	        err := rows.Scan(&r.ID, &r.QuarantineHostID, &r.Type, &r.QuarantineAuthtypeID, &r.Authname, &r.IPAddr1, &r.IPAddr2, &r.MacAddr, &r.CreateTime, &r.ApplyTime, &r.Properties)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QuarantineEventlogRow struct represents rows of the QUARANTINE_EVENTLOG table.
type QuarantineEventlogRow struct {
    ID	uint64
    CreateTime	string
    Level	sql.NullString
    Message	sql.NullString
    IeeConfiguredActionName	sql.NullString
    QuarantineHostID	uint
    CauseEventID	uint
}

// IterateQuarantineEventlog provide access to all rows of the QUARANTINE_EVENTLOG matching given criteria.
func IterateQuarantineEventlog(db *sql.DB, where string, callback func(v *QuarantineEventlogRow) error) error {
    query := "SELECT ID,CREATE_TIME,LEVEL,MESSAGE,IEE_CONFIGURED_ACTION_NAME,QUARANTINE_HOST_ID,CAUSE_EVENT_ID FROM QUARANTINE_EVENTLOG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QuarantineEventlogRow
        err := rows.Scan(&r.ID, &r.CreateTime, &r.Level, &r.Message, &r.IeeConfiguredActionName, &r.QuarantineHostID, &r.CauseEventID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQuarantineEventlog provide iterator to all rows of the QUARANTINE_EVENTLOG matching given criteria.
func RangeQuarantineEventlog(db *sql.DB, where string) iter.Seq2[*QuarantineEventlogRow, error] {
	return func(yield func(v *QuarantineEventlogRow, err error) bool) {
	    query := "SELECT ID,CREATE_TIME,LEVEL,MESSAGE,IEE_CONFIGURED_ACTION_NAME,QUARANTINE_HOST_ID,CAUSE_EVENT_ID FROM QUARANTINE_EVENTLOG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QuarantineEventlogRow
	        err := rows.Scan(&r.ID, &r.CreateTime, &r.Level, &r.Message, &r.IeeConfiguredActionName, &r.QuarantineHostID, &r.CauseEventID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QuarantineExpectationRow struct represents rows of the QUARANTINE_EXPECTATION table.
type QuarantineExpectationRow struct {
    ID	uint
    InvokeOnStateID	sql.NullInt16
    InvokeOnTriggerType	sql.NullInt16
    HandlerConfiguredActionID	uint
    HandlerConfiguredActionName	sql.NullString
    HandlerActionCommand	sql.NullString
    Description	sql.NullString
    Priority	int64
    QuarantineHostID	uint
    CauseEventID	uint
    CreateTime	string
    Satisfied	sql.NullByte
    SatisfyEventID	sql.NullInt32
    SatisfyTime	string
    Properties	sql.NullString
}

// IterateQuarantineExpectation provide access to all rows of the QUARANTINE_EXPECTATION matching given criteria.
func IterateQuarantineExpectation(db *sql.DB, where string, callback func(v *QuarantineExpectationRow) error) error {
    query := "SELECT ID,INVOKE_ON_STATE_ID,INVOKE_ON_TRIGGER_TYPE,HANDLER_CONFIGURED_ACTION_ID,HANDLER_CONFIGURED_ACTION_NAME,HANDLER_ACTION_COMMAND,DESCRIPTION,PRIORITY,QUARANTINE_HOST_ID,CAUSE_EVENT_ID,CREATE_TIME,SATISFIED,SATISFY_EVENT_ID,SATISFY_TIME,PROPERTIES FROM QUARANTINE_EXPECTATION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QuarantineExpectationRow
        err := rows.Scan(&r.ID, &r.InvokeOnStateID, &r.InvokeOnTriggerType, &r.HandlerConfiguredActionID, &r.HandlerConfiguredActionName, &r.HandlerActionCommand, &r.Description, &r.Priority, &r.QuarantineHostID, &r.CauseEventID, &r.CreateTime, &r.Satisfied, &r.SatisfyEventID, &r.SatisfyTime, &r.Properties)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQuarantineExpectation provide iterator to all rows of the QUARANTINE_EXPECTATION matching given criteria.
func RangeQuarantineExpectation(db *sql.DB, where string) iter.Seq2[*QuarantineExpectationRow, error] {
	return func(yield func(v *QuarantineExpectationRow, err error) bool) {
	    query := "SELECT ID,INVOKE_ON_STATE_ID,INVOKE_ON_TRIGGER_TYPE,HANDLER_CONFIGURED_ACTION_ID,HANDLER_CONFIGURED_ACTION_NAME,HANDLER_ACTION_COMMAND,DESCRIPTION,PRIORITY,QUARANTINE_HOST_ID,CAUSE_EVENT_ID,CREATE_TIME,SATISFIED,SATISFY_EVENT_ID,SATISFY_TIME,PROPERTIES FROM QUARANTINE_EXPECTATION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QuarantineExpectationRow
	        err := rows.Scan(&r.ID, &r.InvokeOnStateID, &r.InvokeOnTriggerType, &r.HandlerConfiguredActionID, &r.HandlerConfiguredActionName, &r.HandlerActionCommand, &r.Description, &r.Priority, &r.QuarantineHostID, &r.CauseEventID, &r.CreateTime, &r.Satisfied, &r.SatisfyEventID, &r.SatisfyTime, &r.Properties)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QuarantineHostRow struct represents rows of the QUARANTINE_HOST table.
type QuarantineHostRow struct {
    ID	uint
    IPAddr1	int64
    IPAddr2	int64
    MacAddr	uint64
    IeeCompositeActionID	sql.NullInt32
    QuarantineHostStateID	uint16
    Finalized	sql.NullByte
    QuarantineAuthtypeID	uint16
    Authname	sql.NullString
    CreateTime	string
    UpdateTime	string
    Properties	sql.NullString
}

// IterateQuarantineHost provide access to all rows of the QUARANTINE_HOST matching given criteria.
func IterateQuarantineHost(db *sql.DB, where string, callback func(v *QuarantineHostRow) error) error {
    query := "SELECT ID,IP_ADDR_1,IP_ADDR_2,MAC_ADDR,IEE_COMPOSITE_ACTION_ID,QUARANTINE_HOST_STATE_ID,FINALIZED,QUARANTINE_AUTHTYPE_ID,AUTHNAME,CREATE_TIME,UPDATE_TIME,PROPERTIES FROM QUARANTINE_HOST"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QuarantineHostRow
        err := rows.Scan(&r.ID, &r.IPAddr1, &r.IPAddr2, &r.MacAddr, &r.IeeCompositeActionID, &r.QuarantineHostStateID, &r.Finalized, &r.QuarantineAuthtypeID, &r.Authname, &r.CreateTime, &r.UpdateTime, &r.Properties)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQuarantineHost provide iterator to all rows of the QUARANTINE_HOST matching given criteria.
func RangeQuarantineHost(db *sql.DB, where string) iter.Seq2[*QuarantineHostRow, error] {
	return func(yield func(v *QuarantineHostRow, err error) bool) {
	    query := "SELECT ID,IP_ADDR_1,IP_ADDR_2,MAC_ADDR,IEE_COMPOSITE_ACTION_ID,QUARANTINE_HOST_STATE_ID,FINALIZED,QUARANTINE_AUTHTYPE_ID,AUTHNAME,CREATE_TIME,UPDATE_TIME,PROPERTIES FROM QUARANTINE_HOST"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QuarantineHostRow
	        err := rows.Scan(&r.ID, &r.IPAddr1, &r.IPAddr2, &r.MacAddr, &r.IeeCompositeActionID, &r.QuarantineHostStateID, &r.Finalized, &r.QuarantineAuthtypeID, &r.Authname, &r.CreateTime, &r.UpdateTime, &r.Properties)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QuarantineHostStateRefRow struct represents rows of the QUARANTINE_HOST_STATE_REF table.
type QuarantineHostStateRefRow struct {
    ID	uint16
    StateName	sql.NullString
    FinalState	sql.NullBool
}

// IterateQuarantineHostStateRef provide access to all rows of the QUARANTINE_HOST_STATE_REF matching given criteria.
func IterateQuarantineHostStateRef(db *sql.DB, where string, callback func(v *QuarantineHostStateRefRow) error) error {
    query := "SELECT ID,STATE_NAME,FINAL_STATE FROM QUARANTINE_HOST_STATE_REF"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QuarantineHostStateRefRow
        err := rows.Scan(&r.ID, &r.StateName, &r.FinalState)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQuarantineHostStateRef provide iterator to all rows of the QUARANTINE_HOST_STATE_REF matching given criteria.
func RangeQuarantineHostStateRef(db *sql.DB, where string) iter.Seq2[*QuarantineHostStateRefRow, error] {
	return func(yield func(v *QuarantineHostStateRefRow, err error) bool) {
	    query := "SELECT ID,STATE_NAME,FINAL_STATE FROM QUARANTINE_HOST_STATE_REF"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QuarantineHostStateRefRow
	        err := rows.Scan(&r.ID, &r.StateName, &r.FinalState)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QuarantineRepCountRow struct represents rows of the QUARANTINE_REP_COUNT table.
type QuarantineRepCountRow struct {
    ID	uint
    ActionID	uint
    Count	uint
}

// IterateQuarantineRepCount provide access to all rows of the QUARANTINE_REP_COUNT matching given criteria.
func IterateQuarantineRepCount(db *sql.DB, where string, callback func(v *QuarantineRepCountRow) error) error {
    query := "SELECT ID,ACTION_ID,COUNT FROM QUARANTINE_REP_COUNT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QuarantineRepCountRow
        err := rows.Scan(&r.ID, &r.ActionID, &r.Count)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQuarantineRepCount provide iterator to all rows of the QUARANTINE_REP_COUNT matching given criteria.
func RangeQuarantineRepCount(db *sql.DB, where string) iter.Seq2[*QuarantineRepCountRow, error] {
	return func(yield func(v *QuarantineRepCountRow, err error) bool) {
	    query := "SELECT ID,ACTION_ID,COUNT FROM QUARANTINE_REP_COUNT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QuarantineRepCountRow
	        err := rows.Scan(&r.ID, &r.ActionID, &r.Count)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QuarantineStateTimerRow struct represents rows of the QUARANTINE_STATE_TIMER table.
type QuarantineStateTimerRow struct {
    HostID	uint
    Name	string
    CreatorStateID	sql.NullInt16
    ResetCount	sql.NullInt32
    InitialValueMillis	sql.NullInt64
    ExpireTime	sql.NullTime
    Stopped	sql.NullBool
    StoppedRemainingMillis	sql.NullInt64
}

// IterateQuarantineStateTimer provide access to all rows of the QUARANTINE_STATE_TIMER matching given criteria.
func IterateQuarantineStateTimer(db *sql.DB, where string, callback func(v *QuarantineStateTimerRow) error) error {
    query := "SELECT HOST_ID,NAME,CREATOR_STATE_ID,RESET_COUNT,INITIAL_VALUE_MILLIS,EXPIRE_TIME,STOPPED,STOPPED_REMAINING_MILLIS FROM QUARANTINE_STATE_TIMER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QuarantineStateTimerRow
        err := rows.Scan(&r.HostID, &r.Name, &r.CreatorStateID, &r.ResetCount, &r.InitialValueMillis, &r.ExpireTime, &r.Stopped, &r.StoppedRemainingMillis)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQuarantineStateTimer provide iterator to all rows of the QUARANTINE_STATE_TIMER matching given criteria.
func RangeQuarantineStateTimer(db *sql.DB, where string) iter.Seq2[*QuarantineStateTimerRow, error] {
	return func(yield func(v *QuarantineStateTimerRow, err error) bool) {
	    query := "SELECT HOST_ID,NAME,CREATOR_STATE_ID,RESET_COUNT,INITIAL_VALUE_MILLIS,EXPIRE_TIME,STOPPED,STOPPED_REMAINING_MILLIS FROM QUARANTINE_STATE_TIMER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QuarantineStateTimerRow
	        err := rows.Scan(&r.HostID, &r.Name, &r.CreatorStateID, &r.ResetCount, &r.InitialValueMillis, &r.ExpireTime, &r.Stopped, &r.StoppedRemainingMillis)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// QuerySpecRow struct represents rows of the QUERY_SPEC table.
type QuerySpecRow struct {
    ID	uint
    Name	sql.NullString
    QueryData	sql.NullString
    EditorType	sql.NullInt32
    ResultRowLimit	sql.NullInt32
}

// IterateQuerySpec provide access to all rows of the QUERY_SPEC matching given criteria.
func IterateQuerySpec(db *sql.DB, where string, callback func(v *QuerySpecRow) error) error {
    query := "SELECT ID,NAME,QUERY_DATA,EDITOR_TYPE,RESULT_ROW_LIMIT FROM QUERY_SPEC"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r QuerySpecRow
        err := rows.Scan(&r.ID, &r.Name, &r.QueryData, &r.EditorType, &r.ResultRowLimit)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeQuerySpec provide iterator to all rows of the QUERY_SPEC matching given criteria.
func RangeQuerySpec(db *sql.DB, where string) iter.Seq2[*QuerySpecRow, error] {
	return func(yield func(v *QuerySpecRow, err error) bool) {
	    query := "SELECT ID,NAME,QUERY_DATA,EDITOR_TYPE,RESULT_ROW_LIMIT FROM QUERY_SPEC"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r QuerySpecRow
	        err := rows.Scan(&r.ID, &r.Name, &r.QueryData, &r.EditorType, &r.ResultRowLimit)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RadiusProxyTargetRow struct represents rows of the RADIUS_PROXY_TARGET table.
type RadiusProxyTargetRow struct {
    ID	int
    RadiusServiceConfigID	int
    Priority	int8
    Address	sql.NullString
    AuthPort	sql.NullInt32
    Secret	sql.NullString
}

// IterateRadiusProxyTarget provide access to all rows of the RADIUS_PROXY_TARGET matching given criteria.
func IterateRadiusProxyTarget(db *sql.DB, where string, callback func(v *RadiusProxyTargetRow) error) error {
    query := "SELECT ID,RADIUS_SERVICE_CONFIG_ID,PRIORITY,ADDRESS,AUTH_PORT,SECRET FROM RADIUS_PROXY_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RadiusProxyTargetRow
        err := rows.Scan(&r.ID, &r.RadiusServiceConfigID, &r.Priority, &r.Address, &r.AuthPort, &r.Secret)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRadiusProxyTarget provide iterator to all rows of the RADIUS_PROXY_TARGET matching given criteria.
func RangeRadiusProxyTarget(db *sql.DB, where string) iter.Seq2[*RadiusProxyTargetRow, error] {
	return func(yield func(v *RadiusProxyTargetRow, err error) bool) {
	    query := "SELECT ID,RADIUS_SERVICE_CONFIG_ID,PRIORITY,ADDRESS,AUTH_PORT,SECRET FROM RADIUS_PROXY_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RadiusProxyTargetRow
	        err := rows.Scan(&r.ID, &r.RadiusServiceConfigID, &r.Priority, &r.Address, &r.AuthPort, &r.Secret)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RadiusServerConfigRow struct represents rows of the RADIUS_SERVER_CONFIG table.
type RadiusServerConfigRow struct {
    ID	int
    AuthenticationMode	sql.NullString
    AuthorizationMode	sql.NullString
    FallbackMode	sql.NullString
    GroupMappingAttribute	sql.NullString
    FallbackGroup	sql.NullInt32
}

// IterateRadiusServerConfig provide access to all rows of the RADIUS_SERVER_CONFIG matching given criteria.
func IterateRadiusServerConfig(db *sql.DB, where string, callback func(v *RadiusServerConfigRow) error) error {
    query := "SELECT ID,AUTHENTICATION_MODE,AUTHORIZATION_MODE,FALLBACK_MODE,GROUP_MAPPING_ATTRIBUTE,FALLBACK_GROUP FROM RADIUS_SERVER_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RadiusServerConfigRow
        err := rows.Scan(&r.ID, &r.AuthenticationMode, &r.AuthorizationMode, &r.FallbackMode, &r.GroupMappingAttribute, &r.FallbackGroup)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRadiusServerConfig provide iterator to all rows of the RADIUS_SERVER_CONFIG matching given criteria.
func RangeRadiusServerConfig(db *sql.DB, where string) iter.Seq2[*RadiusServerConfigRow, error] {
	return func(yield func(v *RadiusServerConfigRow, err error) bool) {
	    query := "SELECT ID,AUTHENTICATION_MODE,AUTHORIZATION_MODE,FALLBACK_MODE,GROUP_MAPPING_ATTRIBUTE,FALLBACK_GROUP FROM RADIUS_SERVER_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RadiusServerConfigRow
	        err := rows.Scan(&r.ID, &r.AuthenticationMode, &r.AuthorizationMode, &r.FallbackMode, &r.GroupMappingAttribute, &r.FallbackGroup)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RadiusServiceConfigRow struct represents rows of the RADIUS_SERVICE_CONFIG table.
type RadiusServiceConfigRow struct {
    ID	int
    Enabled	sql.NullByte
    AuthPort	sql.NullInt32
    Realm	sql.NullString
    Secret	sql.NullString
    FallbackResponse	sql.NullByte
    FallbackVLAN	sql.NullString
}

// IterateRadiusServiceConfig provide access to all rows of the RADIUS_SERVICE_CONFIG matching given criteria.
func IterateRadiusServiceConfig(db *sql.DB, where string, callback func(v *RadiusServiceConfigRow) error) error {
    query := "SELECT ID,ENABLED,AUTH_PORT,REALM,SECRET,FALLBACK_RESPONSE,FALLBACK_VLAN FROM RADIUS_SERVICE_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RadiusServiceConfigRow
        err := rows.Scan(&r.ID, &r.Enabled, &r.AuthPort, &r.Realm, &r.Secret, &r.FallbackResponse, &r.FallbackVLAN)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRadiusServiceConfig provide iterator to all rows of the RADIUS_SERVICE_CONFIG matching given criteria.
func RangeRadiusServiceConfig(db *sql.DB, where string) iter.Seq2[*RadiusServiceConfigRow, error] {
	return func(yield func(v *RadiusServiceConfigRow, err error) bool) {
	    query := "SELECT ID,ENABLED,AUTH_PORT,REALM,SECRET,FALLBACK_RESPONSE,FALLBACK_VLAN FROM RADIUS_SERVICE_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RadiusServiceConfigRow
	        err := rows.Scan(&r.ID, &r.Enabled, &r.AuthPort, &r.Realm, &r.Secret, &r.FallbackResponse, &r.FallbackVLAN)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RemoteSyslogRow struct represents rows of the REMOTE_SYSLOG table.
type RemoteSyslogRow struct {
    ID	uint
    Enabled	int8
    IPAddress	string
    Port	int
    Protocol	uint16
    Encrypt	int8
    Facility	int
    Severity	sql.NullInt32
    IncludeTimestamp	int8
    IncludeHostname	int8
    Delimiter	string
    LastIdx	uint64
    StartFromCurrent	sql.NullByte
    EventQueryID	sql.NullInt32
    SyslogFormatID	uint
}

// IterateRemoteSyslog provide access to all rows of the REMOTE_SYSLOG matching given criteria.
func IterateRemoteSyslog(db *sql.DB, where string, callback func(v *RemoteSyslogRow) error) error {
    query := "SELECT ID,ENABLED,IP_ADDRESS,PORT,PROTOCOL,ENCRYPT,FACILITY,SEVERITY,INCLUDE_TIMESTAMP,INCLUDE_HOSTNAME,DELIMITER,LAST_IDX,START_FROM_CURRENT,EVENT_QUERY_ID,SYSLOG_FORMAT_ID FROM REMOTE_SYSLOG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RemoteSyslogRow
        err := rows.Scan(&r.ID, &r.Enabled, &r.IPAddress, &r.Port, &r.Protocol, &r.Encrypt, &r.Facility, &r.Severity, &r.IncludeTimestamp, &r.IncludeHostname, &r.Delimiter, &r.LastIdx, &r.StartFromCurrent, &r.EventQueryID, &r.SyslogFormatID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRemoteSyslog provide iterator to all rows of the REMOTE_SYSLOG matching given criteria.
func RangeRemoteSyslog(db *sql.DB, where string) iter.Seq2[*RemoteSyslogRow, error] {
	return func(yield func(v *RemoteSyslogRow, err error) bool) {
	    query := "SELECT ID,ENABLED,IP_ADDRESS,PORT,PROTOCOL,ENCRYPT,FACILITY,SEVERITY,INCLUDE_TIMESTAMP,INCLUDE_HOSTNAME,DELIMITER,LAST_IDX,START_FROM_CURRENT,EVENT_QUERY_ID,SYSLOG_FORMAT_ID FROM REMOTE_SYSLOG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RemoteSyslogRow
	        err := rows.Scan(&r.ID, &r.Enabled, &r.IPAddress, &r.Port, &r.Protocol, &r.Encrypt, &r.Facility, &r.Severity, &r.IncludeTimestamp, &r.IncludeHostname, &r.Delimiter, &r.LastIdx, &r.StartFromCurrent, &r.EventQueryID, &r.SyslogFormatID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RemoteTacacsServerRow struct represents rows of the REMOTE_TACACS_SERVER table.
type RemoteTacacsServerRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    ServerOrder	uint
    ServerTypeIpaddress	int8
    ServerNamedObjID	sql.NullInt32
    ServerHostname	sql.NullString
    Port	uint
    AuthMethod	string
    SharedSecret	sql.NullString
    Timeout	uint
    Retries	uint
    Version	uint
}

// IterateRemoteTacacsServer provide access to all rows of the REMOTE_TACACS_SERVER matching given criteria.
func IterateRemoteTacacsServer(db *sql.DB, where string, callback func(v *RemoteTacacsServerRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,SERVER_ORDER,SERVER_TYPE_IPADDRESS,SERVER_NAMED_OBJ_ID,SERVER_HOSTNAME,PORT,AUTH_METHOD,SHARED_SECRET,TIMEOUT,RETRIES,VERSION FROM REMOTE_TACACS_SERVER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RemoteTacacsServerRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.ServerOrder, &r.ServerTypeIpaddress, &r.ServerNamedObjID, &r.ServerHostname, &r.Port, &r.AuthMethod, &r.SharedSecret, &r.Timeout, &r.Retries, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRemoteTacacsServer provide iterator to all rows of the REMOTE_TACACS_SERVER matching given criteria.
func RangeRemoteTacacsServer(db *sql.DB, where string) iter.Seq2[*RemoteTacacsServerRow, error] {
	return func(yield func(v *RemoteTacacsServerRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,SERVER_ORDER,SERVER_TYPE_IPADDRESS,SERVER_NAMED_OBJ_ID,SERVER_HOSTNAME,PORT,AUTH_METHOD,SHARED_SECRET,TIMEOUT,RETRIES,VERSION FROM REMOTE_TACACS_SERVER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RemoteTacacsServerRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.ServerOrder, &r.ServerTypeIpaddress, &r.ServerNamedObjID, &r.ServerHostname, &r.Port, &r.AuthMethod, &r.SharedSecret, &r.Timeout, &r.Retries, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ReputationActivityQueueRow struct represents rows of the REPUTATION_ACTIVITY_QUEUE table.
type ReputationActivityQueueRow struct {
    ID	string
    Category	string
    Operation	string
    Header	[]byte
    Payload	[]byte
    Delta	[]byte
    SessionID	int
    CreatedTime	int64
}

// IterateReputationActivityQueue provide access to all rows of the REPUTATION_ACTIVITY_QUEUE matching given criteria.
func IterateReputationActivityQueue(db *sql.DB, where string, callback func(v *ReputationActivityQueueRow) error) error {
    query := "SELECT ID,CATEGORY,OPERATION,HEADER,PAYLOAD,DELTA,SESSION_ID,CREATED_TIME FROM REPUTATION_ACTIVITY_QUEUE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ReputationActivityQueueRow
        err := rows.Scan(&r.ID, &r.Category, &r.Operation, &r.Header, &r.Payload, &r.Delta, &r.SessionID, &r.CreatedTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeReputationActivityQueue provide iterator to all rows of the REPUTATION_ACTIVITY_QUEUE matching given criteria.
func RangeReputationActivityQueue(db *sql.DB, where string) iter.Seq2[*ReputationActivityQueueRow, error] {
	return func(yield func(v *ReputationActivityQueueRow, err error) bool) {
	    query := "SELECT ID,CATEGORY,OPERATION,HEADER,PAYLOAD,DELTA,SESSION_ID,CREATED_TIME FROM REPUTATION_ACTIVITY_QUEUE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ReputationActivityQueueRow
	        err := rows.Scan(&r.ID, &r.Category, &r.Operation, &r.Header, &r.Payload, &r.Delta, &r.SessionID, &r.CreatedTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDbEntryDataRow struct represents rows of the REP_DB_ENTRY_DATA table.
type RepDbEntryDataRow struct {
    ID	int64
    AddedTs	int64
    Url	string
    EntryHash	sql.NullString
    RepTagClassUuid	string
    Untagged	int8
    BoolValue	sql.NullByte
    DateValue	sql.NullTime
    MultipleValues	sql.NullByte
    ValidValue	sql.NullString
    ListValueID	int
    NumericValue	sql.NullInt32
    TextValue	sql.NullString
}

// IterateRepDbEntryData provide access to all rows of the REP_DB_ENTRY_DATA matching given criteria.
func IterateRepDbEntryData(db *sql.DB, where string, callback func(v *RepDbEntryDataRow) error) error {
    query := "SELECT ID,ADDED_TS,URL,entry_hash,REP_TAG_CLASS_UUID,untagged,BOOL_VALUE,DATE_VALUE,multiple_values,valid_value,LIST_VALUE_ID,NUMERIC_VALUE,TEXT_VALUE FROM REP_DB_ENTRY_DATA"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDbEntryDataRow
        err := rows.Scan(&r.ID, &r.AddedTs, &r.Url, &r.EntryHash, &r.RepTagClassUuid, &r.Untagged, &r.BoolValue, &r.DateValue, &r.MultipleValues, &r.ValidValue, &r.ListValueID, &r.NumericValue, &r.TextValue)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDbEntryData provide iterator to all rows of the REP_DB_ENTRY_DATA matching given criteria.
func RangeRepDbEntryData(db *sql.DB, where string) iter.Seq2[*RepDbEntryDataRow, error] {
	return func(yield func(v *RepDbEntryDataRow, err error) bool) {
	    query := "SELECT ID,ADDED_TS,URL,entry_hash,REP_TAG_CLASS_UUID,untagged,BOOL_VALUE,DATE_VALUE,multiple_values,valid_value,LIST_VALUE_ID,NUMERIC_VALUE,TEXT_VALUE FROM REP_DB_ENTRY_DATA"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDbEntryDataRow
	        err := rows.Scan(&r.ID, &r.AddedTs, &r.Url, &r.EntryHash, &r.RepTagClassUuid, &r.Untagged, &r.BoolValue, &r.DateValue, &r.MultipleValues, &r.ValidValue, &r.ListValueID, &r.NumericValue, &r.TextValue)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDbFileHashRow struct represents rows of the REP_DB_FILE_HASH table.
type RepDbFileHashRow struct {
    ID	int64
    AddedTs	int64
    Hash	string
    EntryHash	sql.NullString
    RepTagClassUuid	string
    Untagged	int8
    BoolValue	sql.NullByte
    DateValue	sql.NullTime
    MultipleValues	sql.NullByte
    ValidValue	sql.NullString
    ListValueID	int
    NumericValue	sql.NullInt32
    TextValue	sql.NullString
}

// IterateRepDbFileHash provide access to all rows of the REP_DB_FILE_HASH matching given criteria.
func IterateRepDbFileHash(db *sql.DB, where string, callback func(v *RepDbFileHashRow) error) error {
    query := "SELECT ID,ADDED_TS,HASH,entry_hash,REP_TAG_CLASS_UUID,untagged,BOOL_VALUE,DATE_VALUE,multiple_values,valid_value,LIST_VALUE_ID,NUMERIC_VALUE,TEXT_VALUE FROM REP_DB_FILE_HASH"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDbFileHashRow
        err := rows.Scan(&r.ID, &r.AddedTs, &r.Hash, &r.EntryHash, &r.RepTagClassUuid, &r.Untagged, &r.BoolValue, &r.DateValue, &r.MultipleValues, &r.ValidValue, &r.ListValueID, &r.NumericValue, &r.TextValue)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDbFileHash provide iterator to all rows of the REP_DB_FILE_HASH matching given criteria.
func RangeRepDbFileHash(db *sql.DB, where string) iter.Seq2[*RepDbFileHashRow, error] {
	return func(yield func(v *RepDbFileHashRow, err error) bool) {
	    query := "SELECT ID,ADDED_TS,HASH,entry_hash,REP_TAG_CLASS_UUID,untagged,BOOL_VALUE,DATE_VALUE,multiple_values,valid_value,LIST_VALUE_ID,NUMERIC_VALUE,TEXT_VALUE FROM REP_DB_FILE_HASH"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDbFileHashRow
	        err := rows.Scan(&r.ID, &r.AddedTs, &r.Hash, &r.EntryHash, &r.RepTagClassUuid, &r.Untagged, &r.BoolValue, &r.DateValue, &r.MultipleValues, &r.ValidValue, &r.ListValueID, &r.NumericValue, &r.TextValue)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDbIncomingEntriesRemDupsRow struct represents rows of the REP_DB_INCOMING_ENTRIES_REM_DUPS table.
type RepDbIncomingEntriesRemDupsRow struct {
    ID	int64
    EntryHash	string
    Duplicate	int8
}

// IterateRepDbIncomingEntriesRemDups provide access to all rows of the REP_DB_INCOMING_ENTRIES_REM_DUPS matching given criteria.
func IterateRepDbIncomingEntriesRemDups(db *sql.DB, where string, callback func(v *RepDbIncomingEntriesRemDupsRow) error) error {
    query := "SELECT ID,entry_hash,duplicate FROM REP_DB_INCOMING_ENTRIES_REM_DUPS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDbIncomingEntriesRemDupsRow
        err := rows.Scan(&r.ID, &r.EntryHash, &r.Duplicate)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDbIncomingEntriesRemDups provide iterator to all rows of the REP_DB_INCOMING_ENTRIES_REM_DUPS matching given criteria.
func RangeRepDbIncomingEntriesRemDups(db *sql.DB, where string) iter.Seq2[*RepDbIncomingEntriesRemDupsRow, error] {
	return func(yield func(v *RepDbIncomingEntriesRemDupsRow, err error) bool) {
	    query := "SELECT ID,entry_hash,duplicate FROM REP_DB_INCOMING_ENTRIES_REM_DUPS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDbIncomingEntriesRemDupsRow
	        err := rows.Scan(&r.ID, &r.EntryHash, &r.Duplicate)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDbIncomingEntryAddRow struct represents rows of the REP_DB_INCOMING_ENTRY_ADD table.
type RepDbIncomingEntryAddRow struct {
    ID	sql.NullInt64
    AddedTs	int64
    Url	string
    RepTagClassUuid	string
    Untagged	int8
    BoolValue	sql.NullByte
    DateValue	sql.NullTime
    MultipleValues	sql.NullByte
    ValidValue	sql.NullString
    ListValueID	int
    NumericValue	sql.NullInt32
    TextValue	sql.NullString
    EntryHash	sql.NullString
}

// IterateRepDbIncomingEntryAdd provide access to all rows of the REP_DB_INCOMING_ENTRY_ADD matching given criteria.
func IterateRepDbIncomingEntryAdd(db *sql.DB, where string, callback func(v *RepDbIncomingEntryAddRow) error) error {
    query := "SELECT ID,ADDED_TS,URL,REP_TAG_CLASS_UUID,untagged,BOOL_VALUE,DATE_VALUE,multiple_values,valid_value,LIST_VALUE_ID,NUMERIC_VALUE,TEXT_VALUE,entry_hash FROM REP_DB_INCOMING_ENTRY_ADD"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDbIncomingEntryAddRow
        err := rows.Scan(&r.ID, &r.AddedTs, &r.Url, &r.RepTagClassUuid, &r.Untagged, &r.BoolValue, &r.DateValue, &r.MultipleValues, &r.ValidValue, &r.ListValueID, &r.NumericValue, &r.TextValue, &r.EntryHash)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDbIncomingEntryAdd provide iterator to all rows of the REP_DB_INCOMING_ENTRY_ADD matching given criteria.
func RangeRepDbIncomingEntryAdd(db *sql.DB, where string) iter.Seq2[*RepDbIncomingEntryAddRow, error] {
	return func(yield func(v *RepDbIncomingEntryAddRow, err error) bool) {
	    query := "SELECT ID,ADDED_TS,URL,REP_TAG_CLASS_UUID,untagged,BOOL_VALUE,DATE_VALUE,multiple_values,valid_value,LIST_VALUE_ID,NUMERIC_VALUE,TEXT_VALUE,entry_hash FROM REP_DB_INCOMING_ENTRY_ADD"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDbIncomingEntryAddRow
	        err := rows.Scan(&r.ID, &r.AddedTs, &r.Url, &r.RepTagClassUuid, &r.Untagged, &r.BoolValue, &r.DateValue, &r.MultipleValues, &r.ValidValue, &r.ListValueID, &r.NumericValue, &r.TextValue, &r.EntryHash)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDbIncomingEntryDeleteRow struct represents rows of the REP_DB_INCOMING_ENTRY_DELETE table.
type RepDbIncomingEntryDeleteRow struct {
    Url	string
    EntryHash	sql.NullString
}

// IterateRepDbIncomingEntryDelete provide access to all rows of the REP_DB_INCOMING_ENTRY_DELETE matching given criteria.
func IterateRepDbIncomingEntryDelete(db *sql.DB, where string, callback func(v *RepDbIncomingEntryDeleteRow) error) error {
    query := "SELECT URL,entry_hash FROM REP_DB_INCOMING_ENTRY_DELETE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDbIncomingEntryDeleteRow
        err := rows.Scan(&r.Url, &r.EntryHash)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDbIncomingEntryDelete provide iterator to all rows of the REP_DB_INCOMING_ENTRY_DELETE matching given criteria.
func RangeRepDbIncomingEntryDelete(db *sql.DB, where string) iter.Seq2[*RepDbIncomingEntryDeleteRow, error] {
	return func(yield func(v *RepDbIncomingEntryDeleteRow, err error) bool) {
	    query := "SELECT URL,entry_hash FROM REP_DB_INCOMING_ENTRY_DELETE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDbIncomingEntryDeleteRow
	        err := rows.Scan(&r.Url, &r.EntryHash)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDbIncomingEntryUpdateRow struct represents rows of the REP_DB_INCOMING_ENTRY_UPDATE table.
type RepDbIncomingEntryUpdateRow struct {
    ID	sql.NullInt64
    AddedTs	sql.NullInt64
    Url	sql.NullString
    RepTagClassUuid	string
    Untagged	int8
    BoolValue	sql.NullByte
    DateValue	sql.NullTime
    MultipleValues	sql.NullByte
    ValidValue	sql.NullString
    ListValueID	int
    NumericValue	sql.NullInt32
    TextValue	sql.NullString
}

// IterateRepDbIncomingEntryUpdate provide access to all rows of the REP_DB_INCOMING_ENTRY_UPDATE matching given criteria.
func IterateRepDbIncomingEntryUpdate(db *sql.DB, where string, callback func(v *RepDbIncomingEntryUpdateRow) error) error {
    query := "SELECT ID,ADDED_TS,URL,REP_TAG_CLASS_UUID,untagged,BOOL_VALUE,DATE_VALUE,multiple_values,valid_value,LIST_VALUE_ID,NUMERIC_VALUE,TEXT_VALUE FROM REP_DB_INCOMING_ENTRY_UPDATE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDbIncomingEntryUpdateRow
        err := rows.Scan(&r.ID, &r.AddedTs, &r.Url, &r.RepTagClassUuid, &r.Untagged, &r.BoolValue, &r.DateValue, &r.MultipleValues, &r.ValidValue, &r.ListValueID, &r.NumericValue, &r.TextValue)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDbIncomingEntryUpdate provide iterator to all rows of the REP_DB_INCOMING_ENTRY_UPDATE matching given criteria.
func RangeRepDbIncomingEntryUpdate(db *sql.DB, where string) iter.Seq2[*RepDbIncomingEntryUpdateRow, error] {
	return func(yield func(v *RepDbIncomingEntryUpdateRow, err error) bool) {
	    query := "SELECT ID,ADDED_TS,URL,REP_TAG_CLASS_UUID,untagged,BOOL_VALUE,DATE_VALUE,multiple_values,valid_value,LIST_VALUE_ID,NUMERIC_VALUE,TEXT_VALUE FROM REP_DB_INCOMING_ENTRY_UPDATE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDbIncomingEntryUpdateRow
	        err := rows.Scan(&r.ID, &r.AddedTs, &r.Url, &r.RepTagClassUuid, &r.Untagged, &r.BoolValue, &r.DateValue, &r.MultipleValues, &r.ValidValue, &r.ListValueID, &r.NumericValue, &r.TextValue)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDbIncomingFileHashEntryAddRow struct represents rows of the REP_DB_INCOMING_FILE_HASH_ENTRY_ADD table.
type RepDbIncomingFileHashEntryAddRow struct {
    ID	sql.NullInt64
    AddedTs	int64
    Hash	string
    RepTagClassUuid	string
    Untagged	int8
    BoolValue	sql.NullByte
    DateValue	sql.NullTime
    MultipleValues	sql.NullByte
    ValidValue	sql.NullString
    ListValueID	int
    NumericValue	sql.NullInt32
    TextValue	sql.NullString
    EntryHash	sql.NullString
}

// IterateRepDbIncomingFileHashEntryAdd provide access to all rows of the REP_DB_INCOMING_FILE_HASH_ENTRY_ADD matching given criteria.
func IterateRepDbIncomingFileHashEntryAdd(db *sql.DB, where string, callback func(v *RepDbIncomingFileHashEntryAddRow) error) error {
    query := "SELECT ID,ADDED_TS,HASH,REP_TAG_CLASS_UUID,untagged,BOOL_VALUE,DATE_VALUE,multiple_values,valid_value,LIST_VALUE_ID,NUMERIC_VALUE,TEXT_VALUE,entry_hash FROM REP_DB_INCOMING_FILE_HASH_ENTRY_ADD"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDbIncomingFileHashEntryAddRow
        err := rows.Scan(&r.ID, &r.AddedTs, &r.Hash, &r.RepTagClassUuid, &r.Untagged, &r.BoolValue, &r.DateValue, &r.MultipleValues, &r.ValidValue, &r.ListValueID, &r.NumericValue, &r.TextValue, &r.EntryHash)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDbIncomingFileHashEntryAdd provide iterator to all rows of the REP_DB_INCOMING_FILE_HASH_ENTRY_ADD matching given criteria.
func RangeRepDbIncomingFileHashEntryAdd(db *sql.DB, where string) iter.Seq2[*RepDbIncomingFileHashEntryAddRow, error] {
	return func(yield func(v *RepDbIncomingFileHashEntryAddRow, err error) bool) {
	    query := "SELECT ID,ADDED_TS,HASH,REP_TAG_CLASS_UUID,untagged,BOOL_VALUE,DATE_VALUE,multiple_values,valid_value,LIST_VALUE_ID,NUMERIC_VALUE,TEXT_VALUE,entry_hash FROM REP_DB_INCOMING_FILE_HASH_ENTRY_ADD"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDbIncomingFileHashEntryAddRow
	        err := rows.Scan(&r.ID, &r.AddedTs, &r.Hash, &r.RepTagClassUuid, &r.Untagged, &r.BoolValue, &r.DateValue, &r.MultipleValues, &r.ValidValue, &r.ListValueID, &r.NumericValue, &r.TextValue, &r.EntryHash)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDbIncomingFileHashEntryDeleteRow struct represents rows of the REP_DB_INCOMING_FILE_HASH_ENTRY_DELETE table.
type RepDbIncomingFileHashEntryDeleteRow struct {
    Hash	string
}

// IterateRepDbIncomingFileHashEntryDelete provide access to all rows of the REP_DB_INCOMING_FILE_HASH_ENTRY_DELETE matching given criteria.
func IterateRepDbIncomingFileHashEntryDelete(db *sql.DB, where string, callback func(v *RepDbIncomingFileHashEntryDeleteRow) error) error {
    query := "SELECT HASH FROM REP_DB_INCOMING_FILE_HASH_ENTRY_DELETE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDbIncomingFileHashEntryDeleteRow
        err := rows.Scan(&r.Hash)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDbIncomingFileHashEntryDelete provide iterator to all rows of the REP_DB_INCOMING_FILE_HASH_ENTRY_DELETE matching given criteria.
func RangeRepDbIncomingFileHashEntryDelete(db *sql.DB, where string) iter.Seq2[*RepDbIncomingFileHashEntryDeleteRow, error] {
	return func(yield func(v *RepDbIncomingFileHashEntryDeleteRow, err error) bool) {
	    query := "SELECT HASH FROM REP_DB_INCOMING_FILE_HASH_ENTRY_DELETE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDbIncomingFileHashEntryDeleteRow
	        err := rows.Scan(&r.Hash)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDbIncomingFileHashEntryUpdateRow struct represents rows of the REP_DB_INCOMING_FILE_HASH_ENTRY_UPDATE table.
type RepDbIncomingFileHashEntryUpdateRow struct {
    ID	sql.NullInt64
    AddedTs	sql.NullInt64
    Hash	sql.NullString
    RepTagClassUuid	string
    Untagged	int8
    BoolValue	sql.NullByte
    DateValue	sql.NullTime
    MultipleValues	sql.NullByte
    ValidValue	sql.NullString
    ListValueID	int
    NumericValue	sql.NullInt32
    TextValue	sql.NullString
}

// IterateRepDbIncomingFileHashEntryUpdate provide access to all rows of the REP_DB_INCOMING_FILE_HASH_ENTRY_UPDATE matching given criteria.
func IterateRepDbIncomingFileHashEntryUpdate(db *sql.DB, where string, callback func(v *RepDbIncomingFileHashEntryUpdateRow) error) error {
    query := "SELECT ID,ADDED_TS,HASH,REP_TAG_CLASS_UUID,untagged,BOOL_VALUE,DATE_VALUE,multiple_values,valid_value,LIST_VALUE_ID,NUMERIC_VALUE,TEXT_VALUE FROM REP_DB_INCOMING_FILE_HASH_ENTRY_UPDATE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDbIncomingFileHashEntryUpdateRow
        err := rows.Scan(&r.ID, &r.AddedTs, &r.Hash, &r.RepTagClassUuid, &r.Untagged, &r.BoolValue, &r.DateValue, &r.MultipleValues, &r.ValidValue, &r.ListValueID, &r.NumericValue, &r.TextValue)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDbIncomingFileHashEntryUpdate provide iterator to all rows of the REP_DB_INCOMING_FILE_HASH_ENTRY_UPDATE matching given criteria.
func RangeRepDbIncomingFileHashEntryUpdate(db *sql.DB, where string) iter.Seq2[*RepDbIncomingFileHashEntryUpdateRow, error] {
	return func(yield func(v *RepDbIncomingFileHashEntryUpdateRow, err error) bool) {
	    query := "SELECT ID,ADDED_TS,HASH,REP_TAG_CLASS_UUID,untagged,BOOL_VALUE,DATE_VALUE,multiple_values,valid_value,LIST_VALUE_ID,NUMERIC_VALUE,TEXT_VALUE FROM REP_DB_INCOMING_FILE_HASH_ENTRY_UPDATE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDbIncomingFileHashEntryUpdateRow
	        err := rows.Scan(&r.ID, &r.AddedTs, &r.Hash, &r.RepTagClassUuid, &r.Untagged, &r.BoolValue, &r.DateValue, &r.MultipleValues, &r.ValidValue, &r.ListValueID, &r.NumericValue, &r.TextValue)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDbSummaryRow struct represents rows of the REP_DB_SUMMARY table.
type RepDbSummaryRow struct {
    ID	int
    UserIpv4Count	int
    UserIpv6Count	int
    UserDnsCount	int
    DvIpv4Count	int
    DvIpv6Count	int
    DvDnsCount	int
    GeoIpv4Count	int
    UserUrlCount	int
    UserFileHashCount	int
}

// IterateRepDbSummary provide access to all rows of the REP_DB_SUMMARY matching given criteria.
func IterateRepDbSummary(db *sql.DB, where string, callback func(v *RepDbSummaryRow) error) error {
    query := "SELECT ID,USER_IPV4_COUNT,USER_IPV6_COUNT,USER_DNS_COUNT,DV_IPV4_COUNT,DV_IPV6_COUNT,DV_DNS_COUNT,GEO_IPV4_COUNT,USER_URL_COUNT,USER_FILE_HASH_COUNT FROM REP_DB_SUMMARY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDbSummaryRow
        err := rows.Scan(&r.ID, &r.UserIpv4Count, &r.UserIpv6Count, &r.UserDnsCount, &r.DvIpv4Count, &r.DvIpv6Count, &r.DvDnsCount, &r.GeoIpv4Count, &r.UserUrlCount, &r.UserFileHashCount)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDbSummary provide iterator to all rows of the REP_DB_SUMMARY matching given criteria.
func RangeRepDbSummary(db *sql.DB, where string) iter.Seq2[*RepDbSummaryRow, error] {
	return func(yield func(v *RepDbSummaryRow, err error) bool) {
	    query := "SELECT ID,USER_IPV4_COUNT,USER_IPV6_COUNT,USER_DNS_COUNT,DV_IPV4_COUNT,DV_IPV6_COUNT,DV_DNS_COUNT,GEO_IPV4_COUNT,USER_URL_COUNT,USER_FILE_HASH_COUNT FROM REP_DB_SUMMARY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDbSummaryRow
	        err := rows.Scan(&r.ID, &r.UserIpv4Count, &r.UserIpv6Count, &r.UserDnsCount, &r.DvIpv4Count, &r.DvIpv6Count, &r.DvDnsCount, &r.GeoIpv4Count, &r.UserUrlCount, &r.UserFileHashCount)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDeltaInputRow struct represents rows of the REP_DELTA_INPUT table.
type RepDeltaInputRow struct {
    ID	uint
    DeltaType	sql.NullString
    FilePath	sql.NullString
    DeltaData	[]byte
    AllDevices	int8
    SessionID	int
}

// IterateRepDeltaInput provide access to all rows of the REP_DELTA_INPUT matching given criteria.
func IterateRepDeltaInput(db *sql.DB, where string, callback func(v *RepDeltaInputRow) error) error {
    query := "SELECT id,DELTA_TYPE,FILE_PATH,DELTA_DATA,ALL_DEVICES,SESSION_ID FROM REP_DELTA_INPUT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDeltaInputRow
        err := rows.Scan(&r.ID, &r.DeltaType, &r.FilePath, &r.DeltaData, &r.AllDevices, &r.SessionID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDeltaInput provide iterator to all rows of the REP_DELTA_INPUT matching given criteria.
func RangeRepDeltaInput(db *sql.DB, where string) iter.Seq2[*RepDeltaInputRow, error] {
	return func(yield func(v *RepDeltaInputRow, err error) bool) {
	    query := "SELECT id,DELTA_TYPE,FILE_PATH,DELTA_DATA,ALL_DEVICES,SESSION_ID FROM REP_DELTA_INPUT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDeltaInputRow
	        err := rows.Scan(&r.ID, &r.DeltaType, &r.FilePath, &r.DeltaData, &r.AllDevices, &r.SessionID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDeltaInputDeviceTargetRow struct represents rows of the REP_DELTA_INPUT_DEVICE_TARGET table.
type RepDeltaInputDeviceTargetRow struct {
    DeltaInputID	uint
    DeviceID	uint
}

// IterateRepDeltaInputDeviceTarget provide access to all rows of the REP_DELTA_INPUT_DEVICE_TARGET matching given criteria.
func IterateRepDeltaInputDeviceTarget(db *sql.DB, where string, callback func(v *RepDeltaInputDeviceTargetRow) error) error {
    query := "SELECT DELTA_INPUT_ID,DEVICE_ID FROM REP_DELTA_INPUT_DEVICE_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDeltaInputDeviceTargetRow
        err := rows.Scan(&r.DeltaInputID, &r.DeviceID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDeltaInputDeviceTarget provide iterator to all rows of the REP_DELTA_INPUT_DEVICE_TARGET matching given criteria.
func RangeRepDeltaInputDeviceTarget(db *sql.DB, where string) iter.Seq2[*RepDeltaInputDeviceTargetRow, error] {
	return func(yield func(v *RepDeltaInputDeviceTargetRow, err error) bool) {
	    query := "SELECT DELTA_INPUT_ID,DEVICE_ID FROM REP_DELTA_INPUT_DEVICE_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDeltaInputDeviceTargetRow
	        err := rows.Scan(&r.DeltaInputID, &r.DeviceID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDeltaInputIDPkValueRow struct represents rows of the REP_DELTA_INPUT_ID_PK_VALUE table.
type RepDeltaInputIDPkValueRow struct {
    PkID	string
    PkValue	sql.NullInt32
}

// IterateRepDeltaInputIDPkValue provide access to all rows of the REP_DELTA_INPUT_ID_PK_VALUE matching given criteria.
func IterateRepDeltaInputIDPkValue(db *sql.DB, where string, callback func(v *RepDeltaInputIDPkValueRow) error) error {
    query := "SELECT PK_ID,PK_VALUE FROM REP_DELTA_INPUT_ID_PK_VALUE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDeltaInputIDPkValueRow
        err := rows.Scan(&r.PkID, &r.PkValue)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDeltaInputIDPkValue provide iterator to all rows of the REP_DELTA_INPUT_ID_PK_VALUE matching given criteria.
func RangeRepDeltaInputIDPkValue(db *sql.DB, where string) iter.Seq2[*RepDeltaInputIDPkValueRow, error] {
	return func(yield func(v *RepDeltaInputIDPkValueRow, err error) bool) {
	    query := "SELECT PK_ID,PK_VALUE FROM REP_DELTA_INPUT_ID_PK_VALUE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDeltaInputIDPkValueRow
	        err := rows.Scan(&r.PkID, &r.PkValue)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDeltaInputStatusRow struct represents rows of the REP_DELTA_INPUT_STATUS table.
type RepDeltaInputStatusRow struct {
    ID	uint
    Type	uint8
    Status	uint8
    TimeQueued	string
    TimeStarted	string
    TimeCompleted	string
    RepDvVersion	sql.NullString
    Ipv4AddCount	uint
    Ipv4UpdateCount	uint
    Ipv4DeleteCount	uint
    Ipv6AddCount	uint
    Ipv6UpdateCount	uint
    Ipv6DeleteCount	uint
    DnsAddCount	uint
    DnsUpdateCount	uint
    DnsDeleteCount	uint
    ThreatDvVersion	sql.NullString
}

// IterateRepDeltaInputStatus provide access to all rows of the REP_DELTA_INPUT_STATUS matching given criteria.
func IterateRepDeltaInputStatus(db *sql.DB, where string, callback func(v *RepDeltaInputStatusRow) error) error {
    query := "SELECT ID,TYPE,STATUS,TIME_QUEUED,TIME_STARTED,TIME_COMPLETED,REP_DV_VERSION,IPV4_ADD_COUNT,IPV4_UPDATE_COUNT,IPV4_DELETE_COUNT,IPV6_ADD_COUNT,IPV6_UPDATE_COUNT,IPV6_DELETE_COUNT,DNS_ADD_COUNT,DNS_UPDATE_COUNT,DNS_DELETE_COUNT,THREAT_DV_VERSION FROM REP_DELTA_INPUT_STATUS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDeltaInputStatusRow
        err := rows.Scan(&r.ID, &r.Type, &r.Status, &r.TimeQueued, &r.TimeStarted, &r.TimeCompleted, &r.RepDvVersion, &r.Ipv4AddCount, &r.Ipv4UpdateCount, &r.Ipv4DeleteCount, &r.Ipv6AddCount, &r.Ipv6UpdateCount, &r.Ipv6DeleteCount, &r.DnsAddCount, &r.DnsUpdateCount, &r.DnsDeleteCount, &r.ThreatDvVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDeltaInputStatus provide iterator to all rows of the REP_DELTA_INPUT_STATUS matching given criteria.
func RangeRepDeltaInputStatus(db *sql.DB, where string) iter.Seq2[*RepDeltaInputStatusRow, error] {
	return func(yield func(v *RepDeltaInputStatusRow, err error) bool) {
	    query := "SELECT ID,TYPE,STATUS,TIME_QUEUED,TIME_STARTED,TIME_COMPLETED,REP_DV_VERSION,IPV4_ADD_COUNT,IPV4_UPDATE_COUNT,IPV4_DELETE_COUNT,IPV6_ADD_COUNT,IPV6_UPDATE_COUNT,IPV6_DELETE_COUNT,DNS_ADD_COUNT,DNS_UPDATE_COUNT,DNS_DELETE_COUNT,THREAT_DV_VERSION FROM REP_DELTA_INPUT_STATUS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDeltaInputStatusRow
	        err := rows.Scan(&r.ID, &r.Type, &r.Status, &r.TimeQueued, &r.TimeStarted, &r.TimeCompleted, &r.RepDvVersion, &r.Ipv4AddCount, &r.Ipv4UpdateCount, &r.Ipv4DeleteCount, &r.Ipv6AddCount, &r.Ipv6UpdateCount, &r.Ipv6DeleteCount, &r.DnsAddCount, &r.DnsUpdateCount, &r.DnsDeleteCount, &r.ThreatDvVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepDnsExceptionRow struct represents rows of the REP_DNS_EXCEPTION table.
type RepDnsExceptionRow struct {
    ProfileID	string
    HostName	string
    UpdateTime	int64
    Locked	int8
}

// IterateRepDnsException provide access to all rows of the REP_DNS_EXCEPTION matching given criteria.
func IterateRepDnsException(db *sql.DB, where string, callback func(v *RepDnsExceptionRow) error) error {
    query := "SELECT PROFILE_ID,HOST_NAME,UPDATE_TIME,LOCKED FROM REP_DNS_EXCEPTION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepDnsExceptionRow
        err := rows.Scan(&r.ProfileID, &r.HostName, &r.UpdateTime, &r.Locked)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepDnsException provide iterator to all rows of the REP_DNS_EXCEPTION matching given criteria.
func RangeRepDnsException(db *sql.DB, where string) iter.Seq2[*RepDnsExceptionRow, error] {
	return func(yield func(v *RepDnsExceptionRow, err error) bool) {
	    query := "SELECT PROFILE_ID,HOST_NAME,UPDATE_TIME,LOCKED FROM REP_DNS_EXCEPTION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepDnsExceptionRow
	        err := rows.Scan(&r.ProfileID, &r.HostName, &r.UpdateTime, &r.Locked)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepEntryDeltaRow struct represents rows of the REP_ENTRY_DELTA table.
type RepEntryDeltaRow struct {
    ID	uint
    StartAddr	[]byte
    EndAddr	[]byte
    CidrPrefix	sql.NullInt16
    Dns	[]byte
    DnsStr	sql.NullString
    ExactMatch	sql.NullByte
    EntryType	sql.NullByte
    NumTags	int16
}

// IterateRepEntryDelta provide access to all rows of the REP_ENTRY_DELTA matching given criteria.
func IterateRepEntryDelta(db *sql.DB, where string, callback func(v *RepEntryDeltaRow) error) error {
    query := "SELECT ID,START_ADDR,END_ADDR,CIDR_PREFIX,DNS,DNS_STR,EXACT_MATCH,ENTRY_TYPE,NUM_TAGS FROM REP_ENTRY_DELTA"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepEntryDeltaRow
        err := rows.Scan(&r.ID, &r.StartAddr, &r.EndAddr, &r.CidrPrefix, &r.Dns, &r.DnsStr, &r.ExactMatch, &r.EntryType, &r.NumTags)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepEntryDelta provide iterator to all rows of the REP_ENTRY_DELTA matching given criteria.
func RangeRepEntryDelta(db *sql.DB, where string) iter.Seq2[*RepEntryDeltaRow, error] {
	return func(yield func(v *RepEntryDeltaRow, err error) bool) {
	    query := "SELECT ID,START_ADDR,END_ADDR,CIDR_PREFIX,DNS,DNS_STR,EXACT_MATCH,ENTRY_TYPE,NUM_TAGS FROM REP_ENTRY_DELTA"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepEntryDeltaRow
	        err := rows.Scan(&r.ID, &r.StartAddr, &r.EndAddr, &r.CidrPrefix, &r.Dns, &r.DnsStr, &r.ExactMatch, &r.EntryType, &r.NumTags)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepEntryDeltaInfoRow struct represents rows of the REP_ENTRY_DELTA_INFO table.
type RepEntryDeltaInfoRow struct {
    ID	uint
    Operation	sql.NullString
    EntryID	sql.NullInt32
}

// IterateRepEntryDeltaInfo provide access to all rows of the REP_ENTRY_DELTA_INFO matching given criteria.
func IterateRepEntryDeltaInfo(db *sql.DB, where string, callback func(v *RepEntryDeltaInfoRow) error) error {
    query := "SELECT ID,OPERATION,ENTRY_ID FROM REP_ENTRY_DELTA_INFO"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepEntryDeltaInfoRow
        err := rows.Scan(&r.ID, &r.Operation, &r.EntryID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepEntryDeltaInfo provide iterator to all rows of the REP_ENTRY_DELTA_INFO matching given criteria.
func RangeRepEntryDeltaInfo(db *sql.DB, where string) iter.Seq2[*RepEntryDeltaInfoRow, error] {
	return func(yield func(v *RepEntryDeltaInfoRow, err error) bool) {
	    query := "SELECT ID,OPERATION,ENTRY_ID FROM REP_ENTRY_DELTA_INFO"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepEntryDeltaInfoRow
	        err := rows.Scan(&r.ID, &r.Operation, &r.EntryID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepEntryImportQueueRow struct represents rows of the REP_ENTRY_IMPORT_QUEUE table.
type RepEntryImportQueueRow struct {
    RepEntryImportQueueID	string
    FileType	string
    FileName	string
    CreatedTime	int64
    TotalEntriesInFile	uint
    TotalEntriesLoaded	uint
    FileSource	string
    UserTagOverride	string
    UserTagValueData	sql.NullString
    SessionID	int
    BatchFileType	string
}

// IterateRepEntryImportQueue provide access to all rows of the REP_ENTRY_IMPORT_QUEUE matching given criteria.
func IterateRepEntryImportQueue(db *sql.DB, where string, callback func(v *RepEntryImportQueueRow) error) error {
    query := "SELECT REP_ENTRY_IMPORT_QUEUE_ID,FILE_TYPE,FILE_NAME,CREATED_TIME,TOTAL_ENTRIES_IN_FILE,TOTAL_ENTRIES_LOADED,FILE_SOURCE,USER_TAG_OVERRIDE,USER_TAG_VALUE_DATA,SESSION_ID,BATCH_FILE_TYPE FROM REP_ENTRY_IMPORT_QUEUE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepEntryImportQueueRow
        err := rows.Scan(&r.RepEntryImportQueueID, &r.FileType, &r.FileName, &r.CreatedTime, &r.TotalEntriesInFile, &r.TotalEntriesLoaded, &r.FileSource, &r.UserTagOverride, &r.UserTagValueData, &r.SessionID, &r.BatchFileType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepEntryImportQueue provide iterator to all rows of the REP_ENTRY_IMPORT_QUEUE matching given criteria.
func RangeRepEntryImportQueue(db *sql.DB, where string) iter.Seq2[*RepEntryImportQueueRow, error] {
	return func(yield func(v *RepEntryImportQueueRow, err error) bool) {
	    query := "SELECT REP_ENTRY_IMPORT_QUEUE_ID,FILE_TYPE,FILE_NAME,CREATED_TIME,TOTAL_ENTRIES_IN_FILE,TOTAL_ENTRIES_LOADED,FILE_SOURCE,USER_TAG_OVERRIDE,USER_TAG_VALUE_DATA,SESSION_ID,BATCH_FILE_TYPE FROM REP_ENTRY_IMPORT_QUEUE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepEntryImportQueueRow
	        err := rows.Scan(&r.RepEntryImportQueueID, &r.FileType, &r.FileName, &r.CreatedTime, &r.TotalEntriesInFile, &r.TotalEntriesLoaded, &r.FileSource, &r.UserTagOverride, &r.UserTagValueData, &r.SessionID, &r.BatchFileType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepFilterRow struct represents rows of the REP_FILTER table.
type RepFilterRow struct {
    ID	uint
    Name	string
    Description	sql.NullString
    Position	int
    ProfileID	string
    PolicyGroupID	string
    IPV4	int8
    IPV6	int8
    Domain	int8
    UserEntries	int8
    FeedEntries	int8
    UntaggedEntries	int8
    TaggedEntries	int8
    RepFilterUuid	string
    ExpressionXml	sql.NullString
    Active	int
    ActionsetID	sql.NullString
    IsGeo	int8
    Url	int8
    Filehash	int8
}

// IterateRepFilter provide access to all rows of the REP_FILTER matching given criteria.
func IterateRepFilter(db *sql.DB, where string, callback func(v *RepFilterRow) error) error {
    query := "SELECT ID,NAME,DESCRIPTION,POSITION,PROFILE_ID,POLICY_GROUP_ID,IP_V4,IP_V6,DOMAIN,USER_ENTRIES,FEED_ENTRIES,UNTAGGED_ENTRIES,TAGGED_ENTRIES,REP_FILTER_UUID,EXPRESSION_XML,ACTIVE,ACTIONSET_ID,IS_GEO,URL,FILEHASH FROM REP_FILTER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepFilterRow
        err := rows.Scan(&r.ID, &r.Name, &r.Description, &r.Position, &r.ProfileID, &r.PolicyGroupID, &r.IPV4, &r.IPV6, &r.Domain, &r.UserEntries, &r.FeedEntries, &r.UntaggedEntries, &r.TaggedEntries, &r.RepFilterUuid, &r.ExpressionXml, &r.Active, &r.ActionsetID, &r.IsGeo, &r.Url, &r.Filehash)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepFilter provide iterator to all rows of the REP_FILTER matching given criteria.
func RangeRepFilter(db *sql.DB, where string) iter.Seq2[*RepFilterRow, error] {
	return func(yield func(v *RepFilterRow, err error) bool) {
	    query := "SELECT ID,NAME,DESCRIPTION,POSITION,PROFILE_ID,POLICY_GROUP_ID,IP_V4,IP_V6,DOMAIN,USER_ENTRIES,FEED_ENTRIES,UNTAGGED_ENTRIES,TAGGED_ENTRIES,REP_FILTER_UUID,EXPRESSION_XML,ACTIVE,ACTIONSET_ID,IS_GEO,URL,FILEHASH FROM REP_FILTER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepFilterRow
	        err := rows.Scan(&r.ID, &r.Name, &r.Description, &r.Position, &r.ProfileID, &r.PolicyGroupID, &r.IPV4, &r.IPV6, &r.Domain, &r.UserEntries, &r.FeedEntries, &r.UntaggedEntries, &r.TaggedEntries, &r.RepFilterUuid, &r.ExpressionXml, &r.Active, &r.ActionsetID, &r.IsGeo, &r.Url, &r.Filehash)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepFilterSnapshotRow struct represents rows of the REP_FILTER_SNAPSHOT table.
type RepFilterSnapshotRow struct {
    ID	uint
    Name	string
    Description	sql.NullString
    FilterID	uint
    DistributeID	sql.NullString
    ProfileID	string
    ProfileVersion	sql.NullString
    Position	int
    PolicyGroupID	string
    IPV4	int8
    IPV6	int8
    Domain	int8
    UserEntries	int8
    FeedEntries	int8
    UntaggedEntries	int8
    TaggedEntries	int8
    RepFilterUuid	string
    ExpressionXml	sql.NullString
    Active	int
    ActionsetID	sql.NullString
    IsGeo	int8
    Url	int8
    Filehash	int8
}

// IterateRepFilterSnapshot provide access to all rows of the REP_FILTER_SNAPSHOT matching given criteria.
func IterateRepFilterSnapshot(db *sql.DB, where string, callback func(v *RepFilterSnapshotRow) error) error {
    query := "SELECT ID,NAME,DESCRIPTION,FILTER_ID,DISTRIBUTE_ID,PROFILE_ID,PROFILE_VERSION,POSITION,POLICY_GROUP_ID,IP_V4,IP_V6,DOMAIN,USER_ENTRIES,FEED_ENTRIES,UNTAGGED_ENTRIES,TAGGED_ENTRIES,REP_FILTER_UUID,EXPRESSION_XML,ACTIVE,ACTIONSET_ID,IS_GEO,URL,FILEHASH FROM REP_FILTER_SNAPSHOT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepFilterSnapshotRow
        err := rows.Scan(&r.ID, &r.Name, &r.Description, &r.FilterID, &r.DistributeID, &r.ProfileID, &r.ProfileVersion, &r.Position, &r.PolicyGroupID, &r.IPV4, &r.IPV6, &r.Domain, &r.UserEntries, &r.FeedEntries, &r.UntaggedEntries, &r.TaggedEntries, &r.RepFilterUuid, &r.ExpressionXml, &r.Active, &r.ActionsetID, &r.IsGeo, &r.Url, &r.Filehash)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepFilterSnapshot provide iterator to all rows of the REP_FILTER_SNAPSHOT matching given criteria.
func RangeRepFilterSnapshot(db *sql.DB, where string) iter.Seq2[*RepFilterSnapshotRow, error] {
	return func(yield func(v *RepFilterSnapshotRow, err error) bool) {
	    query := "SELECT ID,NAME,DESCRIPTION,FILTER_ID,DISTRIBUTE_ID,PROFILE_ID,PROFILE_VERSION,POSITION,POLICY_GROUP_ID,IP_V4,IP_V6,DOMAIN,USER_ENTRIES,FEED_ENTRIES,UNTAGGED_ENTRIES,TAGGED_ENTRIES,REP_FILTER_UUID,EXPRESSION_XML,ACTIVE,ACTIONSET_ID,IS_GEO,URL,FILEHASH FROM REP_FILTER_SNAPSHOT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepFilterSnapshotRow
	        err := rows.Scan(&r.ID, &r.Name, &r.Description, &r.FilterID, &r.DistributeID, &r.ProfileID, &r.ProfileVersion, &r.Position, &r.PolicyGroupID, &r.IPV4, &r.IPV6, &r.Domain, &r.UserEntries, &r.FeedEntries, &r.UntaggedEntries, &r.TaggedEntries, &r.RepFilterUuid, &r.ExpressionXml, &r.Active, &r.ActionsetID, &r.IsGeo, &r.Url, &r.Filehash)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepGroupsetsRow struct represents rows of the REP_GROUPSETS table.
type RepGroupsetsRow struct {
    DeviceID	uint
    GroupsetsXml	string
}

// IterateRepGroupsets provide access to all rows of the REP_GROUPSETS matching given criteria.
func IterateRepGroupsets(db *sql.DB, where string, callback func(v *RepGroupsetsRow) error) error {
    query := "SELECT DEVICE_ID,GROUPSETS_XML FROM REP_GROUPSETS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepGroupsetsRow
        err := rows.Scan(&r.DeviceID, &r.GroupsetsXml)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepGroupsets provide iterator to all rows of the REP_GROUPSETS matching given criteria.
func RangeRepGroupsets(db *sql.DB, where string) iter.Seq2[*RepGroupsetsRow, error] {
	return func(yield func(v *RepGroupsetsRow, err error) bool) {
	    query := "SELECT DEVICE_ID,GROUPSETS_XML FROM REP_GROUPSETS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepGroupsetsRow
	        err := rows.Scan(&r.DeviceID, &r.GroupsetsXml)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepPkgLatestRow struct represents rows of the REP_PKG_LATEST table.
type RepPkgLatestRow struct {
    ID	uint
    Version	string
    Type	string
    SubType	sql.NullString
    DownloadTimestamp	string
    CreationTime	string
}

// IterateRepPkgLatest provide access to all rows of the REP_PKG_LATEST matching given criteria.
func IterateRepPkgLatest(db *sql.DB, where string, callback func(v *RepPkgLatestRow) error) error {
    query := "SELECT ID,VERSION,TYPE,SUB_TYPE,DOWNLOAD_TIMESTAMP,CREATION_TIME FROM REP_PKG_LATEST"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepPkgLatestRow
        err := rows.Scan(&r.ID, &r.Version, &r.Type, &r.SubType, &r.DownloadTimestamp, &r.CreationTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepPkgLatest provide iterator to all rows of the REP_PKG_LATEST matching given criteria.
func RangeRepPkgLatest(db *sql.DB, where string) iter.Seq2[*RepPkgLatestRow, error] {
	return func(yield func(v *RepPkgLatestRow, err error) bool) {
	    query := "SELECT ID,VERSION,TYPE,SUB_TYPE,DOWNLOAD_TIMESTAMP,CREATION_TIME FROM REP_PKG_LATEST"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepPkgLatestRow
	        err := rows.Scan(&r.ID, &r.Version, &r.Type, &r.SubType, &r.DownloadTimestamp, &r.CreationTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepProfileExceptionRow struct represents rows of the REP_PROFILE_EXCEPTION table.
type RepProfileExceptionRow struct {
    ProfileID	string
    ID	string
    AddrPairsGroupID	sql.NullString
    Deleted	string
    IterationID	string
    Version	string
    PkgDir	string
    UpdateTime	int64
}

// IterateRepProfileException provide access to all rows of the REP_PROFILE_EXCEPTION matching given criteria.
func IterateRepProfileException(db *sql.DB, where string, callback func(v *RepProfileExceptionRow) error) error {
    query := "SELECT PROFILE_ID,ID,ADDR_PAIRS_GROUP_ID,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME FROM REP_PROFILE_EXCEPTION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepProfileExceptionRow
        err := rows.Scan(&r.ProfileID, &r.ID, &r.AddrPairsGroupID, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepProfileException provide iterator to all rows of the REP_PROFILE_EXCEPTION matching given criteria.
func RangeRepProfileException(db *sql.DB, where string) iter.Seq2[*RepProfileExceptionRow, error] {
	return func(yield func(v *RepProfileExceptionRow, err error) bool) {
	    query := "SELECT PROFILE_ID,ID,ADDR_PAIRS_GROUP_ID,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME FROM REP_PROFILE_EXCEPTION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepProfileExceptionRow
	        err := rows.Scan(&r.ProfileID, &r.ID, &r.AddrPairsGroupID, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepTagClassRow struct represents rows of the REP_TAG_CLASS table.
type RepTagClassRow struct {
    ID	uint
    Uuid	string
    Timestamp	string
    InputDtFormat	sql.NullString
    DisplayDtFormat	sql.NullString
    Name	string
    TagType	uint8
    Description	sql.NullString
    StrLen	sql.NullInt32
    IntLow	sql.NullInt32
    IntHigh	sql.NullInt32
    MultipleValuesAllowed	sql.NullBool
    IsDeleted	sql.NullBool
}

// IterateRepTagClass provide access to all rows of the REP_TAG_CLASS matching given criteria.
func IterateRepTagClass(db *sql.DB, where string, callback func(v *RepTagClassRow) error) error {
    query := "SELECT ID,UUID,TIMESTAMP,INPUT_DT_FORMAT,DISPLAY_DT_FORMAT,NAME,TAG_TYPE,DESCRIPTION,STR_LEN,INT_LOW,INT_HIGH,MULTIPLE_VALUES_ALLOWED,IS_DELETED FROM REP_TAG_CLASS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepTagClassRow
        err := rows.Scan(&r.ID, &r.Uuid, &r.Timestamp, &r.InputDtFormat, &r.DisplayDtFormat, &r.Name, &r.TagType, &r.Description, &r.StrLen, &r.IntLow, &r.IntHigh, &r.MultipleValuesAllowed, &r.IsDeleted)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepTagClass provide iterator to all rows of the REP_TAG_CLASS matching given criteria.
func RangeRepTagClass(db *sql.DB, where string) iter.Seq2[*RepTagClassRow, error] {
	return func(yield func(v *RepTagClassRow, err error) bool) {
	    query := "SELECT ID,UUID,TIMESTAMP,INPUT_DT_FORMAT,DISPLAY_DT_FORMAT,NAME,TAG_TYPE,DESCRIPTION,STR_LEN,INT_LOW,INT_HIGH,MULTIPLE_VALUES_ALLOWED,IS_DELETED FROM REP_TAG_CLASS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepTagClassRow
	        err := rows.Scan(&r.ID, &r.Uuid, &r.Timestamp, &r.InputDtFormat, &r.DisplayDtFormat, &r.Name, &r.TagType, &r.Description, &r.StrLen, &r.IntLow, &r.IntHigh, &r.MultipleValuesAllowed, &r.IsDeleted)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepTagListValueRow struct represents rows of the REP_TAG_LIST_VALUE table.
type RepTagListValueRow struct {
    ID	uint
    TagID	uint
    ValidValue	sql.NullString
    ListValIndex	uint
}

// IterateRepTagListValue provide access to all rows of the REP_TAG_LIST_VALUE matching given criteria.
func IterateRepTagListValue(db *sql.DB, where string, callback func(v *RepTagListValueRow) error) error {
    query := "SELECT ID,TAG_ID,VALID_VALUE,LIST_VAL_INDEX FROM REP_TAG_LIST_VALUE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepTagListValueRow
        err := rows.Scan(&r.ID, &r.TagID, &r.ValidValue, &r.ListValIndex)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepTagListValue provide iterator to all rows of the REP_TAG_LIST_VALUE matching given criteria.
func RangeRepTagListValue(db *sql.DB, where string) iter.Seq2[*RepTagListValueRow, error] {
	return func(yield func(v *RepTagListValueRow, err error) bool) {
	    query := "SELECT ID,TAG_ID,VALID_VALUE,LIST_VAL_INDEX FROM REP_TAG_LIST_VALUE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepTagListValueRow
	        err := rows.Scan(&r.ID, &r.TagID, &r.ValidValue, &r.ListValIndex)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RepUrlExceptionRow struct represents rows of the REP_URL_EXCEPTION table.
type RepUrlExceptionRow struct {
    ID	uint
    ProfileID	string
    Url	string
    UpdateTime	int64
    Locked	int8
}

// IterateRepUrlException provide access to all rows of the REP_URL_EXCEPTION matching given criteria.
func IterateRepUrlException(db *sql.DB, where string, callback func(v *RepUrlExceptionRow) error) error {
    query := "SELECT ID,PROFILE_ID,URL,UPDATE_TIME,LOCKED FROM REP_URL_EXCEPTION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RepUrlExceptionRow
        err := rows.Scan(&r.ID, &r.ProfileID, &r.Url, &r.UpdateTime, &r.Locked)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRepUrlException provide iterator to all rows of the REP_URL_EXCEPTION matching given criteria.
func RangeRepUrlException(db *sql.DB, where string) iter.Seq2[*RepUrlExceptionRow, error] {
	return func(yield func(v *RepUrlExceptionRow, err error) bool) {
	    query := "SELECT ID,PROFILE_ID,URL,UPDATE_TIME,LOCKED FROM REP_URL_EXCEPTION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RepUrlExceptionRow
	        err := rows.Scan(&r.ID, &r.ProfileID, &r.Url, &r.UpdateTime, &r.Locked)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RouteRow struct represents rows of the ROUTE table.
type RouteRow struct {
    RouteID	string
    RouteDeviceKey	string
    RouteMask	sql.NullString
    TypeOfRoute	int
    RoutePortID	sql.NullString
    RouteDestinationNamedObjID	sql.NullInt32
    GatewayNamedObjID	sql.NullInt32
    Distance	sql.NullInt32
}

// IterateRoute provide access to all rows of the ROUTE matching given criteria.
func IterateRoute(db *sql.DB, where string, callback func(v *RouteRow) error) error {
    query := "SELECT ROUTE_ID,ROUTE_DEVICE_KEY,ROUTE_MASK,TYPE_OF_ROUTE,ROUTE_PORT_ID,ROUTE_DESTINATION_NAMED_OBJ_ID,GATEWAY_NAMED_OBJ_ID,DISTANCE FROM ROUTE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RouteRow
        err := rows.Scan(&r.RouteID, &r.RouteDeviceKey, &r.RouteMask, &r.TypeOfRoute, &r.RoutePortID, &r.RouteDestinationNamedObjID, &r.GatewayNamedObjID, &r.Distance)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRoute provide iterator to all rows of the ROUTE matching given criteria.
func RangeRoute(db *sql.DB, where string) iter.Seq2[*RouteRow, error] {
	return func(yield func(v *RouteRow, err error) bool) {
	    query := "SELECT ROUTE_ID,ROUTE_DEVICE_KEY,ROUTE_MASK,TYPE_OF_ROUTE,ROUTE_PORT_ID,ROUTE_DESTINATION_NAMED_OBJ_ID,GATEWAY_NAMED_OBJ_ID,DISTANCE FROM ROUTE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RouteRow
	        err := rows.Scan(&r.RouteID, &r.RouteDeviceKey, &r.RouteMask, &r.TypeOfRoute, &r.RoutePortID, &r.RouteDestinationNamedObjID, &r.GatewayNamedObjID, &r.Distance)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RoutingConfigRow struct represents rows of the ROUTING_CONFIG table.
type RoutingConfigRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    PimDmEnabled	sql.NullByte
    QueryInterval	sql.NullInt32
    PruneTimeout	sql.NullInt32
    IgmpEnabled	sql.NullByte
    RipEnabled	sql.NullByte
    RipUpdateInterval	sql.NullInt32
}

// IterateRoutingConfig provide access to all rows of the ROUTING_CONFIG matching given criteria.
func IterateRoutingConfig(db *sql.DB, where string, callback func(v *RoutingConfigRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,PIM_DM_ENABLED,QUERY_INTERVAL,PRUNE_TIMEOUT,IGMP_ENABLED,RIP_ENABLED,RIP_UPDATE_INTERVAL FROM ROUTING_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RoutingConfigRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.PimDmEnabled, &r.QueryInterval, &r.PruneTimeout, &r.IgmpEnabled, &r.RipEnabled, &r.RipUpdateInterval)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRoutingConfig provide iterator to all rows of the ROUTING_CONFIG matching given criteria.
func RangeRoutingConfig(db *sql.DB, where string) iter.Seq2[*RoutingConfigRow, error] {
	return func(yield func(v *RoutingConfigRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,PIM_DM_ENABLED,QUERY_INTERVAL,PRUNE_TIMEOUT,IGMP_ENABLED,RIP_ENABLED,RIP_UPDATE_INTERVAL FROM ROUTING_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RoutingConfigRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.PimDmEnabled, &r.QueryInterval, &r.PruneTimeout, &r.IgmpEnabled, &r.RipEnabled, &r.RipUpdateInterval)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// RoutingTableRow struct represents rows of the ROUTING_TABLE table.
type RoutingTableRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    DestAddr	sql.NullInt32
    DestSubnetMask	sql.NullInt32
    NextHop	sql.NullInt32
    Metric	sql.NullInt16
    Age	sql.NullInt32
    Status	sql.NullByte
}

// IterateRoutingTable provide access to all rows of the ROUTING_TABLE matching given criteria.
func IterateRoutingTable(db *sql.DB, where string, callback func(v *RoutingTableRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,DEST_ADDR,DEST_SUBNET_MASK,NEXT_HOP,METRIC,AGE,STATUS FROM ROUTING_TABLE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r RoutingTableRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.DestAddr, &r.DestSubnetMask, &r.NextHop, &r.Metric, &r.Age, &r.Status)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeRoutingTable provide iterator to all rows of the ROUTING_TABLE matching given criteria.
func RangeRoutingTable(db *sql.DB, where string) iter.Seq2[*RoutingTableRow, error] {
	return func(yield func(v *RoutingTableRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,DEST_ADDR,DEST_SUBNET_MASK,NEXT_HOP,METRIC,AGE,STATUS FROM ROUTING_TABLE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r RoutingTableRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.DestAddr, &r.DestSubnetMask, &r.NextHop, &r.Metric, &r.Age, &r.Status)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SandboxInventoryRow struct represents rows of the SANDBOX_INVENTORY table.
type SandboxInventoryRow struct {
    DeviceShortID	uint
    SandboxEnabled	int8
}

// IterateSandboxInventory provide access to all rows of the SANDBOX_INVENTORY matching given criteria.
func IterateSandboxInventory(db *sql.DB, where string, callback func(v *SandboxInventoryRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,SANDBOX_ENABLED FROM SANDBOX_INVENTORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SandboxInventoryRow
        err := rows.Scan(&r.DeviceShortID, &r.SandboxEnabled)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSandboxInventory provide iterator to all rows of the SANDBOX_INVENTORY matching given criteria.
func RangeSandboxInventory(db *sql.DB, where string) iter.Seq2[*SandboxInventoryRow, error] {
	return func(yield func(v *SandboxInventoryRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,SANDBOX_ENABLED FROM SANDBOX_INVENTORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SandboxInventoryRow
	        err := rows.Scan(&r.DeviceShortID, &r.SandboxEnabled)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ScheduledDistributionRow struct represents rows of the SCHEDULED_DISTRIBUTION table.
type ScheduledDistributionRow struct {
    ID	uint
    Name	sql.NullString
    PackageType	sql.NullInt32
    PackageID	sql.NullString
    PackageVersion	sql.NullString
    StartTime	sql.NullTime
    LastDistribTime	sql.NullTime
    Status	sql.NullInt32
    Recurring	sql.NullByte
    DaysOfWeek	sql.NullInt32
    Hour	sql.NullInt32
    Minute	sql.NullInt32
}

// IterateScheduledDistribution provide access to all rows of the SCHEDULED_DISTRIBUTION matching given criteria.
func IterateScheduledDistribution(db *sql.DB, where string, callback func(v *ScheduledDistributionRow) error) error {
    query := "SELECT ID,NAME,PACKAGE_TYPE,PACKAGE_ID,PACKAGE_VERSION,START_TIME,LAST_DISTRIB_TIME,STATUS,RECURRING,DAYS_OF_WEEK,HOUR_,MINUTE_ FROM SCHEDULED_DISTRIBUTION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ScheduledDistributionRow
        err := rows.Scan(&r.ID, &r.Name, &r.PackageType, &r.PackageID, &r.PackageVersion, &r.StartTime, &r.LastDistribTime, &r.Status, &r.Recurring, &r.DaysOfWeek, &r.Hour, &r.Minute)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeScheduledDistribution provide iterator to all rows of the SCHEDULED_DISTRIBUTION matching given criteria.
func RangeScheduledDistribution(db *sql.DB, where string) iter.Seq2[*ScheduledDistributionRow, error] {
	return func(yield func(v *ScheduledDistributionRow, err error) bool) {
	    query := "SELECT ID,NAME,PACKAGE_TYPE,PACKAGE_ID,PACKAGE_VERSION,START_TIME,LAST_DISTRIB_TIME,STATUS,RECURRING,DAYS_OF_WEEK,HOUR_,MINUTE_ FROM SCHEDULED_DISTRIBUTION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ScheduledDistributionRow
	        err := rows.Scan(&r.ID, &r.Name, &r.PackageType, &r.PackageID, &r.PackageVersion, &r.StartTime, &r.LastDistribTime, &r.Status, &r.Recurring, &r.DaysOfWeek, &r.Hour, &r.Minute)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ScheduledDistributionDeviceRow struct represents rows of the SCHEDULED_DISTRIBUTION_DEVICE table.
type ScheduledDistributionDeviceRow struct {
    ScheduledDistributionID	sql.NullInt32
    TargetsID	sql.NullInt32
}

// IterateScheduledDistributionDevice provide access to all rows of the SCHEDULED_DISTRIBUTION_DEVICE matching given criteria.
func IterateScheduledDistributionDevice(db *sql.DB, where string, callback func(v *ScheduledDistributionDeviceRow) error) error {
    query := "SELECT SCHEDULED_DISTRIBUTION_ID,TARGETS_ID FROM SCHEDULED_DISTRIBUTION_DEVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ScheduledDistributionDeviceRow
        err := rows.Scan(&r.ScheduledDistributionID, &r.TargetsID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeScheduledDistributionDevice provide iterator to all rows of the SCHEDULED_DISTRIBUTION_DEVICE matching given criteria.
func RangeScheduledDistributionDevice(db *sql.DB, where string) iter.Seq2[*ScheduledDistributionDeviceRow, error] {
	return func(yield func(v *ScheduledDistributionDeviceRow, err error) bool) {
	    query := "SELECT SCHEDULED_DISTRIBUTION_ID,TARGETS_ID FROM SCHEDULED_DISTRIBUTION_DEVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ScheduledDistributionDeviceRow
	        err := rows.Scan(&r.ScheduledDistributionID, &r.TargetsID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ScheduledDistributionSegmentTargetRow struct represents rows of the SCHEDULED_DISTRIBUTION_SEGMENT_TARGET table.
type ScheduledDistributionSegmentTargetRow struct {
    ScheduledDistributionID	sql.NullInt32
    TargetsID	sql.NullInt32
}

// IterateScheduledDistributionSegmentTarget provide access to all rows of the SCHEDULED_DISTRIBUTION_SEGMENT_TARGET matching given criteria.
func IterateScheduledDistributionSegmentTarget(db *sql.DB, where string, callback func(v *ScheduledDistributionSegmentTargetRow) error) error {
    query := "SELECT SCHEDULED_DISTRIBUTION_ID,TARGETS_ID FROM SCHEDULED_DISTRIBUTION_SEGMENT_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ScheduledDistributionSegmentTargetRow
        err := rows.Scan(&r.ScheduledDistributionID, &r.TargetsID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeScheduledDistributionSegmentTarget provide iterator to all rows of the SCHEDULED_DISTRIBUTION_SEGMENT_TARGET matching given criteria.
func RangeScheduledDistributionSegmentTarget(db *sql.DB, where string) iter.Seq2[*ScheduledDistributionSegmentTargetRow, error] {
	return func(yield func(v *ScheduledDistributionSegmentTargetRow, err error) bool) {
	    query := "SELECT SCHEDULED_DISTRIBUTION_ID,TARGETS_ID FROM SCHEDULED_DISTRIBUTION_SEGMENT_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ScheduledDistributionSegmentTargetRow
	        err := rows.Scan(&r.ScheduledDistributionID, &r.TargetsID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ScheduleDefinitionRow struct represents rows of the SCHEDULE_DEFINITION table.
type ScheduleDefinitionRow struct {
    ID	uint
    Uuid	string
    Name	sql.NullString
    IterationID	uint
    Description	sql.NullString
}

// IterateScheduleDefinition provide access to all rows of the SCHEDULE_DEFINITION matching given criteria.
func IterateScheduleDefinition(db *sql.DB, where string, callback func(v *ScheduleDefinitionRow) error) error {
    query := "SELECT ID,UUID,NAME,ITERATION_ID,DESCRIPTION FROM SCHEDULE_DEFINITION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ScheduleDefinitionRow
        err := rows.Scan(&r.ID, &r.Uuid, &r.Name, &r.IterationID, &r.Description)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeScheduleDefinition provide iterator to all rows of the SCHEDULE_DEFINITION matching given criteria.
func RangeScheduleDefinition(db *sql.DB, where string) iter.Seq2[*ScheduleDefinitionRow, error] {
	return func(yield func(v *ScheduleDefinitionRow, err error) bool) {
	    query := "SELECT ID,UUID,NAME,ITERATION_ID,DESCRIPTION FROM SCHEDULE_DEFINITION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ScheduleDefinitionRow
	        err := rows.Scan(&r.ID, &r.Uuid, &r.Name, &r.IterationID, &r.Description)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ScheduleDetailRow struct represents rows of the SCHEDULE_DETAIL table.
type ScheduleDetailRow struct {
    ID	uint
    ScheduleType	sql.NullByte
    ScheduleName	sql.NullString
    JobName	sql.NullString
    Creator	sql.NullString
    StartDate	sql.NullTime
    EndDate	sql.NullTime
    LastRunningTime	sql.NullTime
    TriggerType	sql.NullByte
    MinInHour	sql.NullByte
    DayInWeek	sql.NullInt32
    DayInMonth	sql.NullByte
    MonthInYear	sql.NullByte
    ScheduleTime	sql.NullTime
}

// IterateScheduleDetail provide access to all rows of the SCHEDULE_DETAIL matching given criteria.
func IterateScheduleDetail(db *sql.DB, where string, callback func(v *ScheduleDetailRow) error) error {
    query := "SELECT ID,SCHEDULE_TYPE,SCHEDULE_NAME,JOB_NAME,CREATOR,START_DATE,END_DATE,LAST_RUNNING_TIME,TRIGGER_TYPE,MIN_IN_HOUR,DAY_IN_WEEK,DAY_IN_MONTH,MONTH_IN_YEAR,SCHEDULE_TIME FROM SCHEDULE_DETAIL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ScheduleDetailRow
        err := rows.Scan(&r.ID, &r.ScheduleType, &r.ScheduleName, &r.JobName, &r.Creator, &r.StartDate, &r.EndDate, &r.LastRunningTime, &r.TriggerType, &r.MinInHour, &r.DayInWeek, &r.DayInMonth, &r.MonthInYear, &r.ScheduleTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeScheduleDetail provide iterator to all rows of the SCHEDULE_DETAIL matching given criteria.
func RangeScheduleDetail(db *sql.DB, where string) iter.Seq2[*ScheduleDetailRow, error] {
	return func(yield func(v *ScheduleDetailRow, err error) bool) {
	    query := "SELECT ID,SCHEDULE_TYPE,SCHEDULE_NAME,JOB_NAME,CREATOR,START_DATE,END_DATE,LAST_RUNNING_TIME,TRIGGER_TYPE,MIN_IN_HOUR,DAY_IN_WEEK,DAY_IN_MONTH,MONTH_IN_YEAR,SCHEDULE_TIME FROM SCHEDULE_DETAIL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ScheduleDetailRow
	        err := rows.Scan(&r.ID, &r.ScheduleType, &r.ScheduleName, &r.JobName, &r.Creator, &r.StartDate, &r.EndDate, &r.LastRunningTime, &r.TriggerType, &r.MinInHour, &r.DayInWeek, &r.DayInMonth, &r.MonthInYear, &r.ScheduleTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ScheduleEntryRow struct represents rows of the SCHEDULE_ENTRY table.
type ScheduleEntryRow struct {
    ID	uint
    ScheduleID	uint
    StartTime	sql.NullInt32
    Duration	sql.NullInt32
    ExpireAfter	sql.NullInt32
    Monday	sql.NullByte
    Tuesday	sql.NullByte
    Wednesday	sql.NullByte
    Thursday	sql.NullByte
    Friday	sql.NullByte
    Saturday	sql.NullByte
    Sunday	sql.NullByte
    RecurrenceCount	sql.NullInt32
}

// IterateScheduleEntry provide access to all rows of the SCHEDULE_ENTRY matching given criteria.
func IterateScheduleEntry(db *sql.DB, where string, callback func(v *ScheduleEntryRow) error) error {
    query := "SELECT ID,SCHEDULE_ID,START_TIME,DURATION,EXPIRE_AFTER,MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY,RECURRENCE_COUNT FROM SCHEDULE_ENTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ScheduleEntryRow
        err := rows.Scan(&r.ID, &r.ScheduleID, &r.StartTime, &r.Duration, &r.ExpireAfter, &r.Monday, &r.Tuesday, &r.Wednesday, &r.Thursday, &r.Friday, &r.Saturday, &r.Sunday, &r.RecurrenceCount)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeScheduleEntry provide iterator to all rows of the SCHEDULE_ENTRY matching given criteria.
func RangeScheduleEntry(db *sql.DB, where string) iter.Seq2[*ScheduleEntryRow, error] {
	return func(yield func(v *ScheduleEntryRow, err error) bool) {
	    query := "SELECT ID,SCHEDULE_ID,START_TIME,DURATION,EXPIRE_AFTER,MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY,RECURRENCE_COUNT FROM SCHEDULE_ENTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ScheduleEntryRow
	        err := rows.Scan(&r.ID, &r.ScheduleID, &r.StartTime, &r.Duration, &r.ExpireAfter, &r.Monday, &r.Tuesday, &r.Wednesday, &r.Thursday, &r.Friday, &r.Saturday, &r.Sunday, &r.RecurrenceCount)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SecurityAssociationRow struct represents rows of the SECURITY_ASSOCIATION table.
type SecurityAssociationRow struct {
    ID	uint
    Name	sql.NullString
    DeviceShortID	sql.NullInt32
    Enable	sql.NullByte
    GreIpsecTransport	sql.NullByte
    IpsecGateway	sql.NullString
    TerminatedSecurityZoneID	sql.NullInt32
    KeyingMode	sql.NullInt32
    IkeModeProposalID	sql.NullInt32
    IkeModeSharedSecret	sql.NullString
    IkeModePeerID	sql.NullString
    ManualModeIncomingSpi	sql.NullInt32
    ManualModeOutgoingSpi	sql.NullInt32
    ManualModeEncryptionType	sql.NullInt32
    ManualModeEncryptionKey	sql.NullString
    ManualModeAuthType	sql.NullInt32
    ManualModeAuthKey	sql.NullString
    IpsecTunnel	sql.NullByte
    IpsecTunnelDestNetworkType	sql.NullInt32
    IpsecTunnelDestNetworkAddr	sql.NullString
    IpsecTunnelDestNetworkNamedIPAddrGroupID	sql.NullInt32
    IpsecTunnelLocalNetworkType	sql.NullInt32
    IpsecTunnelLocalNetworkAddr	sql.NullString
    IpsecTunnelLocalNetworkNamedIPAddrGroupID	sql.NullInt32
    VpnNatEnabled	sql.NullByte
    VpnNatIpaddr	sql.NullString
}

// IterateSecurityAssociation provide access to all rows of the SECURITY_ASSOCIATION matching given criteria.
func IterateSecurityAssociation(db *sql.DB, where string, callback func(v *SecurityAssociationRow) error) error {
    query := "SELECT ID,NAME,DEVICE_SHORT_ID,ENABLE,GRE_IPSEC_TRANSPORT,IPSEC_GATEWAY,TERMINATED_SECURITY_ZONE_ID,KEYING_MODE,IKE_MODE_PROPOSAL_ID,IKE_MODE_SHARED_SECRET,IKE_MODE_PEER_ID,MANUAL_MODE_INCOMING_SPI,MANUAL_MODE_OUTGOING_SPI,MANUAL_MODE_ENCRYPTION_TYPE,MANUAL_MODE_ENCRYPTION_KEY,MANUAL_MODE_AUTH_TYPE,MANUAL_MODE_AUTH_KEY,IPSEC_TUNNEL,IPSEC_TUNNEL_DEST_NETWORK_TYPE,IPSEC_TUNNEL_DEST_NETWORK_ADDR,IPSEC_TUNNEL_DEST_NETWORK_NAMED_IP_ADDR_GROUP_ID,IPSEC_TUNNEL_LOCAL_NETWORK_TYPE,IPSEC_TUNNEL_LOCAL_NETWORK_ADDR,IPSEC_TUNNEL_LOCAL_NETWORK_NAMED_IP_ADDR_GROUP_ID,VPN_NAT_ENABLED,VPN_NAT_IPADDR FROM SECURITY_ASSOCIATION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SecurityAssociationRow
        err := rows.Scan(&r.ID, &r.Name, &r.DeviceShortID, &r.Enable, &r.GreIpsecTransport, &r.IpsecGateway, &r.TerminatedSecurityZoneID, &r.KeyingMode, &r.IkeModeProposalID, &r.IkeModeSharedSecret, &r.IkeModePeerID, &r.ManualModeIncomingSpi, &r.ManualModeOutgoingSpi, &r.ManualModeEncryptionType, &r.ManualModeEncryptionKey, &r.ManualModeAuthType, &r.ManualModeAuthKey, &r.IpsecTunnel, &r.IpsecTunnelDestNetworkType, &r.IpsecTunnelDestNetworkAddr, &r.IpsecTunnelDestNetworkNamedIPAddrGroupID, &r.IpsecTunnelLocalNetworkType, &r.IpsecTunnelLocalNetworkAddr, &r.IpsecTunnelLocalNetworkNamedIPAddrGroupID, &r.VpnNatEnabled, &r.VpnNatIpaddr)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSecurityAssociation provide iterator to all rows of the SECURITY_ASSOCIATION matching given criteria.
func RangeSecurityAssociation(db *sql.DB, where string) iter.Seq2[*SecurityAssociationRow, error] {
	return func(yield func(v *SecurityAssociationRow, err error) bool) {
	    query := "SELECT ID,NAME,DEVICE_SHORT_ID,ENABLE,GRE_IPSEC_TRANSPORT,IPSEC_GATEWAY,TERMINATED_SECURITY_ZONE_ID,KEYING_MODE,IKE_MODE_PROPOSAL_ID,IKE_MODE_SHARED_SECRET,IKE_MODE_PEER_ID,MANUAL_MODE_INCOMING_SPI,MANUAL_MODE_OUTGOING_SPI,MANUAL_MODE_ENCRYPTION_TYPE,MANUAL_MODE_ENCRYPTION_KEY,MANUAL_MODE_AUTH_TYPE,MANUAL_MODE_AUTH_KEY,IPSEC_TUNNEL,IPSEC_TUNNEL_DEST_NETWORK_TYPE,IPSEC_TUNNEL_DEST_NETWORK_ADDR,IPSEC_TUNNEL_DEST_NETWORK_NAMED_IP_ADDR_GROUP_ID,IPSEC_TUNNEL_LOCAL_NETWORK_TYPE,IPSEC_TUNNEL_LOCAL_NETWORK_ADDR,IPSEC_TUNNEL_LOCAL_NETWORK_NAMED_IP_ADDR_GROUP_ID,VPN_NAT_ENABLED,VPN_NAT_IPADDR FROM SECURITY_ASSOCIATION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SecurityAssociationRow
	        err := rows.Scan(&r.ID, &r.Name, &r.DeviceShortID, &r.Enable, &r.GreIpsecTransport, &r.IpsecGateway, &r.TerminatedSecurityZoneID, &r.KeyingMode, &r.IkeModeProposalID, &r.IkeModeSharedSecret, &r.IkeModePeerID, &r.ManualModeIncomingSpi, &r.ManualModeOutgoingSpi, &r.ManualModeEncryptionType, &r.ManualModeEncryptionKey, &r.ManualModeAuthType, &r.ManualModeAuthKey, &r.IpsecTunnel, &r.IpsecTunnelDestNetworkType, &r.IpsecTunnelDestNetworkAddr, &r.IpsecTunnelDestNetworkNamedIPAddrGroupID, &r.IpsecTunnelLocalNetworkType, &r.IpsecTunnelLocalNetworkAddr, &r.IpsecTunnelLocalNetworkNamedIPAddrGroupID, &r.VpnNatEnabled, &r.VpnNatIpaddr)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SecurityPostureCategoryRow struct represents rows of the SECURITY_POSTURE_CATEGORY table.
type SecurityPostureCategoryRow struct {
    ProfileID	string
    CategoryID	string
    ActionSetID	string
    ActiveStatus	string
    Locked	sql.NullByte
    UseParentSettings	sql.NullByte
    Precedence	sql.NullString
}

// IterateSecurityPostureCategory provide access to all rows of the SECURITY_POSTURE_CATEGORY matching given criteria.
func IterateSecurityPostureCategory(db *sql.DB, where string, callback func(v *SecurityPostureCategoryRow) error) error {
    query := "SELECT PROFILE_ID,CATEGORY_ID,ACTION_SET_ID,ACTIVE_STATUS,LOCKED,USE_PARENT_SETTINGS,PRECEDENCE FROM SECURITY_POSTURE_CATEGORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SecurityPostureCategoryRow
        err := rows.Scan(&r.ProfileID, &r.CategoryID, &r.ActionSetID, &r.ActiveStatus, &r.Locked, &r.UseParentSettings, &r.Precedence)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSecurityPostureCategory provide iterator to all rows of the SECURITY_POSTURE_CATEGORY matching given criteria.
func RangeSecurityPostureCategory(db *sql.DB, where string) iter.Seq2[*SecurityPostureCategoryRow, error] {
	return func(yield func(v *SecurityPostureCategoryRow, err error) bool) {
	    query := "SELECT PROFILE_ID,CATEGORY_ID,ACTION_SET_ID,ACTIVE_STATUS,LOCKED,USE_PARENT_SETTINGS,PRECEDENCE FROM SECURITY_POSTURE_CATEGORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SecurityPostureCategoryRow
	        err := rows.Scan(&r.ProfileID, &r.CategoryID, &r.ActionSetID, &r.ActiveStatus, &r.Locked, &r.UseParentSettings, &r.Precedence)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SecurityZoneRow struct represents rows of the SECURITY_ZONE table.
type SecurityZoneRow struct {
    ID	uint
    Name	sql.NullString
    SecurityZoneUuid	sql.NullString
    DeviceShortID	sql.NullInt32
    VLANTagging	sql.NullByte
    OverrideMtu	sql.NullByte
    RatelimitBandwidth	sql.NullByte
    DosPrevention	sql.NullByte
    RestrictIPAddr	sql.NullByte
    VpnRouting	sql.NullByte
    VLANID	sql.NullInt32
    MaxInboundBandwidth	sql.NullInt32
    MaxOutboundBandwidth	sql.NullInt32
    IfMtu	sql.NullInt32
    RestrictedIPAddrGroupID	sql.NullInt32
    RestrictedIPAddrType	sql.NullInt32
    RestrictedIPAddress	sql.NullString
    Description	sql.NullString
}

// IterateSecurityZone provide access to all rows of the SECURITY_ZONE matching given criteria.
func IterateSecurityZone(db *sql.DB, where string, callback func(v *SecurityZoneRow) error) error {
    query := "SELECT ID,NAME,SECURITY_ZONE_UUID,DEVICE_SHORT_ID,VLAN_TAGGING,OVERRIDE_MTU,RATELIMIT_BANDWIDTH,DOS_PREVENTION,RESTRICT_IP_ADDR,VPN_ROUTING,VLAN_ID,MAX_INBOUND_BANDWIDTH,MAX_OUTBOUND_BANDWIDTH,IF_MTU,RESTRICTED_IP_ADDR_GROUP_ID,RESTRICTED_IP_ADDR_TYPE,RESTRICTED_IP_ADDRESS,DESCRIPTION FROM SECURITY_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SecurityZoneRow
        err := rows.Scan(&r.ID, &r.Name, &r.SecurityZoneUuid, &r.DeviceShortID, &r.VLANTagging, &r.OverrideMtu, &r.RatelimitBandwidth, &r.DosPrevention, &r.RestrictIPAddr, &r.VpnRouting, &r.VLANID, &r.MaxInboundBandwidth, &r.MaxOutboundBandwidth, &r.IfMtu, &r.RestrictedIPAddrGroupID, &r.RestrictedIPAddrType, &r.RestrictedIPAddress, &r.Description)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSecurityZone provide iterator to all rows of the SECURITY_ZONE matching given criteria.
func RangeSecurityZone(db *sql.DB, where string) iter.Seq2[*SecurityZoneRow, error] {
	return func(yield func(v *SecurityZoneRow, err error) bool) {
	    query := "SELECT ID,NAME,SECURITY_ZONE_UUID,DEVICE_SHORT_ID,VLAN_TAGGING,OVERRIDE_MTU,RATELIMIT_BANDWIDTH,DOS_PREVENTION,RESTRICT_IP_ADDR,VPN_ROUTING,VLAN_ID,MAX_INBOUND_BANDWIDTH,MAX_OUTBOUND_BANDWIDTH,IF_MTU,RESTRICTED_IP_ADDR_GROUP_ID,RESTRICTED_IP_ADDR_TYPE,RESTRICTED_IP_ADDRESS,DESCRIPTION FROM SECURITY_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SecurityZoneRow
	        err := rows.Scan(&r.ID, &r.Name, &r.SecurityZoneUuid, &r.DeviceShortID, &r.VLANTagging, &r.OverrideMtu, &r.RatelimitBandwidth, &r.DosPrevention, &r.RestrictIPAddr, &r.VpnRouting, &r.VLANID, &r.MaxInboundBandwidth, &r.MaxOutboundBandwidth, &r.IfMtu, &r.RestrictedIPAddrGroupID, &r.RestrictedIPAddrType, &r.RestrictedIPAddress, &r.Description)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SecurityZonePairRow struct represents rows of the SECURITY_ZONE_PAIR table.
type SecurityZonePairRow struct {
    ID	uint
    Name	sql.NullString
    Uuid	sql.NullString
    DeviceShortID	sql.NullInt32
    SrcZone	sql.NullInt32
    DstZone	sql.NullInt32
    Direction	sql.NullByte
    TwinID	sql.NullInt32
    ParentType	sql.NullByte
    TptSegmentUuid	sql.NullString
    Description	sql.NullString
    DeviceVsegID	sql.NullString
}

// IterateSecurityZonePair provide access to all rows of the SECURITY_ZONE_PAIR matching given criteria.
func IterateSecurityZonePair(db *sql.DB, where string, callback func(v *SecurityZonePairRow) error) error {
    query := "SELECT ID,NAME,UUID,DEVICE_SHORT_ID,SRC_ZONE,DST_ZONE,DIRECTION,TWIN_ID,PARENT_TYPE,TPT_SEGMENT_UUID,DESCRIPTION,DEVICE_VSEG_ID FROM SECURITY_ZONE_PAIR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SecurityZonePairRow
        err := rows.Scan(&r.ID, &r.Name, &r.Uuid, &r.DeviceShortID, &r.SrcZone, &r.DstZone, &r.Direction, &r.TwinID, &r.ParentType, &r.TptSegmentUuid, &r.Description, &r.DeviceVsegID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSecurityZonePair provide iterator to all rows of the SECURITY_ZONE_PAIR matching given criteria.
func RangeSecurityZonePair(db *sql.DB, where string) iter.Seq2[*SecurityZonePairRow, error] {
	return func(yield func(v *SecurityZonePairRow, err error) bool) {
	    query := "SELECT ID,NAME,UUID,DEVICE_SHORT_ID,SRC_ZONE,DST_ZONE,DIRECTION,TWIN_ID,PARENT_TYPE,TPT_SEGMENT_UUID,DESCRIPTION,DEVICE_VSEG_ID FROM SECURITY_ZONE_PAIR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SecurityZonePairRow
	        err := rows.Scan(&r.ID, &r.Name, &r.Uuid, &r.DeviceShortID, &r.SrcZone, &r.DstZone, &r.Direction, &r.TwinID, &r.ParentType, &r.TptSegmentUuid, &r.Description, &r.DeviceVsegID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SecurityZonePortRow struct represents rows of the SECURITY_ZONE_PORT table.
type SecurityZonePortRow struct {
    ID	uint
    SecurityZoneID	sql.NullInt32
    PortID	sql.NullString
    VLANTagged	sql.NullByte
}

// IterateSecurityZonePort provide access to all rows of the SECURITY_ZONE_PORT matching given criteria.
func IterateSecurityZonePort(db *sql.DB, where string, callback func(v *SecurityZonePortRow) error) error {
    query := "SELECT ID,SECURITY_ZONE_ID,PORT_ID,VLAN_TAGGED FROM SECURITY_ZONE_PORT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SecurityZonePortRow
        err := rows.Scan(&r.ID, &r.SecurityZoneID, &r.PortID, &r.VLANTagged)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSecurityZonePort provide iterator to all rows of the SECURITY_ZONE_PORT matching given criteria.
func RangeSecurityZonePort(db *sql.DB, where string) iter.Seq2[*SecurityZonePortRow, error] {
	return func(yield func(v *SecurityZonePortRow, err error) bool) {
	    query := "SELECT ID,SECURITY_ZONE_ID,PORT_ID,VLAN_TAGGED FROM SECURITY_ZONE_PORT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SecurityZonePortRow
	        err := rows.Scan(&r.ID, &r.SecurityZoneID, &r.PortID, &r.VLANTagged)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SegmentTargetRow struct represents rows of the SEGMENT_TARGET table.
type SegmentTargetRow struct {
    ID	uint
    SegmentUuid	sql.NullString
    SegmentID	sql.NullInt32
    HiPriority	sql.NullByte
    IsGroup	sql.NullByte
    LastDistrib	string
}

// IterateSegmentTarget provide access to all rows of the SEGMENT_TARGET matching given criteria.
func IterateSegmentTarget(db *sql.DB, where string, callback func(v *SegmentTargetRow) error) error {
    query := "SELECT ID,SEGMENT_UUID,SEGMENT_ID,HI_PRIORITY,IS_GROUP,LAST_DISTRIB FROM SEGMENT_TARGET"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SegmentTargetRow
        err := rows.Scan(&r.ID, &r.SegmentUuid, &r.SegmentID, &r.HiPriority, &r.IsGroup, &r.LastDistrib)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSegmentTarget provide iterator to all rows of the SEGMENT_TARGET matching given criteria.
func RangeSegmentTarget(db *sql.DB, where string) iter.Seq2[*SegmentTargetRow, error] {
	return func(yield func(v *SegmentTargetRow, err error) bool) {
	    query := "SELECT ID,SEGMENT_UUID,SEGMENT_ID,HI_PRIORITY,IS_GROUP,LAST_DISTRIB FROM SEGMENT_TARGET"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SegmentTargetRow
	        err := rows.Scan(&r.ID, &r.SegmentUuid, &r.SegmentID, &r.HiPriority, &r.IsGroup, &r.LastDistrib)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ServerAccessMethodRow struct represents rows of the SERVER_ACCESS_METHOD table.
type ServerAccessMethodRow struct {
    ServerType	string
    AccessMethod	string
    Urn	sql.NullString
    Url	sql.NullString
}

// IterateServerAccessMethod provide access to all rows of the SERVER_ACCESS_METHOD matching given criteria.
func IterateServerAccessMethod(db *sql.DB, where string, callback func(v *ServerAccessMethodRow) error) error {
    query := "SELECT SERVER_TYPE,ACCESS_METHOD,URN,URL FROM SERVER_ACCESS_METHOD"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ServerAccessMethodRow
        err := rows.Scan(&r.ServerType, &r.AccessMethod, &r.Urn, &r.Url)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeServerAccessMethod provide iterator to all rows of the SERVER_ACCESS_METHOD matching given criteria.
func RangeServerAccessMethod(db *sql.DB, where string) iter.Seq2[*ServerAccessMethodRow, error] {
	return func(yield func(v *ServerAccessMethodRow, err error) bool) {
	    query := "SELECT SERVER_TYPE,ACCESS_METHOD,URN,URL FROM SERVER_ACCESS_METHOD"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ServerAccessMethodRow
	        err := rows.Scan(&r.ServerType, &r.AccessMethod, &r.Urn, &r.Url)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ServiceConnectionRow struct represents rows of the SERVICE_CONNECTION table.
type ServiceConnectionRow struct {
    ID	uint
    ServiceType	uint
    Enabled	int8
    IPAddr1	int64
    IPAddr2	int64
    Port	uint
    Timeout	uint
    AuthMethod	uint
    NamedCertificateID	uint
    TrustAll	sql.NullByte
    Protocol	sql.NullString
    Username	sql.NullString
    Password	sql.NullString
}

// IterateServiceConnection provide access to all rows of the SERVICE_CONNECTION matching given criteria.
func IterateServiceConnection(db *sql.DB, where string, callback func(v *ServiceConnectionRow) error) error {
    query := "SELECT ID,SERVICE_TYPE,ENABLED,IP_ADDR_1,IP_ADDR_2,PORT,TIMEOUT,AUTH_METHOD,NAMED_CERTIFICATE_ID,TRUST_ALL,PROTOCOL,USERNAME,PASSWORD FROM SERVICE_CONNECTION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ServiceConnectionRow
        err := rows.Scan(&r.ID, &r.ServiceType, &r.Enabled, &r.IPAddr1, &r.IPAddr2, &r.Port, &r.Timeout, &r.AuthMethod, &r.NamedCertificateID, &r.TrustAll, &r.Protocol, &r.Username, &r.Password)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeServiceConnection provide iterator to all rows of the SERVICE_CONNECTION matching given criteria.
func RangeServiceConnection(db *sql.DB, where string) iter.Seq2[*ServiceConnectionRow, error] {
	return func(yield func(v *ServiceConnectionRow, err error) bool) {
	    query := "SELECT ID,SERVICE_TYPE,ENABLED,IP_ADDR_1,IP_ADDR_2,PORT,TIMEOUT,AUTH_METHOD,NAMED_CERTIFICATE_ID,TRUST_ALL,PROTOCOL,USERNAME,PASSWORD FROM SERVICE_CONNECTION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ServiceConnectionRow
	        err := rows.Scan(&r.ID, &r.ServiceType, &r.Enabled, &r.IPAddr1, &r.IPAddr2, &r.Port, &r.Timeout, &r.AuthMethod, &r.NamedCertificateID, &r.TrustAll, &r.Protocol, &r.Username, &r.Password)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ServiceGroupRow struct represents rows of the SERVICE_GROUP table.
type ServiceGroupRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    DefaultServiceGroup	sql.NullByte
    Name	sql.NullString
}

// IterateServiceGroup provide access to all rows of the SERVICE_GROUP matching given criteria.
func IterateServiceGroup(db *sql.DB, where string, callback func(v *ServiceGroupRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,DEFAULT_SERVICE_GROUP,NAME FROM SERVICE_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ServiceGroupRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.DefaultServiceGroup, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeServiceGroup provide iterator to all rows of the SERVICE_GROUP matching given criteria.
func RangeServiceGroup(db *sql.DB, where string) iter.Seq2[*ServiceGroupRow, error] {
	return func(yield func(v *ServiceGroupRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,DEFAULT_SERVICE_GROUP,NAME FROM SERVICE_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ServiceGroupRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.DefaultServiceGroup, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ServiceGroupMemberRow struct represents rows of the SERVICE_GROUP_MEMBER table.
type ServiceGroupMemberRow struct {
    ServiceID	uint
    ServiceGroupID	uint
}

// IterateServiceGroupMember provide access to all rows of the SERVICE_GROUP_MEMBER matching given criteria.
func IterateServiceGroupMember(db *sql.DB, where string, callback func(v *ServiceGroupMemberRow) error) error {
    query := "SELECT SERVICE_ID,SERVICE_GROUP_ID FROM SERVICE_GROUP_MEMBER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ServiceGroupMemberRow
        err := rows.Scan(&r.ServiceID, &r.ServiceGroupID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeServiceGroupMember provide iterator to all rows of the SERVICE_GROUP_MEMBER matching given criteria.
func RangeServiceGroupMember(db *sql.DB, where string) iter.Seq2[*ServiceGroupMemberRow, error] {
	return func(yield func(v *ServiceGroupMemberRow, err error) bool) {
	    query := "SELECT SERVICE_ID,SERVICE_GROUP_ID FROM SERVICE_GROUP_MEMBER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ServiceGroupMemberRow
	        err := rows.Scan(&r.ServiceID, &r.ServiceGroupID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SeverityRow struct represents rows of the SEVERITY table.
type SeverityRow struct {
    ID	uint
    Name	sql.NullString
}

// IterateSeverity provide access to all rows of the SEVERITY matching given criteria.
func IterateSeverity(db *sql.DB, where string, callback func(v *SeverityRow) error) error {
    query := "SELECT ID,NAME FROM SEVERITY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SeverityRow
        err := rows.Scan(&r.ID, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSeverity provide iterator to all rows of the SEVERITY matching given criteria.
func RangeSeverity(db *sql.DB, where string) iter.Seq2[*SeverityRow, error] {
	return func(yield func(v *SeverityRow, err error) bool) {
	    query := "SELECT ID,NAME FROM SEVERITY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SeverityRow
	        err := rows.Scan(&r.ID, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SignatureRow struct represents rows of the SIGNATURE table.
type SignatureRow struct {
    ID	string
    Number	int
    Description	sql.NullString
    Name	string
    Sigclass	string
    CategoryNumber	int
    ReqCapabilities	sql.NullString
    TaxonomyGroup	string
    TaxonomyLevel	string
    CveID	sql.NullString
    BugtraqID	sql.NullString
    NfAlarmID	sql.NullInt32
    Message	sql.NullString
    Protocol	string
    Severity	int
    UserDefined	string
    Type	string
    Inverted	int
    Deleted	string
    IpmOnly	sql.NullByte
    IterationID	string
    Version	sql.NullString
    PkgDir	string
    UpdateTime	int64
    FilterType	uint8
    ApplicationUuid	sql.NullString
    ApplicationName	sql.NullString
    Risk	uint8
    NgfwVersion	sql.NullString
    PkgID	sql.NullString
    SmsFilterNumber	sql.NullInt32
    OrigDvtFilterNumber	sql.NullString
    ReleasedPkg	sql.NullInt32
    ModifiedPkg	sql.NullInt32
    ZdiDisclosedPkg	sql.NullInt32
    SuspiciousUrl	sql.NullByte
    IsBreachedHost	sql.NullByte
    BreachType	sql.NullString
    BreachConfidence	sql.NullInt32
    BreachDirection	sql.NullString
    BreachSpecificName	sql.NullString
}

// IterateSignature provide access to all rows of the SIGNATURE matching given criteria.
func IterateSignature(db *sql.DB, where string, callback func(v *SignatureRow) error) error {
    query := "SELECT ID,NUMBER,DESCRIPTION,NAME,SIGCLASS,CATEGORY_NUMBER,REQ_CAPABILITIES,TAXONOMY_GROUP,TAXONOMY_LEVEL,CVE_ID,BUGTRAQ_ID,NF_ALARM_ID,MESSAGE,PROTOCOL,SEVERITY,USER_DEFINED,TYPE,INVERTED,DELETED,IPM_ONLY,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME,FILTER_TYPE,APPLICATION_UUID,APPLICATION_NAME,RISK,NGFW_VERSION,PKG_ID,SMS_FILTER_NUMBER,ORIG_DVT_FILTER_NUMBER,RELEASED_PKG,MODIFIED_PKG,ZDI_DISCLOSED_PKG,SUSPICIOUS_URL,IS_BREACHED_HOST,BREACH_TYPE,BREACH_CONFIDENCE,BREACH_DIRECTION,BREACH_SPECIFIC_NAME FROM SIGNATURE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SignatureRow
        err := rows.Scan(&r.ID, &r.Number, &r.Description, &r.Name, &r.Sigclass, &r.CategoryNumber, &r.ReqCapabilities, &r.TaxonomyGroup, &r.TaxonomyLevel, &r.CveID, &r.BugtraqID, &r.NfAlarmID, &r.Message, &r.Protocol, &r.Severity, &r.UserDefined, &r.Type, &r.Inverted, &r.Deleted, &r.IpmOnly, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime, &r.FilterType, &r.ApplicationUuid, &r.ApplicationName, &r.Risk, &r.NgfwVersion, &r.PkgID, &r.SmsFilterNumber, &r.OrigDvtFilterNumber, &r.ReleasedPkg, &r.ModifiedPkg, &r.ZdiDisclosedPkg, &r.SuspiciousUrl, &r.IsBreachedHost, &r.BreachType, &r.BreachConfidence, &r.BreachDirection, &r.BreachSpecificName)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSignature provide iterator to all rows of the SIGNATURE matching given criteria.
func RangeSignature(db *sql.DB, where string) iter.Seq2[*SignatureRow, error] {
	return func(yield func(v *SignatureRow, err error) bool) {
	    query := "SELECT ID,NUMBER,DESCRIPTION,NAME,SIGCLASS,CATEGORY_NUMBER,REQ_CAPABILITIES,TAXONOMY_GROUP,TAXONOMY_LEVEL,CVE_ID,BUGTRAQ_ID,NF_ALARM_ID,MESSAGE,PROTOCOL,SEVERITY,USER_DEFINED,TYPE,INVERTED,DELETED,IPM_ONLY,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME,FILTER_TYPE,APPLICATION_UUID,APPLICATION_NAME,RISK,NGFW_VERSION,PKG_ID,SMS_FILTER_NUMBER,ORIG_DVT_FILTER_NUMBER,RELEASED_PKG,MODIFIED_PKG,ZDI_DISCLOSED_PKG,SUSPICIOUS_URL,IS_BREACHED_HOST,BREACH_TYPE,BREACH_CONFIDENCE,BREACH_DIRECTION,BREACH_SPECIFIC_NAME FROM SIGNATURE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SignatureRow
	        err := rows.Scan(&r.ID, &r.Number, &r.Description, &r.Name, &r.Sigclass, &r.CategoryNumber, &r.ReqCapabilities, &r.TaxonomyGroup, &r.TaxonomyLevel, &r.CveID, &r.BugtraqID, &r.NfAlarmID, &r.Message, &r.Protocol, &r.Severity, &r.UserDefined, &r.Type, &r.Inverted, &r.Deleted, &r.IpmOnly, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime, &r.FilterType, &r.ApplicationUuid, &r.ApplicationName, &r.Risk, &r.NgfwVersion, &r.PkgID, &r.SmsFilterNumber, &r.OrigDvtFilterNumber, &r.ReleasedPkg, &r.ModifiedPkg, &r.ZdiDisclosedPkg, &r.SuspiciousUrl, &r.IsBreachedHost, &r.BreachType, &r.BreachConfidence, &r.BreachDirection, &r.BreachSpecificName)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SignatureAttrRow struct represents rows of the SIGNATURE_ATTR table.
type SignatureAttrRow struct {
    SigNumber	int
    AttrName	string
    AttrUuid	sql.NullString
    AttrValue	string
    AttrDisplayName	sql.NullString
}

// IterateSignatureAttr provide access to all rows of the SIGNATURE_ATTR matching given criteria.
func IterateSignatureAttr(db *sql.DB, where string, callback func(v *SignatureAttrRow) error) error {
    query := "SELECT SIG_NUMBER,ATTR_NAME,ATTR_UUID,ATTR_VALUE,ATTR_DISPLAY_NAME FROM SIGNATURE_ATTR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SignatureAttrRow
        err := rows.Scan(&r.SigNumber, &r.AttrName, &r.AttrUuid, &r.AttrValue, &r.AttrDisplayName)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSignatureAttr provide iterator to all rows of the SIGNATURE_ATTR matching given criteria.
func RangeSignatureAttr(db *sql.DB, where string) iter.Seq2[*SignatureAttrRow, error] {
	return func(yield func(v *SignatureAttrRow, err error) bool) {
	    query := "SELECT SIG_NUMBER,ATTR_NAME,ATTR_UUID,ATTR_VALUE,ATTR_DISPLAY_NAME FROM SIGNATURE_ATTR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SignatureAttrRow
	        err := rows.Scan(&r.SigNumber, &r.AttrName, &r.AttrUuid, &r.AttrValue, &r.AttrDisplayName)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SignatureZdiRow struct represents rows of the SIGNATURE_ZDI table.
type SignatureZdiRow struct {
    SignatureID	string
    ZdiID	string
}

// IterateSignatureZdi provide access to all rows of the SIGNATURE_ZDI matching given criteria.
func IterateSignatureZdi(db *sql.DB, where string, callback func(v *SignatureZdiRow) error) error {
    query := "SELECT SIGNATURE_ID,ZDI_ID FROM SIGNATURE_ZDI"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SignatureZdiRow
        err := rows.Scan(&r.SignatureID, &r.ZdiID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSignatureZdi provide iterator to all rows of the SIGNATURE_ZDI matching given criteria.
func RangeSignatureZdi(db *sql.DB, where string) iter.Seq2[*SignatureZdiRow, error] {
	return func(yield func(v *SignatureZdiRow, err error) bool) {
	    query := "SELECT SIGNATURE_ID,ZDI_ID FROM SIGNATURE_ZDI"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SignatureZdiRow
	        err := rows.Scan(&r.SignatureID, &r.ZdiID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SigTaxonomyLookupRow struct represents rows of the SIG_TAXONOMY_LOOKUP table.
type SigTaxonomyLookupRow struct {
    ID	string
    Number	int
    DotNotation	sql.NullString
    TaxonomyID	sql.NullInt32
    Major	sql.NullInt64
    Minor	sql.NullInt64
    Protocol	sql.NullInt64
    Platform	sql.NullInt64
}

// IterateSigTaxonomyLookup provide access to all rows of the SIG_TAXONOMY_LOOKUP matching given criteria.
func IterateSigTaxonomyLookup(db *sql.DB, where string, callback func(v *SigTaxonomyLookupRow) error) error {
    query := "SELECT ID,NUMBER,DOT_NOTATION,TAXONOMY_ID,MAJOR,MINOR,PROTOCOL,PLATFORM FROM SIG_TAXONOMY_LOOKUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SigTaxonomyLookupRow
        err := rows.Scan(&r.ID, &r.Number, &r.DotNotation, &r.TaxonomyID, &r.Major, &r.Minor, &r.Protocol, &r.Platform)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSigTaxonomyLookup provide iterator to all rows of the SIG_TAXONOMY_LOOKUP matching given criteria.
func RangeSigTaxonomyLookup(db *sql.DB, where string) iter.Seq2[*SigTaxonomyLookupRow, error] {
	return func(yield func(v *SigTaxonomyLookupRow, err error) bool) {
	    query := "SELECT ID,NUMBER,DOT_NOTATION,TAXONOMY_ID,MAJOR,MINOR,PROTOCOL,PLATFORM FROM SIG_TAXONOMY_LOOKUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SigTaxonomyLookupRow
	        err := rows.Scan(&r.ID, &r.Number, &r.DotNotation, &r.TaxonomyID, &r.Major, &r.Minor, &r.Protocol, &r.Platform)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SmsAuthTypeRow struct represents rows of the SMS_AUTH_TYPE table.
type SmsAuthTypeRow struct {
    ID	uint
    Type	sql.NullByte
}

// IterateSmsAuthType provide access to all rows of the SMS_AUTH_TYPE matching given criteria.
func IterateSmsAuthType(db *sql.DB, where string, callback func(v *SmsAuthTypeRow) error) error {
    query := "SELECT ID,TYPE FROM SMS_AUTH_TYPE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SmsAuthTypeRow
        err := rows.Scan(&r.ID, &r.Type)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSmsAuthType provide iterator to all rows of the SMS_AUTH_TYPE matching given criteria.
func RangeSmsAuthType(db *sql.DB, where string) iter.Seq2[*SmsAuthTypeRow, error] {
	return func(yield func(v *SmsAuthTypeRow, err error) bool) {
	    query := "SELECT ID,TYPE FROM SMS_AUTH_TYPE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SmsAuthTypeRow
	        err := rows.Scan(&r.ID, &r.Type)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SmsSnmpRequestSettingsRow struct represents rows of the SMS_SNMP_REQUEST_SETTINGS table.
type SmsSnmpRequestSettingsRow struct {
    ID	uint
    EnableRequests	int8
    SnmpVersion	uint16
    CommunityString	string
    EngineID	sql.NullString
    UserName	sql.NullString
    AuthProtocol	uint16
    AuthKey	sql.NullString
    PrivacyProtocol	uint16
    PrivacyKey	sql.NullString
}

// IterateSmsSnmpRequestSettings provide access to all rows of the SMS_SNMP_REQUEST_SETTINGS matching given criteria.
func IterateSmsSnmpRequestSettings(db *sql.DB, where string, callback func(v *SmsSnmpRequestSettingsRow) error) error {
    query := "SELECT ID,ENABLE_REQUESTS,SNMP_VERSION,COMMUNITY_STRING,ENGINE_ID,USER_NAME,AUTH_PROTOCOL,AUTH_KEY,PRIVACY_PROTOCOL,PRIVACY_KEY FROM SMS_SNMP_REQUEST_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SmsSnmpRequestSettingsRow
        err := rows.Scan(&r.ID, &r.EnableRequests, &r.SnmpVersion, &r.CommunityString, &r.EngineID, &r.UserName, &r.AuthProtocol, &r.AuthKey, &r.PrivacyProtocol, &r.PrivacyKey)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSmsSnmpRequestSettings provide iterator to all rows of the SMS_SNMP_REQUEST_SETTINGS matching given criteria.
func RangeSmsSnmpRequestSettings(db *sql.DB, where string) iter.Seq2[*SmsSnmpRequestSettingsRow, error] {
	return func(yield func(v *SmsSnmpRequestSettingsRow, err error) bool) {
	    query := "SELECT ID,ENABLE_REQUESTS,SNMP_VERSION,COMMUNITY_STRING,ENGINE_ID,USER_NAME,AUTH_PROTOCOL,AUTH_KEY,PRIVACY_PROTOCOL,PRIVACY_KEY FROM SMS_SNMP_REQUEST_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SmsSnmpRequestSettingsRow
	        err := rows.Scan(&r.ID, &r.EnableRequests, &r.SnmpVersion, &r.CommunityString, &r.EngineID, &r.UserName, &r.AuthProtocol, &r.AuthKey, &r.PrivacyProtocol, &r.PrivacyKey)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SmsSnmpTrapDestinationRow struct represents rows of the SMS_SNMP_TRAP_DESTINATION table.
type SmsSnmpTrapDestinationRow struct {
    ID	uint
    IPAddr1	int64
    IPAddr2	int64
    Port	uint
    SnmpVersion	uint16
    CommunityString	sql.NullString
    EngineID	sql.NullString
    UserName	sql.NullString
    AuthProtocol	uint16
    AuthKey	sql.NullString
    PrivacyProtocol	uint16
    PrivacyKey	sql.NullString
}

// IterateSmsSnmpTrapDestination provide access to all rows of the SMS_SNMP_TRAP_DESTINATION matching given criteria.
func IterateSmsSnmpTrapDestination(db *sql.DB, where string, callback func(v *SmsSnmpTrapDestinationRow) error) error {
    query := "SELECT ID,IP_ADDR_1,IP_ADDR_2,PORT,SNMP_VERSION,COMMUNITY_STRING,ENGINE_ID,USER_NAME,AUTH_PROTOCOL,AUTH_KEY,PRIVACY_PROTOCOL,PRIVACY_KEY FROM SMS_SNMP_TRAP_DESTINATION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SmsSnmpTrapDestinationRow
        err := rows.Scan(&r.ID, &r.IPAddr1, &r.IPAddr2, &r.Port, &r.SnmpVersion, &r.CommunityString, &r.EngineID, &r.UserName, &r.AuthProtocol, &r.AuthKey, &r.PrivacyProtocol, &r.PrivacyKey)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSmsSnmpTrapDestination provide iterator to all rows of the SMS_SNMP_TRAP_DESTINATION matching given criteria.
func RangeSmsSnmpTrapDestination(db *sql.DB, where string) iter.Seq2[*SmsSnmpTrapDestinationRow, error] {
	return func(yield func(v *SmsSnmpTrapDestinationRow, err error) bool) {
	    query := "SELECT ID,IP_ADDR_1,IP_ADDR_2,PORT,SNMP_VERSION,COMMUNITY_STRING,ENGINE_ID,USER_NAME,AUTH_PROTOCOL,AUTH_KEY,PRIVACY_PROTOCOL,PRIVACY_KEY FROM SMS_SNMP_TRAP_DESTINATION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SmsSnmpTrapDestinationRow
	        err := rows.Scan(&r.ID, &r.IPAddr1, &r.IPAddr2, &r.Port, &r.SnmpVersion, &r.CommunityString, &r.EngineID, &r.UserName, &r.AuthProtocol, &r.AuthKey, &r.PrivacyProtocol, &r.PrivacyKey)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SmsUserInfoRow struct represents rows of the SMS_USER_INFO table.
type SmsUserInfoRow struct {
    SmsUserID	string
    FirstName	string
    MiddleName	sql.NullString
    LastName	string
    Email	sql.NullString
    Phone	sql.NullString
}

// IterateSmsUserInfo provide access to all rows of the SMS_USER_INFO matching given criteria.
func IterateSmsUserInfo(db *sql.DB, where string, callback func(v *SmsUserInfoRow) error) error {
    query := "SELECT SMS_USER_ID,FIRST_NAME,MIDDLE_NAME,LAST_NAME,EMAIL,PHONE FROM SMS_USER_INFO"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SmsUserInfoRow
        err := rows.Scan(&r.SmsUserID, &r.FirstName, &r.MiddleName, &r.LastName, &r.Email, &r.Phone)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSmsUserInfo provide iterator to all rows of the SMS_USER_INFO matching given criteria.
func RangeSmsUserInfo(db *sql.DB, where string) iter.Seq2[*SmsUserInfoRow, error] {
	return func(yield func(v *SmsUserInfoRow, err error) bool) {
	    query := "SELECT SMS_USER_ID,FIRST_NAME,MIDDLE_NAME,LAST_NAME,EMAIL,PHONE FROM SMS_USER_INFO"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SmsUserInfoRow
	        err := rows.Scan(&r.SmsUserID, &r.FirstName, &r.MiddleName, &r.LastName, &r.Email, &r.Phone)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SnortMappingRow struct represents rows of the SNORT_MAPPING table.
type SnortMappingRow struct {
    TpSigNum	uint
    SnortSigNum	uint
    SnortSigRevision	sql.NullInt32
    SnortSigName	sql.NullString
    SnortSigClassification	sql.NullString
    SnortSigPriority	sql.NullInt16
    SnortSigProtocol	string
}

// IterateSnortMapping provide access to all rows of the SNORT_MAPPING matching given criteria.
func IterateSnortMapping(db *sql.DB, where string, callback func(v *SnortMappingRow) error) error {
    query := "SELECT TP_SIG_NUM,SNORT_SIG_NUM,SNORT_SIG_REVISION,SNORT_SIG_NAME,SNORT_SIG_CLASSIFICATION,SNORT_SIG_PRIORITY,SNORT_SIG_PROTOCOL FROM SNORT_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SnortMappingRow
        err := rows.Scan(&r.TpSigNum, &r.SnortSigNum, &r.SnortSigRevision, &r.SnortSigName, &r.SnortSigClassification, &r.SnortSigPriority, &r.SnortSigProtocol)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSnortMapping provide iterator to all rows of the SNORT_MAPPING matching given criteria.
func RangeSnortMapping(db *sql.DB, where string) iter.Seq2[*SnortMappingRow, error] {
	return func(yield func(v *SnortMappingRow, err error) bool) {
	    query := "SELECT TP_SIG_NUM,SNORT_SIG_NUM,SNORT_SIG_REVISION,SNORT_SIG_NAME,SNORT_SIG_CLASSIFICATION,SNORT_SIG_PRIORITY,SNORT_SIG_PROTOCOL FROM SNORT_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SnortMappingRow
	        err := rows.Scan(&r.TpSigNum, &r.SnortSigNum, &r.SnortSigRevision, &r.SnortSigName, &r.SnortSigClassification, &r.SnortSigPriority, &r.SnortSigProtocol)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslCategoryRow struct represents rows of the SSL_CATEGORY table.
type SslCategoryRow struct {
    SslCategoryID	uint
    TmcCategoryID	sql.NullInt32
    Name	sql.NullString
}

// IterateSslCategory provide access to all rows of the SSL_CATEGORY matching given criteria.
func IterateSslCategory(db *sql.DB, where string, callback func(v *SslCategoryRow) error) error {
    query := "SELECT SSL_CATEGORY_ID,TMC_CATEGORY_ID,NAME FROM SSL_CATEGORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslCategoryRow
        err := rows.Scan(&r.SslCategoryID, &r.TmcCategoryID, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslCategory provide iterator to all rows of the SSL_CATEGORY matching given criteria.
func RangeSslCategory(db *sql.DB, where string) iter.Seq2[*SslCategoryRow, error] {
	return func(yield func(v *SslCategoryRow, err error) bool) {
	    query := "SELECT SSL_CATEGORY_ID,TMC_CATEGORY_ID,NAME FROM SSL_CATEGORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslCategoryRow
	        err := rows.Scan(&r.SslCategoryID, &r.TmcCategoryID, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslClientDecryptRow struct represents rows of the SSL_CLIENT_DECRYPT table.
type SslClientDecryptRow struct {
    SslClientDecryptID	string
    Name	string
    Description	sql.NullString
    IterationID	uint
    LastUpdated	string
    Version	string
}

// IterateSslClientDecrypt provide access to all rows of the SSL_CLIENT_DECRYPT matching given criteria.
func IterateSslClientDecrypt(db *sql.DB, where string, callback func(v *SslClientDecryptRow) error) error {
    query := "SELECT SSL_CLIENT_DECRYPT_ID,NAME,DESCRIPTION,ITERATION_ID,LAST_UPDATED,VERSION FROM SSL_CLIENT_DECRYPT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslClientDecryptRow
        err := rows.Scan(&r.SslClientDecryptID, &r.Name, &r.Description, &r.IterationID, &r.LastUpdated, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslClientDecrypt provide iterator to all rows of the SSL_CLIENT_DECRYPT matching given criteria.
func RangeSslClientDecrypt(db *sql.DB, where string) iter.Seq2[*SslClientDecryptRow, error] {
	return func(yield func(v *SslClientDecryptRow, err error) bool) {
	    query := "SELECT SSL_CLIENT_DECRYPT_ID,NAME,DESCRIPTION,ITERATION_ID,LAST_UPDATED,VERSION FROM SSL_CLIENT_DECRYPT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslClientDecryptRow
	        err := rows.Scan(&r.SslClientDecryptID, &r.Name, &r.Description, &r.IterationID, &r.LastUpdated, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslClientDecryptCatRow struct represents rows of the SSL_CLIENT_DECRYPT_CAT table.
type SslClientDecryptCatRow struct {
    ID	uint
    SslCategoryID	uint
    SslClientDecryptID	string
}

// IterateSslClientDecryptCat provide access to all rows of the SSL_CLIENT_DECRYPT_CAT matching given criteria.
func IterateSslClientDecryptCat(db *sql.DB, where string, callback func(v *SslClientDecryptCatRow) error) error {
    query := "SELECT ID,SSL_CATEGORY_ID,SSL_CLIENT_DECRYPT_ID FROM SSL_CLIENT_DECRYPT_CAT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslClientDecryptCatRow
        err := rows.Scan(&r.ID, &r.SslCategoryID, &r.SslClientDecryptID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslClientDecryptCat provide iterator to all rows of the SSL_CLIENT_DECRYPT_CAT matching given criteria.
func RangeSslClientDecryptCat(db *sql.DB, where string) iter.Seq2[*SslClientDecryptCatRow, error] {
	return func(yield func(v *SslClientDecryptCatRow, err error) bool) {
	    query := "SELECT ID,SSL_CATEGORY_ID,SSL_CLIENT_DECRYPT_ID FROM SSL_CLIENT_DECRYPT_CAT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslClientDecryptCatRow
	        err := rows.Scan(&r.ID, &r.SslCategoryID, &r.SslClientDecryptID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslClientDecryptDomainRow struct represents rows of the SSL_CLIENT_DECRYPT_DOMAIN table.
type SslClientDecryptDomainRow struct {
    ID	uint
    SslClientDecryptID	string
    DecryptType	uint
    DomainName	string
    Version	uint
}

// IterateSslClientDecryptDomain provide access to all rows of the SSL_CLIENT_DECRYPT_DOMAIN matching given criteria.
func IterateSslClientDecryptDomain(db *sql.DB, where string, callback func(v *SslClientDecryptDomainRow) error) error {
    query := "SELECT ID,SSL_CLIENT_DECRYPT_ID,DECRYPT_TYPE,DOMAIN_NAME,VERSION FROM SSL_CLIENT_DECRYPT_DOMAIN"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslClientDecryptDomainRow
        err := rows.Scan(&r.ID, &r.SslClientDecryptID, &r.DecryptType, &r.DomainName, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslClientDecryptDomain provide iterator to all rows of the SSL_CLIENT_DECRYPT_DOMAIN matching given criteria.
func RangeSslClientDecryptDomain(db *sql.DB, where string) iter.Seq2[*SslClientDecryptDomainRow, error] {
	return func(yield func(v *SslClientDecryptDomainRow, err error) bool) {
	    query := "SELECT ID,SSL_CLIENT_DECRYPT_ID,DECRYPT_TYPE,DOMAIN_NAME,VERSION FROM SSL_CLIENT_DECRYPT_DOMAIN"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslClientDecryptDomainRow
	        err := rows.Scan(&r.ID, &r.SslClientDecryptID, &r.DecryptType, &r.DomainName, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslClientDecryptNamedObjRow struct represents rows of the SSL_CLIENT_DECRYPT_NAMED_OBJ table.
type SslClientDecryptNamedObjRow struct {
    ID	uint
    SslClientDecryptID	string
    NamedObjID	int
    Name	sql.NullString
    Version	uint
}

// IterateSslClientDecryptNamedObj provide access to all rows of the SSL_CLIENT_DECRYPT_NAMED_OBJ matching given criteria.
func IterateSslClientDecryptNamedObj(db *sql.DB, where string, callback func(v *SslClientDecryptNamedObjRow) error) error {
    query := "SELECT ID,SSL_CLIENT_DECRYPT_ID,NAMED_OBJ_ID,NAME,VERSION FROM SSL_CLIENT_DECRYPT_NAMED_OBJ"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslClientDecryptNamedObjRow
        err := rows.Scan(&r.ID, &r.SslClientDecryptID, &r.NamedObjID, &r.Name, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslClientDecryptNamedObj provide iterator to all rows of the SSL_CLIENT_DECRYPT_NAMED_OBJ matching given criteria.
func RangeSslClientDecryptNamedObj(db *sql.DB, where string) iter.Seq2[*SslClientDecryptNamedObjRow, error] {
	return func(yield func(v *SslClientDecryptNamedObjRow, err error) bool) {
	    query := "SELECT ID,SSL_CLIENT_DECRYPT_ID,NAMED_OBJ_ID,NAME,VERSION FROM SSL_CLIENT_DECRYPT_NAMED_OBJ"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslClientDecryptNamedObjRow
	        err := rows.Scan(&r.ID, &r.SslClientDecryptID, &r.NamedObjID, &r.Name, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslClientDecryptUserGroupRow struct represents rows of the SSL_CLIENT_DECRYPT_USER_GROUP table.
type SslClientDecryptUserGroupRow struct {
    UserGroupsIDFk	uint
    SslClientDecryptIDFk	string
}

// IterateSslClientDecryptUserGroup provide access to all rows of the SSL_CLIENT_DECRYPT_USER_GROUP matching given criteria.
func IterateSslClientDecryptUserGroup(db *sql.DB, where string, callback func(v *SslClientDecryptUserGroupRow) error) error {
    query := "SELECT USER_GROUPS_ID_FK,SSL_CLIENT_DECRYPT_ID_FK FROM SSL_CLIENT_DECRYPT_USER_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslClientDecryptUserGroupRow
        err := rows.Scan(&r.UserGroupsIDFk, &r.SslClientDecryptIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslClientDecryptUserGroup provide iterator to all rows of the SSL_CLIENT_DECRYPT_USER_GROUP matching given criteria.
func RangeSslClientDecryptUserGroup(db *sql.DB, where string) iter.Seq2[*SslClientDecryptUserGroupRow, error] {
	return func(yield func(v *SslClientDecryptUserGroupRow, err error) bool) {
	    query := "SELECT USER_GROUPS_ID_FK,SSL_CLIENT_DECRYPT_ID_FK FROM SSL_CLIENT_DECRYPT_USER_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslClientDecryptUserGroupRow
	        err := rows.Scan(&r.UserGroupsIDFk, &r.SslClientDecryptIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslClientProxyRow struct represents rows of the SSL_CLIENT_PROXY table.
type SslClientProxyRow struct {
    SslClientProxyID	string
    Name	string
    Description	sql.NullString
    NamedCertificateID	int
    ServiceNamedObjID	sql.NullInt32
    MinKeyLength	sql.NullInt32
    LoggingEnabled	int8
    TcpResetEnabled	int8
    BlockInvCertEnabled	int8
    BlockExpCertEnabled	int8
    DowngradeHtt2Enabled	int8
    IterationID	uint
    LastUpdated	string
    Version	string
}

// IterateSslClientProxy provide access to all rows of the SSL_CLIENT_PROXY matching given criteria.
func IterateSslClientProxy(db *sql.DB, where string, callback func(v *SslClientProxyRow) error) error {
    query := "SELECT SSL_CLIENT_PROXY_ID,NAME,DESCRIPTION,NAMED_CERTIFICATE_ID,SERVICE_NAMED_OBJ_ID,MIN_KEY_LENGTH,LOGGING_ENABLED,TCP_RESET_ENABLED,BLOCK_INV_CERT_ENABLED,BLOCK_EXP_CERT_ENABLED,DOWNGRADE_HTT2_ENABLED,ITERATION_ID,LAST_UPDATED,VERSION FROM SSL_CLIENT_PROXY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslClientProxyRow
        err := rows.Scan(&r.SslClientProxyID, &r.Name, &r.Description, &r.NamedCertificateID, &r.ServiceNamedObjID, &r.MinKeyLength, &r.LoggingEnabled, &r.TcpResetEnabled, &r.BlockInvCertEnabled, &r.BlockExpCertEnabled, &r.DowngradeHtt2Enabled, &r.IterationID, &r.LastUpdated, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslClientProxy provide iterator to all rows of the SSL_CLIENT_PROXY matching given criteria.
func RangeSslClientProxy(db *sql.DB, where string) iter.Seq2[*SslClientProxyRow, error] {
	return func(yield func(v *SslClientProxyRow, err error) bool) {
	    query := "SELECT SSL_CLIENT_PROXY_ID,NAME,DESCRIPTION,NAMED_CERTIFICATE_ID,SERVICE_NAMED_OBJ_ID,MIN_KEY_LENGTH,LOGGING_ENABLED,TCP_RESET_ENABLED,BLOCK_INV_CERT_ENABLED,BLOCK_EXP_CERT_ENABLED,DOWNGRADE_HTT2_ENABLED,ITERATION_ID,LAST_UPDATED,VERSION FROM SSL_CLIENT_PROXY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslClientProxyRow
	        err := rows.Scan(&r.SslClientProxyID, &r.Name, &r.Description, &r.NamedCertificateID, &r.ServiceNamedObjID, &r.MinKeyLength, &r.LoggingEnabled, &r.TcpResetEnabled, &r.BlockInvCertEnabled, &r.BlockExpCertEnabled, &r.DowngradeHtt2Enabled, &r.IterationID, &r.LastUpdated, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslClientProxyCipherSuiteRow struct represents rows of the SSL_CLIENT_PROXY_CIPHER_SUITE table.
type SslClientProxyCipherSuiteRow struct {
    ID	uint
    SslClientProxyID	string
    SslCipherIanaID	sql.NullInt32
}

// IterateSslClientProxyCipherSuite provide access to all rows of the SSL_CLIENT_PROXY_CIPHER_SUITE matching given criteria.
func IterateSslClientProxyCipherSuite(db *sql.DB, where string, callback func(v *SslClientProxyCipherSuiteRow) error) error {
    query := "SELECT ID,SSL_CLIENT_PROXY_ID,SSL_CIPHER_IANA_ID FROM SSL_CLIENT_PROXY_CIPHER_SUITE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslClientProxyCipherSuiteRow
        err := rows.Scan(&r.ID, &r.SslClientProxyID, &r.SslCipherIanaID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslClientProxyCipherSuite provide iterator to all rows of the SSL_CLIENT_PROXY_CIPHER_SUITE matching given criteria.
func RangeSslClientProxyCipherSuite(db *sql.DB, where string) iter.Seq2[*SslClientProxyCipherSuiteRow, error] {
	return func(yield func(v *SslClientProxyCipherSuiteRow, err error) bool) {
	    query := "SELECT ID,SSL_CLIENT_PROXY_ID,SSL_CIPHER_IANA_ID FROM SSL_CLIENT_PROXY_CIPHER_SUITE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslClientProxyCipherSuiteRow
	        err := rows.Scan(&r.ID, &r.SslClientProxyID, &r.SslCipherIanaID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslClientProxyPortRow struct represents rows of the SSL_CLIENT_PROXY_PORT table.
type SslClientProxyPortRow struct {
    ID	uint
    SslClientProxyID	string
    ProtocolType	string
    StartPort	uint
    EndPort	sql.NullInt32
    Version	uint
}

// IterateSslClientProxyPort provide access to all rows of the SSL_CLIENT_PROXY_PORT matching given criteria.
func IterateSslClientProxyPort(db *sql.DB, where string, callback func(v *SslClientProxyPortRow) error) error {
    query := "SELECT ID,SSL_CLIENT_PROXY_ID,PROTOCOL_TYPE,START_PORT,END_PORT,VERSION FROM SSL_CLIENT_PROXY_PORT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslClientProxyPortRow
        err := rows.Scan(&r.ID, &r.SslClientProxyID, &r.ProtocolType, &r.StartPort, &r.EndPort, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslClientProxyPort provide iterator to all rows of the SSL_CLIENT_PROXY_PORT matching given criteria.
func RangeSslClientProxyPort(db *sql.DB, where string) iter.Seq2[*SslClientProxyPortRow, error] {
	return func(yield func(v *SslClientProxyPortRow, err error) bool) {
	    query := "SELECT ID,SSL_CLIENT_PROXY_ID,PROTOCOL_TYPE,START_PORT,END_PORT,VERSION FROM SSL_CLIENT_PROXY_PORT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslClientProxyPortRow
	        err := rows.Scan(&r.ID, &r.SslClientProxyID, &r.ProtocolType, &r.StartPort, &r.EndPort, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslClientProxyProtocolRow struct represents rows of the SSL_CLIENT_PROXY_PROTOCOL table.
type SslClientProxyProtocolRow struct {
    ID	uint
    SslClientProxyID	string
    SslProtocolType	string
}

// IterateSslClientProxyProtocol provide access to all rows of the SSL_CLIENT_PROXY_PROTOCOL matching given criteria.
func IterateSslClientProxyProtocol(db *sql.DB, where string, callback func(v *SslClientProxyProtocolRow) error) error {
    query := "SELECT ID,SSL_CLIENT_PROXY_ID,SSL_PROTOCOL_TYPE FROM SSL_CLIENT_PROXY_PROTOCOL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslClientProxyProtocolRow
        err := rows.Scan(&r.ID, &r.SslClientProxyID, &r.SslProtocolType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslClientProxyProtocol provide iterator to all rows of the SSL_CLIENT_PROXY_PROTOCOL matching given criteria.
func RangeSslClientProxyProtocol(db *sql.DB, where string) iter.Seq2[*SslClientProxyProtocolRow, error] {
	return func(yield func(v *SslClientProxyProtocolRow, err error) bool) {
	    query := "SELECT ID,SSL_CLIENT_PROXY_ID,SSL_PROTOCOL_TYPE FROM SSL_CLIENT_PROXY_PROTOCOL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslClientProxyProtocolRow
	        err := rows.Scan(&r.ID, &r.SslClientProxyID, &r.SslProtocolType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslClientProxyUserGroupRow struct represents rows of the SSL_CLIENT_PROXY_USER_GROUP table.
type SslClientProxyUserGroupRow struct {
    UserGroupsIDFk	uint
    SslClientProxyIDFk	string
}

// IterateSslClientProxyUserGroup provide access to all rows of the SSL_CLIENT_PROXY_USER_GROUP matching given criteria.
func IterateSslClientProxyUserGroup(db *sql.DB, where string, callback func(v *SslClientProxyUserGroupRow) error) error {
    query := "SELECT USER_GROUPS_ID_FK,SSL_CLIENT_PROXY_ID_FK FROM SSL_CLIENT_PROXY_USER_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslClientProxyUserGroupRow
        err := rows.Scan(&r.UserGroupsIDFk, &r.SslClientProxyIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslClientProxyUserGroup provide iterator to all rows of the SSL_CLIENT_PROXY_USER_GROUP matching given criteria.
func RangeSslClientProxyUserGroup(db *sql.DB, where string) iter.Seq2[*SslClientProxyUserGroupRow, error] {
	return func(yield func(v *SslClientProxyUserGroupRow, err error) bool) {
	    query := "SELECT USER_GROUPS_ID_FK,SSL_CLIENT_PROXY_ID_FK FROM SSL_CLIENT_PROXY_USER_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslClientProxyUserGroupRow
	        err := rows.Scan(&r.UserGroupsIDFk, &r.SslClientProxyIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslClientTruststoreRow struct represents rows of the SSL_CLIENT_TRUSTSTORE table.
type SslClientTruststoreRow struct {
    SslClientTruststoreID	string
    Name	string
    Description	sql.NullString
    IncludeDefaultCaEnabled	sql.NullByte
    IterationID	uint
    LastUpdated	string
    Version	string
}

// IterateSslClientTruststore provide access to all rows of the SSL_CLIENT_TRUSTSTORE matching given criteria.
func IterateSslClientTruststore(db *sql.DB, where string, callback func(v *SslClientTruststoreRow) error) error {
    query := "SELECT SSL_CLIENT_TRUSTSTORE_ID,NAME,DESCRIPTION,INCLUDE_DEFAULT_CA_ENABLED,ITERATION_ID,LAST_UPDATED,VERSION FROM SSL_CLIENT_TRUSTSTORE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslClientTruststoreRow
        err := rows.Scan(&r.SslClientTruststoreID, &r.Name, &r.Description, &r.IncludeDefaultCaEnabled, &r.IterationID, &r.LastUpdated, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslClientTruststore provide iterator to all rows of the SSL_CLIENT_TRUSTSTORE matching given criteria.
func RangeSslClientTruststore(db *sql.DB, where string) iter.Seq2[*SslClientTruststoreRow, error] {
	return func(yield func(v *SslClientTruststoreRow, err error) bool) {
	    query := "SELECT SSL_CLIENT_TRUSTSTORE_ID,NAME,DESCRIPTION,INCLUDE_DEFAULT_CA_ENABLED,ITERATION_ID,LAST_UPDATED,VERSION FROM SSL_CLIENT_TRUSTSTORE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslClientTruststoreRow
	        err := rows.Scan(&r.SslClientTruststoreID, &r.Name, &r.Description, &r.IncludeDefaultCaEnabled, &r.IterationID, &r.LastUpdated, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslClientTruststoreCertificatesRow struct represents rows of the SSL_CLIENT_TRUSTSTORE_CERTIFICATES table.
type SslClientTruststoreCertificatesRow struct {
    SslClientTruststoreID	string
    NamedCertificateID	int
}

// IterateSslClientTruststoreCertificates provide access to all rows of the SSL_CLIENT_TRUSTSTORE_CERTIFICATES matching given criteria.
func IterateSslClientTruststoreCertificates(db *sql.DB, where string, callback func(v *SslClientTruststoreCertificatesRow) error) error {
    query := "SELECT SSL_CLIENT_TRUSTSTORE_ID,NAMED_CERTIFICATE_ID FROM SSL_CLIENT_TRUSTSTORE_CERTIFICATES"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslClientTruststoreCertificatesRow
        err := rows.Scan(&r.SslClientTruststoreID, &r.NamedCertificateID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslClientTruststoreCertificates provide iterator to all rows of the SSL_CLIENT_TRUSTSTORE_CERTIFICATES matching given criteria.
func RangeSslClientTruststoreCertificates(db *sql.DB, where string) iter.Seq2[*SslClientTruststoreCertificatesRow, error] {
	return func(yield func(v *SslClientTruststoreCertificatesRow, err error) bool) {
	    query := "SELECT SSL_CLIENT_TRUSTSTORE_ID,NAMED_CERTIFICATE_ID FROM SSL_CLIENT_TRUSTSTORE_CERTIFICATES"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslClientTruststoreCertificatesRow
	        err := rows.Scan(&r.SslClientTruststoreID, &r.NamedCertificateID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslClientTrustStoreUserGroupRow struct represents rows of the SSL_CLIENT_TRUST_STORE_USER_GROUP table.
type SslClientTrustStoreUserGroupRow struct {
    UserGroupsIDFk	uint
    SslClientTruststoreIDFk	string
}

// IterateSslClientTrustStoreUserGroup provide access to all rows of the SSL_CLIENT_TRUST_STORE_USER_GROUP matching given criteria.
func IterateSslClientTrustStoreUserGroup(db *sql.DB, where string, callback func(v *SslClientTrustStoreUserGroupRow) error) error {
    query := "SELECT USER_GROUPS_ID_FK,SSL_CLIENT_TRUSTSTORE_ID_FK FROM SSL_CLIENT_TRUST_STORE_USER_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslClientTrustStoreUserGroupRow
        err := rows.Scan(&r.UserGroupsIDFk, &r.SslClientTruststoreIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslClientTrustStoreUserGroup provide iterator to all rows of the SSL_CLIENT_TRUST_STORE_USER_GROUP matching given criteria.
func RangeSslClientTrustStoreUserGroup(db *sql.DB, where string) iter.Seq2[*SslClientTrustStoreUserGroupRow, error] {
	return func(yield func(v *SslClientTrustStoreUserGroupRow, err error) bool) {
	    query := "SELECT USER_GROUPS_ID_FK,SSL_CLIENT_TRUSTSTORE_ID_FK FROM SSL_CLIENT_TRUST_STORE_USER_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslClientTrustStoreUserGroupRow
	        err := rows.Scan(&r.UserGroupsIDFk, &r.SslClientTruststoreIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslDeviceGlobalSettingsRow struct represents rows of the SSL_DEVICE_GLOBAL_SETTINGS table.
type SslDeviceGlobalSettingsRow struct {
    ID	uint
    Version	uint
    DeviceShortID	uint
    SslInspectionEnabled	int8
    SslClientInspectionEnabled	int8
    PrivateKeyPersistEnabled	int8
}

// IterateSslDeviceGlobalSettings provide access to all rows of the SSL_DEVICE_GLOBAL_SETTINGS matching given criteria.
func IterateSslDeviceGlobalSettings(db *sql.DB, where string, callback func(v *SslDeviceGlobalSettingsRow) error) error {
    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,SSL_INSPECTION_ENABLED,SSL_CLIENT_INSPECTION_ENABLED,PRIVATE_KEY_PERSIST_ENABLED FROM SSL_DEVICE_GLOBAL_SETTINGS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslDeviceGlobalSettingsRow
        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.SslInspectionEnabled, &r.SslClientInspectionEnabled, &r.PrivateKeyPersistEnabled)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslDeviceGlobalSettings provide iterator to all rows of the SSL_DEVICE_GLOBAL_SETTINGS matching given criteria.
func RangeSslDeviceGlobalSettings(db *sql.DB, where string) iter.Seq2[*SslDeviceGlobalSettingsRow, error] {
	return func(yield func(v *SslDeviceGlobalSettingsRow, err error) bool) {
	    query := "SELECT ID,VERSION,DEVICE_SHORT_ID,SSL_INSPECTION_ENABLED,SSL_CLIENT_INSPECTION_ENABLED,PRIVATE_KEY_PERSIST_ENABLED FROM SSL_DEVICE_GLOBAL_SETTINGS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslDeviceGlobalSettingsRow
	        err := rows.Scan(&r.ID, &r.Version, &r.DeviceShortID, &r.SslInspectionEnabled, &r.SslClientInspectionEnabled, &r.PrivateKeyPersistEnabled)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslPerformanceStatsRow struct represents rows of the SSL_PERFORMANCE_STATS table.
type SslPerformanceStatsRow struct {
    ID	uint64
    DeviceShortID	uint
    DeviceTime	int64
    SmsTime	int64
    HttpProxyCurConn	int64
    HttpProxyTotConn	int64
    HttpProxyServConn	int64
    TotCurConn	int64
    TotNewConn	int64
    TotNewL4Conn	int64
    TotNewL7Conn	int64
    TotNewNatConn	int64
    TotNewSslConn	int64
    TotNewL7Req	int64
    TotBytes	int64
}

// IterateSslPerformanceStats provide access to all rows of the SSL_PERFORMANCE_STATS matching given criteria.
func IterateSslPerformanceStats(db *sql.DB, where string, callback func(v *SslPerformanceStatsRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,DEVICE_TIME,SMS_TIME,HTTP_PROXY_CUR_CONN,HTTP_PROXY_TOT_CONN,HTTP_PROXY_SERV_CONN,TOT_CUR_CONN,TOT_NEW_CONN,TOT_NEW_L4_CONN,TOT_NEW_L7_CONN,TOT_NEW_NAT_CONN,TOT_NEW_SSL_CONN,TOT_NEW_L7_REQ,TOT_BYTES FROM SSL_PERFORMANCE_STATS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslPerformanceStatsRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.DeviceTime, &r.SmsTime, &r.HttpProxyCurConn, &r.HttpProxyTotConn, &r.HttpProxyServConn, &r.TotCurConn, &r.TotNewConn, &r.TotNewL4Conn, &r.TotNewL7Conn, &r.TotNewNatConn, &r.TotNewSslConn, &r.TotNewL7Req, &r.TotBytes)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslPerformanceStats provide iterator to all rows of the SSL_PERFORMANCE_STATS matching given criteria.
func RangeSslPerformanceStats(db *sql.DB, where string) iter.Seq2[*SslPerformanceStatsRow, error] {
	return func(yield func(v *SslPerformanceStatsRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,DEVICE_TIME,SMS_TIME,HTTP_PROXY_CUR_CONN,HTTP_PROXY_TOT_CONN,HTTP_PROXY_SERV_CONN,TOT_CUR_CONN,TOT_NEW_CONN,TOT_NEW_L4_CONN,TOT_NEW_L7_CONN,TOT_NEW_NAT_CONN,TOT_NEW_SSL_CONN,TOT_NEW_L7_REQ,TOT_BYTES FROM SSL_PERFORMANCE_STATS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslPerformanceStatsRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.DeviceTime, &r.SmsTime, &r.HttpProxyCurConn, &r.HttpProxyTotConn, &r.HttpProxyServConn, &r.TotCurConn, &r.TotNewConn, &r.TotNewL4Conn, &r.TotNewL7Conn, &r.TotNewNatConn, &r.TotNewSslConn, &r.TotNewL7Req, &r.TotBytes)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslPortTrafficStatsRow struct represents rows of the SSL_PORT_TRAFFIC_STATS table.
type SslPortTrafficStatsRow struct {
    ID	uint64
    DeviceID	string
    PortID	string
    SmsTime	int64
    DeviceTime	int64
    InOctets	int64
    OutOctets	int64
    InPkts	int64
    OutPkts	int64
    InErrs	int64
    OutErrs	int64
    InOtherErrs	int64
    OutOtherErrs	int64
}

// IterateSslPortTrafficStats provide access to all rows of the SSL_PORT_TRAFFIC_STATS matching given criteria.
func IterateSslPortTrafficStats(db *sql.DB, where string, callback func(v *SslPortTrafficStatsRow) error) error {
    query := "SELECT ID,DEVICE_ID,PORT_ID,SMS_TIME,DEVICE_TIME,IN_OCTETS,OUT_OCTETS,IN_PKTS,OUT_PKTS,IN_ERRS,OUT_ERRS,IN_OTHER_ERRS,OUT_OTHER_ERRS FROM SSL_PORT_TRAFFIC_STATS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslPortTrafficStatsRow
        err := rows.Scan(&r.ID, &r.DeviceID, &r.PortID, &r.SmsTime, &r.DeviceTime, &r.InOctets, &r.OutOctets, &r.InPkts, &r.OutPkts, &r.InErrs, &r.OutErrs, &r.InOtherErrs, &r.OutOtherErrs)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslPortTrafficStats provide iterator to all rows of the SSL_PORT_TRAFFIC_STATS matching given criteria.
func RangeSslPortTrafficStats(db *sql.DB, where string) iter.Seq2[*SslPortTrafficStatsRow, error] {
	return func(yield func(v *SslPortTrafficStatsRow, err error) bool) {
	    query := "SELECT ID,DEVICE_ID,PORT_ID,SMS_TIME,DEVICE_TIME,IN_OCTETS,OUT_OCTETS,IN_PKTS,OUT_PKTS,IN_ERRS,OUT_ERRS,IN_OTHER_ERRS,OUT_OTHER_ERRS FROM SSL_PORT_TRAFFIC_STATS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslPortTrafficStatsRow
	        err := rows.Scan(&r.ID, &r.DeviceID, &r.PortID, &r.SmsTime, &r.DeviceTime, &r.InOctets, &r.OutOctets, &r.InPkts, &r.OutPkts, &r.InErrs, &r.OutErrs, &r.InOtherErrs, &r.OutOtherErrs)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslServerRow struct represents rows of the SSL_SERVER table.
type SslServerRow struct {
    SslServerID	string
    Name	string
    Description	sql.NullString
    ServiceNamedObjID	sql.NullInt32
    LoggingEnabled	sql.NullByte
    TcpResetEnabled	sql.NullByte
    DowngradeHttp2Enabled	sql.NullByte
    IterationID	uint
    LastUpdated	string
    Version	string
}

// IterateSslServer provide access to all rows of the SSL_SERVER matching given criteria.
func IterateSslServer(db *sql.DB, where string, callback func(v *SslServerRow) error) error {
    query := "SELECT SSL_SERVER_ID,NAME,DESCRIPTION,SERVICE_NAMED_OBJ_ID,LOGGING_ENABLED,TCP_RESET_ENABLED,DOWNGRADE_HTTP2_ENABLED,ITERATION_ID,LAST_UPDATED,VERSION FROM SSL_SERVER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslServerRow
        err := rows.Scan(&r.SslServerID, &r.Name, &r.Description, &r.ServiceNamedObjID, &r.LoggingEnabled, &r.TcpResetEnabled, &r.DowngradeHttp2Enabled, &r.IterationID, &r.LastUpdated, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslServer provide iterator to all rows of the SSL_SERVER matching given criteria.
func RangeSslServer(db *sql.DB, where string) iter.Seq2[*SslServerRow, error] {
	return func(yield func(v *SslServerRow, err error) bool) {
	    query := "SELECT SSL_SERVER_ID,NAME,DESCRIPTION,SERVICE_NAMED_OBJ_ID,LOGGING_ENABLED,TCP_RESET_ENABLED,DOWNGRADE_HTTP2_ENABLED,ITERATION_ID,LAST_UPDATED,VERSION FROM SSL_SERVER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslServerRow
	        err := rows.Scan(&r.SslServerID, &r.Name, &r.Description, &r.ServiceNamedObjID, &r.LoggingEnabled, &r.TcpResetEnabled, &r.DowngradeHttp2Enabled, &r.IterationID, &r.LastUpdated, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslServerCertificatesRow struct represents rows of the SSL_SERVER_CERTIFICATES table.
type SslServerCertificatesRow struct {
    SslServerID	string
    NamedCertificateID	int
}

// IterateSslServerCertificates provide access to all rows of the SSL_SERVER_CERTIFICATES matching given criteria.
func IterateSslServerCertificates(db *sql.DB, where string, callback func(v *SslServerCertificatesRow) error) error {
    query := "SELECT SSL_SERVER_ID,NAMED_CERTIFICATE_ID FROM SSL_SERVER_CERTIFICATES"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslServerCertificatesRow
        err := rows.Scan(&r.SslServerID, &r.NamedCertificateID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslServerCertificates provide iterator to all rows of the SSL_SERVER_CERTIFICATES matching given criteria.
func RangeSslServerCertificates(db *sql.DB, where string) iter.Seq2[*SslServerCertificatesRow, error] {
	return func(yield func(v *SslServerCertificatesRow, err error) bool) {
	    query := "SELECT SSL_SERVER_ID,NAMED_CERTIFICATE_ID FROM SSL_SERVER_CERTIFICATES"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslServerCertificatesRow
	        err := rows.Scan(&r.SslServerID, &r.NamedCertificateID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslServerCipherSuiteRow struct represents rows of the SSL_SERVER_CIPHER_SUITE table.
type SslServerCipherSuiteRow struct {
    ID	uint
    SslServerID	string
    SslCipherIanaID	sql.NullInt32
}

// IterateSslServerCipherSuite provide access to all rows of the SSL_SERVER_CIPHER_SUITE matching given criteria.
func IterateSslServerCipherSuite(db *sql.DB, where string, callback func(v *SslServerCipherSuiteRow) error) error {
    query := "SELECT ID,SSL_SERVER_ID,SSL_CIPHER_IANA_ID FROM SSL_SERVER_CIPHER_SUITE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslServerCipherSuiteRow
        err := rows.Scan(&r.ID, &r.SslServerID, &r.SslCipherIanaID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslServerCipherSuite provide iterator to all rows of the SSL_SERVER_CIPHER_SUITE matching given criteria.
func RangeSslServerCipherSuite(db *sql.DB, where string) iter.Seq2[*SslServerCipherSuiteRow, error] {
	return func(yield func(v *SslServerCipherSuiteRow, err error) bool) {
	    query := "SELECT ID,SSL_SERVER_ID,SSL_CIPHER_IANA_ID FROM SSL_SERVER_CIPHER_SUITE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslServerCipherSuiteRow
	        err := rows.Scan(&r.ID, &r.SslServerID, &r.SslCipherIanaID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslServerNamedObjRow struct represents rows of the SSL_SERVER_NAMED_OBJ table.
type SslServerNamedObjRow struct {
    ID	uint
    SslServerID	string
    NamedIPAddressBlockID	int
    Version	uint
}

// IterateSslServerNamedObj provide access to all rows of the SSL_SERVER_NAMED_OBJ matching given criteria.
func IterateSslServerNamedObj(db *sql.DB, where string, callback func(v *SslServerNamedObjRow) error) error {
    query := "SELECT ID,SSL_SERVER_ID,NAMED_IP_ADDRESS_BLOCK_ID,VERSION FROM SSL_SERVER_NAMED_OBJ"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslServerNamedObjRow
        err := rows.Scan(&r.ID, &r.SslServerID, &r.NamedIPAddressBlockID, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslServerNamedObj provide iterator to all rows of the SSL_SERVER_NAMED_OBJ matching given criteria.
func RangeSslServerNamedObj(db *sql.DB, where string) iter.Seq2[*SslServerNamedObjRow, error] {
	return func(yield func(v *SslServerNamedObjRow, err error) bool) {
	    query := "SELECT ID,SSL_SERVER_ID,NAMED_IP_ADDRESS_BLOCK_ID,VERSION FROM SSL_SERVER_NAMED_OBJ"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslServerNamedObjRow
	        err := rows.Scan(&r.ID, &r.SslServerID, &r.NamedIPAddressBlockID, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslServerPortRow struct represents rows of the SSL_SERVER_PORT table.
type SslServerPortRow struct {
    ID	uint
    SslServerID	string
    ProtocolType	string
    StartPort	uint
    EndPort	sql.NullInt32
    Version	uint
}

// IterateSslServerPort provide access to all rows of the SSL_SERVER_PORT matching given criteria.
func IterateSslServerPort(db *sql.DB, where string, callback func(v *SslServerPortRow) error) error {
    query := "SELECT ID,SSL_SERVER_ID,PROTOCOL_TYPE,START_PORT,END_PORT,VERSION FROM SSL_SERVER_PORT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslServerPortRow
        err := rows.Scan(&r.ID, &r.SslServerID, &r.ProtocolType, &r.StartPort, &r.EndPort, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslServerPort provide iterator to all rows of the SSL_SERVER_PORT matching given criteria.
func RangeSslServerPort(db *sql.DB, where string) iter.Seq2[*SslServerPortRow, error] {
	return func(yield func(v *SslServerPortRow, err error) bool) {
	    query := "SELECT ID,SSL_SERVER_ID,PROTOCOL_TYPE,START_PORT,END_PORT,VERSION FROM SSL_SERVER_PORT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslServerPortRow
	        err := rows.Scan(&r.ID, &r.SslServerID, &r.ProtocolType, &r.StartPort, &r.EndPort, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslServerPortStatsRow struct represents rows of the SSL_SERVER_PORT_STATS table.
type SslServerPortStatsRow struct {
    ID	uint64
    DeviceShortID	uint
    ServerName	string
    IPAddr	sql.NullString
    Port	sql.NullInt32
    SmsTime	int64
    DeviceTime	int64
    Status	bool
    Description	sql.NullString
    InBytes	int64
    OutBytes	int64
    InPkts	int64
    OutPkts	int64
    PersistConn	int64
    TotalConn	int64
    CurConn	int64
}

// IterateSslServerPortStats provide access to all rows of the SSL_SERVER_PORT_STATS matching given criteria.
func IterateSslServerPortStats(db *sql.DB, where string, callback func(v *SslServerPortStatsRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,SERVER_NAME,IP_ADDR,PORT,SMS_TIME,DEVICE_TIME,STATUS,DESCRIPTION,IN_BYTES,OUT_BYTES,IN_PKTS,OUT_PKTS,PERSIST_CONN,TOTAL_CONN,CUR_CONN FROM SSL_SERVER_PORT_STATS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslServerPortStatsRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.ServerName, &r.IPAddr, &r.Port, &r.SmsTime, &r.DeviceTime, &r.Status, &r.Description, &r.InBytes, &r.OutBytes, &r.InPkts, &r.OutPkts, &r.PersistConn, &r.TotalConn, &r.CurConn)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslServerPortStats provide iterator to all rows of the SSL_SERVER_PORT_STATS matching given criteria.
func RangeSslServerPortStats(db *sql.DB, where string) iter.Seq2[*SslServerPortStatsRow, error] {
	return func(yield func(v *SslServerPortStatsRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,SERVER_NAME,IP_ADDR,PORT,SMS_TIME,DEVICE_TIME,STATUS,DESCRIPTION,IN_BYTES,OUT_BYTES,IN_PKTS,OUT_PKTS,PERSIST_CONN,TOTAL_CONN,CUR_CONN FROM SSL_SERVER_PORT_STATS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslServerPortStatsRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.ServerName, &r.IPAddr, &r.Port, &r.SmsTime, &r.DeviceTime, &r.Status, &r.Description, &r.InBytes, &r.OutBytes, &r.InPkts, &r.OutPkts, &r.PersistConn, &r.TotalConn, &r.CurConn)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslServerProtocolRow struct represents rows of the SSL_SERVER_PROTOCOL table.
type SslServerProtocolRow struct {
    ID	uint
    SslServerID	string
    SslProtocolType	string
}

// IterateSslServerProtocol provide access to all rows of the SSL_SERVER_PROTOCOL matching given criteria.
func IterateSslServerProtocol(db *sql.DB, where string, callback func(v *SslServerProtocolRow) error) error {
    query := "SELECT ID,SSL_SERVER_ID,SSL_PROTOCOL_TYPE FROM SSL_SERVER_PROTOCOL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslServerProtocolRow
        err := rows.Scan(&r.ID, &r.SslServerID, &r.SslProtocolType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslServerProtocol provide iterator to all rows of the SSL_SERVER_PROTOCOL matching given criteria.
func RangeSslServerProtocol(db *sql.DB, where string) iter.Seq2[*SslServerProtocolRow, error] {
	return func(yield func(v *SslServerProtocolRow, err error) bool) {
	    query := "SELECT ID,SSL_SERVER_ID,SSL_PROTOCOL_TYPE FROM SSL_SERVER_PROTOCOL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslServerProtocolRow
	        err := rows.Scan(&r.ID, &r.SslServerID, &r.SslProtocolType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SslServerUserGroupRow struct represents rows of the SSL_SERVER_USER_GROUP table.
type SslServerUserGroupRow struct {
    UserGroupsIDFk	uint
    SslServerIDFk	string
}

// IterateSslServerUserGroup provide access to all rows of the SSL_SERVER_USER_GROUP matching given criteria.
func IterateSslServerUserGroup(db *sql.DB, where string, callback func(v *SslServerUserGroupRow) error) error {
    query := "SELECT USER_GROUPS_ID_FK,SSL_SERVER_ID_FK FROM SSL_SERVER_USER_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SslServerUserGroupRow
        err := rows.Scan(&r.UserGroupsIDFk, &r.SslServerIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSslServerUserGroup provide iterator to all rows of the SSL_SERVER_USER_GROUP matching given criteria.
func RangeSslServerUserGroup(db *sql.DB, where string) iter.Seq2[*SslServerUserGroupRow, error] {
	return func(yield func(v *SslServerUserGroupRow, err error) bool) {
	    query := "SELECT USER_GROUPS_ID_FK,SSL_SERVER_ID_FK FROM SSL_SERVER_USER_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SslServerUserGroupRow
	        err := rows.Scan(&r.UserGroupsIDFk, &r.SslServerIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// StixIndicatorRow struct represents rows of the STIX_INDICATOR table.
type StixIndicatorRow struct {
    ID	string
    Type	string
    CreatedTime	sql.NullInt64
    ModifyTime	sql.NullInt64
    UpdateTime	string
    Pattern	string
    Revoked	sql.NullByte
    ValidFrom	sql.NullInt64
    ValidUntil	sql.NullInt64
    Severity	sql.NullString
    Confidence	sql.NullByte
}

// IterateStixIndicator provide access to all rows of the STIX_INDICATOR matching given criteria.
func IterateStixIndicator(db *sql.DB, where string, callback func(v *StixIndicatorRow) error) error {
    query := "SELECT ID,TYPE,CREATED_TIME,MODIFY_TIME,UPDATE_TIME,PATTERN,REVOKED,VALID_FROM,VALID_UNTIL,SEVERITY,CONFIDENCE FROM STIX_INDICATOR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r StixIndicatorRow
        err := rows.Scan(&r.ID, &r.Type, &r.CreatedTime, &r.ModifyTime, &r.UpdateTime, &r.Pattern, &r.Revoked, &r.ValidFrom, &r.ValidUntil, &r.Severity, &r.Confidence)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeStixIndicator provide iterator to all rows of the STIX_INDICATOR matching given criteria.
func RangeStixIndicator(db *sql.DB, where string) iter.Seq2[*StixIndicatorRow, error] {
	return func(yield func(v *StixIndicatorRow, err error) bool) {
	    query := "SELECT ID,TYPE,CREATED_TIME,MODIFY_TIME,UPDATE_TIME,PATTERN,REVOKED,VALID_FROM,VALID_UNTIL,SEVERITY,CONFIDENCE FROM STIX_INDICATOR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r StixIndicatorRow
	        err := rows.Scan(&r.ID, &r.Type, &r.CreatedTime, &r.ModifyTime, &r.UpdateTime, &r.Pattern, &r.Revoked, &r.ValidFrom, &r.ValidUntil, &r.Severity, &r.Confidence)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// StixStatusRow struct represents rows of the STIX_STATUS table.
type StixStatusRow struct {
    ID	string
    CreatedTime	string
    CompleteTime	sql.NullTime
    Status	string
}

// IterateStixStatus provide access to all rows of the STIX_STATUS matching given criteria.
func IterateStixStatus(db *sql.DB, where string, callback func(v *StixStatusRow) error) error {
    query := "SELECT ID,CREATED_TIME,COMPLETE_TIME,STATUS FROM STIX_STATUS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r StixStatusRow
        err := rows.Scan(&r.ID, &r.CreatedTime, &r.CompleteTime, &r.Status)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeStixStatus provide iterator to all rows of the STIX_STATUS matching given criteria.
func RangeStixStatus(db *sql.DB, where string) iter.Seq2[*StixStatusRow, error] {
	return func(yield func(v *StixStatusRow, err error) bool) {
	    query := "SELECT ID,CREATED_TIME,COMPLETE_TIME,STATUS FROM STIX_STATUS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r StixStatusRow
	        err := rows.Scan(&r.ID, &r.CreatedTime, &r.CompleteTime, &r.Status)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// StixTransactionRow struct represents rows of the STIX_TRANSACTION table.
type StixTransactionRow struct {
    ID	uint
    StatusID	string
    StixID	string
    Status	string
    CreatedTime	string
    ModifyTime	string
    FailureReason	sql.NullString
}

// IterateStixTransaction provide access to all rows of the STIX_TRANSACTION matching given criteria.
func IterateStixTransaction(db *sql.DB, where string, callback func(v *StixTransactionRow) error) error {
    query := "SELECT ID,STATUS_ID,STIX_ID,STATUS,CREATED_TIME,MODIFY_TIME,FAILURE_REASON FROM STIX_TRANSACTION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r StixTransactionRow
        err := rows.Scan(&r.ID, &r.StatusID, &r.StixID, &r.Status, &r.CreatedTime, &r.ModifyTime, &r.FailureReason)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeStixTransaction provide iterator to all rows of the STIX_TRANSACTION matching given criteria.
func RangeStixTransaction(db *sql.DB, where string) iter.Seq2[*StixTransactionRow, error] {
	return func(yield func(v *StixTransactionRow, err error) bool) {
	    query := "SELECT ID,STATUS_ID,STIX_ID,STATUS,CREATED_TIME,MODIFY_TIME,FAILURE_REASON FROM STIX_TRANSACTION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r StixTransactionRow
	        err := rows.Scan(&r.ID, &r.StatusID, &r.StixID, &r.Status, &r.CreatedTime, &r.ModifyTime, &r.FailureReason)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SwDistribPackageRow struct represents rows of the SW_DISTRIB_PACKAGE table.
type SwDistribPackageRow struct {
    PkgIndex	int
    SwPkgVersion	sql.NullString
    SwPkgFile	sql.NullString
    SwPkgTimestamp	string
    SwPkgTime	sql.NullInt64
}

// IterateSwDistribPackage provide access to all rows of the SW_DISTRIB_PACKAGE matching given criteria.
func IterateSwDistribPackage(db *sql.DB, where string, callback func(v *SwDistribPackageRow) error) error {
    query := "SELECT PKG_INDEX,SW_PKG_VERSION,SW_PKG_FILE,SW_PKG_TIMESTAMP,SW_PKG_TIME FROM SW_DISTRIB_PACKAGE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SwDistribPackageRow
        err := rows.Scan(&r.PkgIndex, &r.SwPkgVersion, &r.SwPkgFile, &r.SwPkgTimestamp, &r.SwPkgTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSwDistribPackage provide iterator to all rows of the SW_DISTRIB_PACKAGE matching given criteria.
func RangeSwDistribPackage(db *sql.DB, where string) iter.Seq2[*SwDistribPackageRow, error] {
	return func(yield func(v *SwDistribPackageRow, err error) bool) {
	    query := "SELECT PKG_INDEX,SW_PKG_VERSION,SW_PKG_FILE,SW_PKG_TIMESTAMP,SW_PKG_TIME FROM SW_DISTRIB_PACKAGE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SwDistribPackageRow
	        err := rows.Scan(&r.PkgIndex, &r.SwPkgVersion, &r.SwPkgFile, &r.SwPkgTimestamp, &r.SwPkgTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SyslogConfigRow struct represents rows of the SYSLOG_CONFIG table.
type SyslogConfigRow struct {
    DeviceShortID	uint
    SystemLogEnabled	sql.NullByte
    SystemLogServer	sql.NullInt32
    AuditLogEnabled	sql.NullByte
    AuditLogServer	sql.NullInt32
    VpnLogEnabled	sql.NullByte
    VpnLogServer	sql.NullInt32
    FirewallSessionLogEnabled	sql.NullByte
    FirewallSessionLogServer	sql.NullInt32
    SystemLogServerNamedObjID	sql.NullInt32
    AuditLogServerNamedObjID	sql.NullInt32
    EventMetadataEnabled	int8
}

// IterateSyslogConfig provide access to all rows of the SYSLOG_CONFIG matching given criteria.
func IterateSyslogConfig(db *sql.DB, where string, callback func(v *SyslogConfigRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,SYSTEM_LOG_ENABLED,SYSTEM_LOG_SERVER,AUDIT_LOG_ENABLED,AUDIT_LOG_SERVER,VPN_LOG_ENABLED,VPN_LOG_SERVER,FIREWALL_SESSION_LOG_ENABLED,FIREWALL_SESSION_LOG_SERVER,SYSTEM_LOG_SERVER_NAMED_OBJ_ID,AUDIT_LOG_SERVER_NAMED_OBJ_ID,EVENT_METADATA_ENABLED FROM SYSLOG_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SyslogConfigRow
        err := rows.Scan(&r.DeviceShortID, &r.SystemLogEnabled, &r.SystemLogServer, &r.AuditLogEnabled, &r.AuditLogServer, &r.VpnLogEnabled, &r.VpnLogServer, &r.FirewallSessionLogEnabled, &r.FirewallSessionLogServer, &r.SystemLogServerNamedObjID, &r.AuditLogServerNamedObjID, &r.EventMetadataEnabled)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSyslogConfig provide iterator to all rows of the SYSLOG_CONFIG matching given criteria.
func RangeSyslogConfig(db *sql.DB, where string) iter.Seq2[*SyslogConfigRow, error] {
	return func(yield func(v *SyslogConfigRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,SYSTEM_LOG_ENABLED,SYSTEM_LOG_SERVER,AUDIT_LOG_ENABLED,AUDIT_LOG_SERVER,VPN_LOG_ENABLED,VPN_LOG_SERVER,FIREWALL_SESSION_LOG_ENABLED,FIREWALL_SESSION_LOG_SERVER,SYSTEM_LOG_SERVER_NAMED_OBJ_ID,AUDIT_LOG_SERVER_NAMED_OBJ_ID,EVENT_METADATA_ENABLED FROM SYSLOG_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SyslogConfigRow
	        err := rows.Scan(&r.DeviceShortID, &r.SystemLogEnabled, &r.SystemLogServer, &r.AuditLogEnabled, &r.AuditLogServer, &r.VpnLogEnabled, &r.VpnLogServer, &r.FirewallSessionLogEnabled, &r.FirewallSessionLogServer, &r.SystemLogServerNamedObjID, &r.AuditLogServerNamedObjID, &r.EventMetadataEnabled)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SyslogFieldRow struct represents rows of the SYSLOG_FIELD table.
type SyslogFieldRow struct {
    Name	string
    Property	string
    FieldType	string
    Snort	sql.NullByte
    DefaultValue	sql.NullString
}

// IterateSyslogField provide access to all rows of the SYSLOG_FIELD matching given criteria.
func IterateSyslogField(db *sql.DB, where string, callback func(v *SyslogFieldRow) error) error {
    query := "SELECT NAME,PROPERTY,FIELD_TYPE,SNORT,DEFAULT_VALUE FROM SYSLOG_FIELD"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SyslogFieldRow
        err := rows.Scan(&r.Name, &r.Property, &r.FieldType, &r.Snort, &r.DefaultValue)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSyslogField provide iterator to all rows of the SYSLOG_FIELD matching given criteria.
func RangeSyslogField(db *sql.DB, where string) iter.Seq2[*SyslogFieldRow, error] {
	return func(yield func(v *SyslogFieldRow, err error) bool) {
	    query := "SELECT NAME,PROPERTY,FIELD_TYPE,SNORT,DEFAULT_VALUE FROM SYSLOG_FIELD"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SyslogFieldRow
	        err := rows.Scan(&r.Name, &r.Property, &r.FieldType, &r.Snort, &r.DefaultValue)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SyslogFormatRow struct represents rows of the SYSLOG_FORMAT table.
type SyslogFormatRow struct {
    ID	uint
    Name	string
    Description	sql.NullString
    Pattern	sql.NullString
    ReadOnly	int8
    Version	int16
    TruncateData	sql.NullByte
    FieldType	sql.NullString
}

// IterateSyslogFormat provide access to all rows of the SYSLOG_FORMAT matching given criteria.
func IterateSyslogFormat(db *sql.DB, where string, callback func(v *SyslogFormatRow) error) error {
    query := "SELECT ID,NAME,DESCRIPTION,pattern,READ_ONLY,VERSION,TRUNCATE_DATA,FIELD_TYPE FROM SYSLOG_FORMAT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SyslogFormatRow
        err := rows.Scan(&r.ID, &r.Name, &r.Description, &r.Pattern, &r.ReadOnly, &r.Version, &r.TruncateData, &r.FieldType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSyslogFormat provide iterator to all rows of the SYSLOG_FORMAT matching given criteria.
func RangeSyslogFormat(db *sql.DB, where string) iter.Seq2[*SyslogFormatRow, error] {
	return func(yield func(v *SyslogFormatRow, err error) bool) {
	    query := "SELECT ID,NAME,DESCRIPTION,pattern,READ_ONLY,VERSION,TRUNCATE_DATA,FIELD_TYPE FROM SYSLOG_FORMAT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SyslogFormatRow
	        err := rows.Scan(&r.ID, &r.Name, &r.Description, &r.Pattern, &r.ReadOnly, &r.Version, &r.TruncateData, &r.FieldType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SystemLogRow struct represents rows of the SYSTEM_LOG table.
type SystemLogRow struct {
    Severity	sql.NullByte
    Time	uint64
    Message	sql.NullString
    Idx	uint64
}

// IterateSystemLog provide access to all rows of the SYSTEM_LOG matching given criteria.
func IterateSystemLog(db *sql.DB, where string, callback func(v *SystemLogRow) error) error {
    query := "SELECT SEVERITY,TIME,MESSAGE,IDX FROM SYSTEM_LOG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SystemLogRow
        err := rows.Scan(&r.Severity, &r.Time, &r.Message, &r.Idx)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSystemLog provide iterator to all rows of the SYSTEM_LOG matching given criteria.
func RangeSystemLog(db *sql.DB, where string) iter.Seq2[*SystemLogRow, error] {
	return func(yield func(v *SystemLogRow, err error) bool) {
	    query := "SELECT SEVERITY,TIME,MESSAGE,IDX FROM SYSTEM_LOG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SystemLogRow
	        err := rows.Scan(&r.Severity, &r.Time, &r.Message, &r.Idx)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// SystemRegistryRow struct represents rows of the SYSTEM_REGISTRY table.
type SystemRegistryRow struct {
    Rkey	string
    Rval	sql.NullString
}

// IterateSystemRegistry provide access to all rows of the SYSTEM_REGISTRY matching given criteria.
func IterateSystemRegistry(db *sql.DB, where string, callback func(v *SystemRegistryRow) error) error {
    query := "SELECT RKEY,RVAL FROM SYSTEM_REGISTRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r SystemRegistryRow
        err := rows.Scan(&r.Rkey, &r.Rval)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeSystemRegistry provide iterator to all rows of the SYSTEM_REGISTRY matching given criteria.
func RangeSystemRegistry(db *sql.DB, where string) iter.Seq2[*SystemRegistryRow, error] {
	return func(yield func(v *SystemRegistryRow, err error) bool) {
	    query := "SELECT RKEY,RVAL FROM SYSTEM_REGISTRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r SystemRegistryRow
	        err := rows.Scan(&r.Rkey, &r.Rval)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TableProcessRecordRow struct represents rows of the TABLE_PROCESS_RECORD table.
type TableProcessRecordRow struct {
    Idx	uint
    TableName	sql.NullString
    LastIdx	sql.NullInt64
}

// IterateTableProcessRecord provide access to all rows of the TABLE_PROCESS_RECORD matching given criteria.
func IterateTableProcessRecord(db *sql.DB, where string, callback func(v *TableProcessRecordRow) error) error {
    query := "SELECT IDX,TABLE_NAME,LAST_IDX FROM TABLE_PROCESS_RECORD"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TableProcessRecordRow
        err := rows.Scan(&r.Idx, &r.TableName, &r.LastIdx)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTableProcessRecord provide iterator to all rows of the TABLE_PROCESS_RECORD matching given criteria.
func RangeTableProcessRecord(db *sql.DB, where string) iter.Seq2[*TableProcessRecordRow, error] {
	return func(yield func(v *TableProcessRecordRow, err error) bool) {
	    query := "SELECT IDX,TABLE_NAME,LAST_IDX FROM TABLE_PROCESS_RECORD"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TableProcessRecordRow
	        err := rows.Scan(&r.Idx, &r.TableName, &r.LastIdx)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TaxonomyMajorRow struct represents rows of the TAXONOMY_MAJOR table.
type TaxonomyMajorRow struct {
    ID	int16
    Name	string
    Descr	string
    IterationID	sql.NullString
    Version	sql.NullString
}

// IterateTaxonomyMajor provide access to all rows of the TAXONOMY_MAJOR matching given criteria.
func IterateTaxonomyMajor(db *sql.DB, where string, callback func(v *TaxonomyMajorRow) error) error {
    query := "SELECT ID,NAME,DESCR,ITERATION_ID,VERSION FROM TAXONOMY_MAJOR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TaxonomyMajorRow
        err := rows.Scan(&r.ID, &r.Name, &r.Descr, &r.IterationID, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTaxonomyMajor provide iterator to all rows of the TAXONOMY_MAJOR matching given criteria.
func RangeTaxonomyMajor(db *sql.DB, where string) iter.Seq2[*TaxonomyMajorRow, error] {
	return func(yield func(v *TaxonomyMajorRow, err error) bool) {
	    query := "SELECT ID,NAME,DESCR,ITERATION_ID,VERSION FROM TAXONOMY_MAJOR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TaxonomyMajorRow
	        err := rows.Scan(&r.ID, &r.Name, &r.Descr, &r.IterationID, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TaxonomyMinorRow struct represents rows of the TAXONOMY_MINOR table.
type TaxonomyMinorRow struct {
    MajorID	int16
    ID	int16
    Descr	string
}

// IterateTaxonomyMinor provide access to all rows of the TAXONOMY_MINOR matching given criteria.
func IterateTaxonomyMinor(db *sql.DB, where string, callback func(v *TaxonomyMinorRow) error) error {
    query := "SELECT MAJOR_ID,ID,DESCR FROM TAXONOMY_MINOR"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TaxonomyMinorRow
        err := rows.Scan(&r.MajorID, &r.ID, &r.Descr)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTaxonomyMinor provide iterator to all rows of the TAXONOMY_MINOR matching given criteria.
func RangeTaxonomyMinor(db *sql.DB, where string) iter.Seq2[*TaxonomyMinorRow, error] {
	return func(yield func(v *TaxonomyMinorRow, err error) bool) {
	    query := "SELECT MAJOR_ID,ID,DESCR FROM TAXONOMY_MINOR"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TaxonomyMinorRow
	        err := rows.Scan(&r.MajorID, &r.ID, &r.Descr)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TaxonomyPlatformRow struct represents rows of the TAXONOMY_PLATFORM table.
type TaxonomyPlatformRow struct {
    ID	int16
    Descr	string
    IterationID	sql.NullString
    Version	sql.NullString
}

// IterateTaxonomyPlatform provide access to all rows of the TAXONOMY_PLATFORM matching given criteria.
func IterateTaxonomyPlatform(db *sql.DB, where string, callback func(v *TaxonomyPlatformRow) error) error {
    query := "SELECT ID,DESCR,ITERATION_ID,VERSION FROM TAXONOMY_PLATFORM"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TaxonomyPlatformRow
        err := rows.Scan(&r.ID, &r.Descr, &r.IterationID, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTaxonomyPlatform provide iterator to all rows of the TAXONOMY_PLATFORM matching given criteria.
func RangeTaxonomyPlatform(db *sql.DB, where string) iter.Seq2[*TaxonomyPlatformRow, error] {
	return func(yield func(v *TaxonomyPlatformRow, err error) bool) {
	    query := "SELECT ID,DESCR,ITERATION_ID,VERSION FROM TAXONOMY_PLATFORM"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TaxonomyPlatformRow
	        err := rows.Scan(&r.ID, &r.Descr, &r.IterationID, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TaxonomyProtocolRow struct represents rows of the TAXONOMY_PROTOCOL table.
type TaxonomyProtocolRow struct {
    ID	int16
    Descr	string
    IterationID	sql.NullString
    Version	sql.NullString
}

// IterateTaxonomyProtocol provide access to all rows of the TAXONOMY_PROTOCOL matching given criteria.
func IterateTaxonomyProtocol(db *sql.DB, where string, callback func(v *TaxonomyProtocolRow) error) error {
    query := "SELECT ID,DESCR,ITERATION_ID,VERSION FROM TAXONOMY_PROTOCOL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TaxonomyProtocolRow
        err := rows.Scan(&r.ID, &r.Descr, &r.IterationID, &r.Version)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTaxonomyProtocol provide iterator to all rows of the TAXONOMY_PROTOCOL matching given criteria.
func RangeTaxonomyProtocol(db *sql.DB, where string) iter.Seq2[*TaxonomyProtocolRow, error] {
	return func(yield func(v *TaxonomyProtocolRow, err error) bool) {
	    query := "SELECT ID,DESCR,ITERATION_ID,VERSION FROM TAXONOMY_PROTOCOL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TaxonomyProtocolRow
	        err := rows.Scan(&r.ID, &r.Descr, &r.IterationID, &r.Version)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TelemetryRow struct represents rows of the TELEMETRY table.
type TelemetryRow struct {
    LastUpdated	sql.NullTime
    Category	string
    MetricName	string
    Value	sql.NullString
}

// IterateTelemetry provide access to all rows of the TELEMETRY matching given criteria.
func IterateTelemetry(db *sql.DB, where string, callback func(v *TelemetryRow) error) error {
    query := "SELECT LAST_UPDATED,CATEGORY,METRIC_NAME,VALUE FROM TELEMETRY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TelemetryRow
        err := rows.Scan(&r.LastUpdated, &r.Category, &r.MetricName, &r.Value)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTelemetry provide iterator to all rows of the TELEMETRY matching given criteria.
func RangeTelemetry(db *sql.DB, where string) iter.Seq2[*TelemetryRow, error] {
	return func(yield func(v *TelemetryRow, err error) bool) {
	    query := "SELECT LAST_UPDATED,CATEGORY,METRIC_NAME,VALUE FROM TELEMETRY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TelemetryRow
	        err := rows.Scan(&r.LastUpdated, &r.Category, &r.MetricName, &r.Value)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ThresholdStatesRow struct represents rows of the THRESHOLD_STATES table.
type ThresholdStatesRow struct {
    ID	int
    Icon	sql.NullString
    Descr	sql.NullString
}

// IterateThresholdStates provide access to all rows of the THRESHOLD_STATES matching given criteria.
func IterateThresholdStates(db *sql.DB, where string, callback func(v *ThresholdStatesRow) error) error {
    query := "SELECT ID,ICON,DESCR FROM THRESHOLD_STATES"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ThresholdStatesRow
        err := rows.Scan(&r.ID, &r.Icon, &r.Descr)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeThresholdStates provide iterator to all rows of the THRESHOLD_STATES matching given criteria.
func RangeThresholdStates(db *sql.DB, where string) iter.Seq2[*ThresholdStatesRow, error] {
	return func(yield func(v *ThresholdStatesRow, err error) bool) {
	    query := "SELECT ID,ICON,DESCR FROM THRESHOLD_STATES"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ThresholdStatesRow
	        err := rows.Scan(&r.ID, &r.Icon, &r.Descr)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ThresholdUnitsRow struct represents rows of the THRESHOLD_UNITS table.
type ThresholdUnitsRow struct {
    ID	int
    Name	sql.NullString
}

// IterateThresholdUnits provide access to all rows of the THRESHOLD_UNITS matching given criteria.
func IterateThresholdUnits(db *sql.DB, where string, callback func(v *ThresholdUnitsRow) error) error {
    query := "SELECT ID,NAME FROM THRESHOLD_UNITS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ThresholdUnitsRow
        err := rows.Scan(&r.ID, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeThresholdUnits provide iterator to all rows of the THRESHOLD_UNITS matching given criteria.
func RangeThresholdUnits(db *sql.DB, where string) iter.Seq2[*ThresholdUnitsRow, error] {
	return func(yield func(v *ThresholdUnitsRow, err error) bool) {
	    query := "SELECT ID,NAME FROM THRESHOLD_UNITS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ThresholdUnitsRow
	        err := rows.Scan(&r.ID, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TimersRow struct represents rows of the TIMERS table.
type TimersRow struct {
    Timerid	string
    Targetid	string
    Initialdate	string
    Timerinterval	sql.NullInt64
    Instancepk	[]byte
    Info	[]byte
}

// IterateTimers provide access to all rows of the TIMERS matching given criteria.
func IterateTimers(db *sql.DB, where string, callback func(v *TimersRow) error) error {
    query := "SELECT TIMERID,TARGETID,INITIALDATE,TIMERINTERVAL,INSTANCEPK,INFO FROM TIMERS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TimersRow
        err := rows.Scan(&r.Timerid, &r.Targetid, &r.Initialdate, &r.Timerinterval, &r.Instancepk, &r.Info)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTimers provide iterator to all rows of the TIMERS matching given criteria.
func RangeTimers(db *sql.DB, where string) iter.Seq2[*TimersRow, error] {
	return func(yield func(v *TimersRow, err error) bool) {
	    query := "SELECT TIMERID,TARGETID,INITIALDATE,TIMERINTERVAL,INSTANCEPK,INFO FROM TIMERS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TimersRow
	        err := rows.Scan(&r.Timerid, &r.Targetid, &r.Initialdate, &r.Timerinterval, &r.Instancepk, &r.Info)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TlsProtocolVersionsRow struct represents rows of the TLS_PROTOCOL_VERSIONS table.
type TlsProtocolVersionsRow struct {
    Type	string
    Tlsv10	sql.NullByte
    Tlsv11	sql.NullByte
    Tlsv12	sql.NullByte
    Tlsv13	sql.NullByte
}

// IterateTlsProtocolVersions provide access to all rows of the TLS_PROTOCOL_VERSIONS matching given criteria.
func IterateTlsProtocolVersions(db *sql.DB, where string, callback func(v *TlsProtocolVersionsRow) error) error {
    query := "SELECT TYPE,TLSV10,TLSV11,TLSV12,TLSV13 FROM TLS_PROTOCOL_VERSIONS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TlsProtocolVersionsRow
        err := rows.Scan(&r.Type, &r.Tlsv10, &r.Tlsv11, &r.Tlsv12, &r.Tlsv13)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTlsProtocolVersions provide iterator to all rows of the TLS_PROTOCOL_VERSIONS matching given criteria.
func RangeTlsProtocolVersions(db *sql.DB, where string) iter.Seq2[*TlsProtocolVersionsRow, error] {
	return func(yield func(v *TlsProtocolVersionsRow, err error) bool) {
	    query := "SELECT TYPE,TLSV10,TLSV11,TLSV12,TLSV13 FROM TLS_PROTOCOL_VERSIONS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TlsProtocolVersionsRow
	        err := rows.Scan(&r.Type, &r.Tlsv10, &r.Tlsv11, &r.Tlsv12, &r.Tlsv13)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TmcTmufeCategoryRow struct represents rows of the TMC_TMUFE_CATEGORY table.
type TmcTmufeCategoryRow struct {
    ID	uint
    SslCategoryID	uint
    CategoryName	string
    TmufeCategoryID	uint
    Deleted	sql.NullByte
    AddTs	uint64
    UpdatedTs	sql.NullInt64
    IterationID	sql.NullInt32
}

// IterateTmcTmufeCategory provide access to all rows of the TMC_TMUFE_CATEGORY matching given criteria.
func IterateTmcTmufeCategory(db *sql.DB, where string, callback func(v *TmcTmufeCategoryRow) error) error {
    query := "SELECT ID,SSL_CATEGORY_ID,CATEGORY_NAME,TMUFE_CATEGORY_ID,DELETED,ADD_TS,UPDATED_TS,ITERATION_ID FROM TMC_TMUFE_CATEGORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TmcTmufeCategoryRow
        err := rows.Scan(&r.ID, &r.SslCategoryID, &r.CategoryName, &r.TmufeCategoryID, &r.Deleted, &r.AddTs, &r.UpdatedTs, &r.IterationID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTmcTmufeCategory provide iterator to all rows of the TMC_TMUFE_CATEGORY matching given criteria.
func RangeTmcTmufeCategory(db *sql.DB, where string) iter.Seq2[*TmcTmufeCategoryRow, error] {
	return func(yield func(v *TmcTmufeCategoryRow, err error) bool) {
	    query := "SELECT ID,SSL_CATEGORY_ID,CATEGORY_NAME,TMUFE_CATEGORY_ID,DELETED,ADD_TS,UPDATED_TS,ITERATION_ID FROM TMC_TMUFE_CATEGORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TmcTmufeCategoryRow
	        err := rows.Scan(&r.ID, &r.SslCategoryID, &r.CategoryName, &r.TmufeCategoryID, &r.Deleted, &r.AddTs, &r.UpdatedTs, &r.IterationID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptCardRow struct represents rows of the TPT_CARD table.
type TptCardRow struct {
    ID	string
    DisplayName	sql.NullString
    ParentID	string
    BitArray	sql.NullInt32
    ParentDeviceKey	string
    CardType	sql.NullString
    CardSlotNumber	sql.NullInt64
    CardSlotType	sql.NullString
    CardCfgType	sql.NullInt32
    CardRunState	sql.NullInt32
    CardQualifier1	sql.NullInt32
    CardQualifier2	sql.NullInt32
    CardQualifier3	sql.NullInt32
    CardQualifier4	sql.NullInt32
    CardStartTime	sql.NullInt64
    CardVendorID	sql.NullInt64
    CardDeviceID	sql.NullInt64
    CardProductID	sql.NullString
    CardFpgaVersion	sql.NullInt64
    CardInterfaceIndex	sql.NullInt32
    BayNumber	sql.NullInt32
}

// IterateTptCard provide access to all rows of the TPT_CARD matching given criteria.
func IterateTptCard(db *sql.DB, where string, callback func(v *TptCardRow) error) error {
    query := "SELECT ID,DISPLAY_NAME,PARENT_ID,BIT_ARRAY,PARENT_DEVICE_KEY,CARD_TYPE,CARD_SLOT_NUMBER,CARD_SLOT_TYPE,CARD_CFG_TYPE,CARD_RUN_STATE,CARD_QUALIFIER_1,CARD_QUALIFIER_2,CARD_QUALIFIER_3,CARD_QUALIFIER_4,CARD_START_TIME,CARD_VENDOR_ID,CARD_DEVICE_ID,CARD_PRODUCT_ID,CARD_FPGA_VERSION,CARD_INTERFACE_INDEX,BAY_NUMBER FROM TPT_CARD"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptCardRow
        err := rows.Scan(&r.ID, &r.DisplayName, &r.ParentID, &r.BitArray, &r.ParentDeviceKey, &r.CardType, &r.CardSlotNumber, &r.CardSlotType, &r.CardCfgType, &r.CardRunState, &r.CardQualifier1, &r.CardQualifier2, &r.CardQualifier3, &r.CardQualifier4, &r.CardStartTime, &r.CardVendorID, &r.CardDeviceID, &r.CardProductID, &r.CardFpgaVersion, &r.CardInterfaceIndex, &r.BayNumber)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptCard provide iterator to all rows of the TPT_CARD matching given criteria.
func RangeTptCard(db *sql.DB, where string) iter.Seq2[*TptCardRow, error] {
	return func(yield func(v *TptCardRow, err error) bool) {
	    query := "SELECT ID,DISPLAY_NAME,PARENT_ID,BIT_ARRAY,PARENT_DEVICE_KEY,CARD_TYPE,CARD_SLOT_NUMBER,CARD_SLOT_TYPE,CARD_CFG_TYPE,CARD_RUN_STATE,CARD_QUALIFIER_1,CARD_QUALIFIER_2,CARD_QUALIFIER_3,CARD_QUALIFIER_4,CARD_START_TIME,CARD_VENDOR_ID,CARD_DEVICE_ID,CARD_PRODUCT_ID,CARD_FPGA_VERSION,CARD_INTERFACE_INDEX,BAY_NUMBER FROM TPT_CARD"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptCardRow
	        err := rows.Scan(&r.ID, &r.DisplayName, &r.ParentID, &r.BitArray, &r.ParentDeviceKey, &r.CardType, &r.CardSlotNumber, &r.CardSlotType, &r.CardCfgType, &r.CardRunState, &r.CardQualifier1, &r.CardQualifier2, &r.CardQualifier3, &r.CardQualifier4, &r.CardStartTime, &r.CardVendorID, &r.CardDeviceID, &r.CardProductID, &r.CardFpgaVersion, &r.CardInterfaceIndex, &r.BayNumber)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptChassisRow struct represents rows of the TPT_CHASSIS table.
type TptChassisRow struct {
    ID	string
    DisplayName	sql.NullString
    ParentID	string
    BitArray	sql.NullInt32
    ParentDeviceKey	string
    ChassisNumber	sql.NullInt64
    ChassisType	sql.NullInt32
    ChassisCfgType	sql.NullInt32
    ChassisRunState	sql.NullInt32
    ChassisQualifier1	sql.NullInt32
    ChassisQualifier2	sql.NullInt32
    ChassisQualifier3	sql.NullInt32
    ChassisQualifier4	sql.NullInt32
    ChassisStartTime	sql.NullInt64
    ChassisVendorID	sql.NullInt64
    ChassisDeviceID	sql.NullInt64
    ChassisSlotCount	sql.NullInt64
    ChassisProductID	sql.NullString
    ChassisFpgaVersion	sql.NullInt64
}

// IterateTptChassis provide access to all rows of the TPT_CHASSIS matching given criteria.
func IterateTptChassis(db *sql.DB, where string, callback func(v *TptChassisRow) error) error {
    query := "SELECT ID,DISPLAY_NAME,PARENT_ID,BIT_ARRAY,PARENT_DEVICE_KEY,CHASSIS_NUMBER,CHASSIS_TYPE,CHASSIS_CFG_TYPE,CHASSIS_RUN_STATE,CHASSIS_QUALIFIER_1,CHASSIS_QUALIFIER_2,CHASSIS_QUALIFIER_3,CHASSIS_QUALIFIER_4,CHASSIS_START_TIME,CHASSIS_VENDOR_ID,CHASSIS_DEVICE_ID,CHASSIS_SLOT_COUNT,CHASSIS_PRODUCT_ID,CHASSIS_FPGA_VERSION FROM TPT_CHASSIS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptChassisRow
        err := rows.Scan(&r.ID, &r.DisplayName, &r.ParentID, &r.BitArray, &r.ParentDeviceKey, &r.ChassisNumber, &r.ChassisType, &r.ChassisCfgType, &r.ChassisRunState, &r.ChassisQualifier1, &r.ChassisQualifier2, &r.ChassisQualifier3, &r.ChassisQualifier4, &r.ChassisStartTime, &r.ChassisVendorID, &r.ChassisDeviceID, &r.ChassisSlotCount, &r.ChassisProductID, &r.ChassisFpgaVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptChassis provide iterator to all rows of the TPT_CHASSIS matching given criteria.
func RangeTptChassis(db *sql.DB, where string) iter.Seq2[*TptChassisRow, error] {
	return func(yield func(v *TptChassisRow, err error) bool) {
	    query := "SELECT ID,DISPLAY_NAME,PARENT_ID,BIT_ARRAY,PARENT_DEVICE_KEY,CHASSIS_NUMBER,CHASSIS_TYPE,CHASSIS_CFG_TYPE,CHASSIS_RUN_STATE,CHASSIS_QUALIFIER_1,CHASSIS_QUALIFIER_2,CHASSIS_QUALIFIER_3,CHASSIS_QUALIFIER_4,CHASSIS_START_TIME,CHASSIS_VENDOR_ID,CHASSIS_DEVICE_ID,CHASSIS_SLOT_COUNT,CHASSIS_PRODUCT_ID,CHASSIS_FPGA_VERSION FROM TPT_CHASSIS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptChassisRow
	        err := rows.Scan(&r.ID, &r.DisplayName, &r.ParentID, &r.BitArray, &r.ParentDeviceKey, &r.ChassisNumber, &r.ChassisType, &r.ChassisCfgType, &r.ChassisRunState, &r.ChassisQualifier1, &r.ChassisQualifier2, &r.ChassisQualifier3, &r.ChassisQualifier4, &r.ChassisStartTime, &r.ChassisVendorID, &r.ChassisDeviceID, &r.ChassisSlotCount, &r.ChassisProductID, &r.ChassisFpgaVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptConfRow struct represents rows of the TPT_CONF table.
type TptConfRow struct {
    ComponentName	string
    DateInitialized	sql.NullTime
}

// IterateTptConf provide access to all rows of the TPT_CONF matching given criteria.
func IterateTptConf(db *sql.DB, where string, callback func(v *TptConfRow) error) error {
    query := "SELECT COMPONENT_NAME,DATE_INITIALIZED FROM TPT_CONF"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptConfRow
        err := rows.Scan(&r.ComponentName, &r.DateInitialized)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptConf provide iterator to all rows of the TPT_CONF matching given criteria.
func RangeTptConf(db *sql.DB, where string) iter.Seq2[*TptConfRow, error] {
	return func(yield func(v *TptConfRow, err error) bool) {
	    query := "SELECT COMPONENT_NAME,DATE_INITIALIZED FROM TPT_CONF"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptConfRow
	        err := rows.Scan(&r.ComponentName, &r.DateInitialized)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptDeviceRow struct represents rows of the TPT_DEVICE table.
type TptDeviceRow struct {
    ID	string
    DisplayName	sql.NullString
    BitArray	sql.NullInt32
    DeviceModel	sql.NullString
    SoftwareVersion	sql.NullString
    SerialNumber	sql.NullString
    DestinationNetwork	sql.NullString
    GatewayMask	sql.NullString
    TimeStamp	sql.NullString
    TimeZone	sql.NullString
    DefaultPosture	sql.NullString
    DeviceMode	sql.NullString
    EmailAdmin	sql.NullString
    NetworkMask	sql.NullString
    SmtpDomain	sql.NullString
    AttackSyncParams	sql.NullString
    GlobalFallbackState	sql.NullInt32
    GlobalFallbackCause	sql.NullInt32
    GlobalFallbackTimeStamp	sql.NullString
    DroppedThreshold	sql.NullInt32
    IPAddress	sql.NullString
    SnmpPort	sql.NullInt32
    Community	sql.NullString
    WriteCommunity	sql.NullString
    HostNetmask	sql.NullString
    SysDescr	sql.NullString
    SysOid	sql.NullString
    Location	sql.NullString
    Contact	sql.NullString
    ConnTableTimeout	sql.NullInt32
    CongestionDetectMode	sql.NullInt32
    SntpDuration	sql.NullInt32
    SntpOffset	sql.NullInt64
    SntpPort	sql.NullInt32
    SntpRetries	sql.NullInt32
    SntpTimeout	sql.NullInt32
    TrhaConnState	sql.NullInt32
    NmsCommunity	sql.NullString
    NmsEventMetadata	int8
    LogImportInterval	sql.NullInt64
    AfcLogLevel	sql.NullInt32
    TseLogThreshold	sql.NullString
    TseLogPeriod	sql.NullInt32
    SmtpThreshold	sql.NullInt32
    QuarantineTimeout	sql.NullInt32
    DnsDomain	sql.NullString
    ParentGroupID	sql.NullInt32
    ZphaState	sql.NullByte
    HaFallbackAction	sql.NullInt16
    HaCongestionThresh	sql.NullInt32
    LbLearnMode	sql.NullByte
    GatewayNamedObjID	sql.NullInt32
    SmtpServerNamedObjID	sql.NullInt32
    SmtpEmailNamedObjID	sql.NullInt32
    TrhaNamedObjID	sql.NullInt32
    PrimaryNtpServerNamedObjID	sql.NullInt32
    SecondaryNtpServerNamedObjID	sql.NullInt32
    DnsPrimaryServerNamedObjID	sql.NullInt32
    DnsSecondaryServerNamedObjID	sql.NullInt32
    Ipv6MgmtEnabled	sql.NullByte
    Ipv6AutoConfig	sql.NullByte
    Ipv4IPAddress	sql.NullString
    Ipv6IPAddress	sql.NullString
    Ipv6LinkLocalAddress	sql.NullString
    Ipv6GatewayNamedObjID	sql.NullInt32
    FipsModeEnabled	uint8
    FipsModeActive	uint8
    HaAutoRecoverHeartbeatEnable	int8
    HaAutoRecoverIlinkEnable	int8
    HaPerfProtectEnable	int8
    HaPerfProtectAutoRestoreEnable	int8
    SnmpVersion	int8
    SnmpConfigVersion	int8
    ConnTableNonTcpTimeout	sql.NullInt32
    ConnTableTrustTimeout	sql.NullInt32
    HwSerial	sql.NullString
    EntitlementVersion	sql.NullString
    RemoteAuthEnabled	int8
    RemoteAuthTimeout	sql.NullInt32
    DeviceVersionDataXml	sql.NullString
    MaxIomPorts	sql.NullInt16
    TrhaDeviceID	sql.NullInt32
    TrhaDeviceSerial	sql.NullString
    IpdbSynced	int8
    DeviceModelType	sql.NullByte
    HaL2fbPref	int8
    GzipDecompression	int8
    IdsConfigured	int8
    IdsActive	int8
    HttpEncodedResp	int8
    FlowStatus	int8
    ApiVersion	sql.NullInt32
    RemoteRadiusAuthEnabled	int8
    RemoteTacacsAuthEnabled	int8
    NxdomainEnabled	int8
    NcrEncodeEnabled	int8
    HttpModeEnabled	int8
    TrhaPassphrase	sql.NullString
    TrhaEncryptionEnabled	int8
    DemoMode	int8
    DvtUninstall	int8
    StackingEnabled	int8
    StackRedundancy	sql.NullInt32
    RegisteredTime	uint64
    RegisterInstanceID	sql.NullString
    RegisterProvider	sql.NullString
    RegisterLicenseType	sql.NullString
    GenericTelemetryEnabled	int8
    VnsInstalled	int8
    VnsRebootRequired	int8
    ApplyDomainRepToHttpTraffic	int8
    ApplyDomainRepToTlsSni	int8
    ApplyDomainRepToDnsTraffic	int8
    ShortID	uint
}

// IterateTptDevice provide access to all rows of the TPT_DEVICE matching given criteria.
func IterateTptDevice(db *sql.DB, where string, callback func(v *TptDeviceRow) error) error {
    query := "SELECT ID,DISPLAY_NAME,BIT_ARRAY,DEVICE_MODEL,SOFTWARE_VERSION,SERIAL_NUMBER,DESTINATION_NETWORK,GATEWAY_MASK,TIME_STAMP,TIME_ZONE,DEFAULT_POSTURE,DEVICE_MODE,EMAIL_ADMIN,NETWORK_MASK,SMTP_DOMAIN,ATTACK_SYNC_PARAMS,GLOBAL_FALLBACK_STATE,GLOBAL_FALLBACK_CAUSE,GLOBAL_FALLBACK_TIME_STAMP,DROPPED_THRESHOLD,IP_ADDRESS,SNMP_PORT,COMMUNITY,WRITE_COMMUNITY,HOST_NETMASK,SYS_DESCR,SYS_OID,LOCATION,CONTACT,CONN_TABLE_TIMEOUT,CONGESTION_DETECT_MODE,SNTP_DURATION,SNTP_OFFSET,SNTP_PORT,SNTP_RETRIES,SNTP_TIMEOUT,TRHA_CONN_STATE,NMS_COMMUNITY,NMS_EVENT_METADATA,LOG_IMPORT_INTERVAL,AFC_LOG_LEVEL,TSE_LOG_THRESHOLD,TSE_LOG_PERIOD,SMTP_THRESHOLD,QUARANTINE_TIMEOUT,DNS_DOMAIN,PARENT_GROUP_ID,ZPHA_STATE,HA_FALLBACK_ACTION,HA_CONGESTION_THRESH,LB_LEARN_MODE,GATEWAY_NAMED_OBJ_ID,SMTP_SERVER_NAMED_OBJ_ID,SMTP_EMAIL_NAMED_OBJ_ID,TRHA_NAMED_OBJ_ID,PRIMARY_NTP_SERVER_NAMED_OBJ_ID,SECONDARY_NTP_SERVER_NAMED_OBJ_ID,DNS_PRIMARY_SERVER_NAMED_OBJ_ID,DNS_SECONDARY_SERVER_NAMED_OBJ_ID,IPV6_MGMT_ENABLED,IPV6_AUTO_CONFIG,IPV4_IP_ADDRESS,IPV6_IP_ADDRESS,IPV6_LINK_LOCAL_ADDRESS,IPV6_GATEWAY_NAMED_OBJ_ID,FIPS_MODE_ENABLED,FIPS_MODE_ACTIVE,HA_AUTO_RECOVER_HEARTBEAT_ENABLE,HA_AUTO_RECOVER_ILINK_ENABLE,HA_PERF_PROTECT_ENABLE,HA_PERF_PROTECT_AUTO_RESTORE_ENABLE,SNMP_VERSION,SNMP_CONFIG_VERSION,CONN_TABLE_NON_TCP_TIMEOUT,CONN_TABLE_TRUST_TIMEOUT,HW_SERIAL,ENTITLEMENT_VERSION,REMOTE_AUTH_ENABLED,REMOTE_AUTH_TIMEOUT,DEVICE_VERSION_DATA_XML,MAX_IOM_PORTS,TRHA_DEVICE_ID,TRHA_DEVICE_SERIAL,IPDB_SYNCED,DEVICE_MODEL_TYPE,HA_L2FB_PREF,GZIP_DECOMPRESSION,IDS_CONFIGURED,IDS_ACTIVE,HTTP_ENCODED_RESP,FLOW_STATUS,API_VERSION,REMOTE_RADIUS_AUTH_ENABLED,REMOTE_TACACS_AUTH_ENABLED,NXDOMAIN_ENABLED,NCR_ENCODE_ENABLED,HTTP_MODE_ENABLED,TRHA_PASSPHRASE,TRHA_ENCRYPTION_ENABLED,DEMO_MODE,DVT_UNINSTALL,STACKING_ENABLED,STACK_REDUNDANCY,REGISTERED_TIME,REGISTER_INSTANCE_ID,REGISTER_PROVIDER,REGISTER_LICENSE_TYPE,GENERIC_TELEMETRY_ENABLED,VNS_INSTALLED,VNS_REBOOT_REQUIRED,APPLY_DOMAIN_REP_TO_HTTP_TRAFFIC,APPLY_DOMAIN_REP_TO_TLS_SNI,APPLY_DOMAIN_REP_TO_DNS_TRAFFIC,SHORT_ID FROM TPT_DEVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptDeviceRow
        err := rows.Scan(&r.ID, &r.DisplayName, &r.BitArray, &r.DeviceModel, &r.SoftwareVersion, &r.SerialNumber, &r.DestinationNetwork, &r.GatewayMask, &r.TimeStamp, &r.TimeZone, &r.DefaultPosture, &r.DeviceMode, &r.EmailAdmin, &r.NetworkMask, &r.SmtpDomain, &r.AttackSyncParams, &r.GlobalFallbackState, &r.GlobalFallbackCause, &r.GlobalFallbackTimeStamp, &r.DroppedThreshold, &r.IPAddress, &r.SnmpPort, &r.Community, &r.WriteCommunity, &r.HostNetmask, &r.SysDescr, &r.SysOid, &r.Location, &r.Contact, &r.ConnTableTimeout, &r.CongestionDetectMode, &r.SntpDuration, &r.SntpOffset, &r.SntpPort, &r.SntpRetries, &r.SntpTimeout, &r.TrhaConnState, &r.NmsCommunity, &r.NmsEventMetadata, &r.LogImportInterval, &r.AfcLogLevel, &r.TseLogThreshold, &r.TseLogPeriod, &r.SmtpThreshold, &r.QuarantineTimeout, &r.DnsDomain, &r.ParentGroupID, &r.ZphaState, &r.HaFallbackAction, &r.HaCongestionThresh, &r.LbLearnMode, &r.GatewayNamedObjID, &r.SmtpServerNamedObjID, &r.SmtpEmailNamedObjID, &r.TrhaNamedObjID, &r.PrimaryNtpServerNamedObjID, &r.SecondaryNtpServerNamedObjID, &r.DnsPrimaryServerNamedObjID, &r.DnsSecondaryServerNamedObjID, &r.Ipv6MgmtEnabled, &r.Ipv6AutoConfig, &r.Ipv4IPAddress, &r.Ipv6IPAddress, &r.Ipv6LinkLocalAddress, &r.Ipv6GatewayNamedObjID, &r.FipsModeEnabled, &r.FipsModeActive, &r.HaAutoRecoverHeartbeatEnable, &r.HaAutoRecoverIlinkEnable, &r.HaPerfProtectEnable, &r.HaPerfProtectAutoRestoreEnable, &r.SnmpVersion, &r.SnmpConfigVersion, &r.ConnTableNonTcpTimeout, &r.ConnTableTrustTimeout, &r.HwSerial, &r.EntitlementVersion, &r.RemoteAuthEnabled, &r.RemoteAuthTimeout, &r.DeviceVersionDataXml, &r.MaxIomPorts, &r.TrhaDeviceID, &r.TrhaDeviceSerial, &r.IpdbSynced, &r.DeviceModelType, &r.HaL2fbPref, &r.GzipDecompression, &r.IdsConfigured, &r.IdsActive, &r.HttpEncodedResp, &r.FlowStatus, &r.ApiVersion, &r.RemoteRadiusAuthEnabled, &r.RemoteTacacsAuthEnabled, &r.NxdomainEnabled, &r.NcrEncodeEnabled, &r.HttpModeEnabled, &r.TrhaPassphrase, &r.TrhaEncryptionEnabled, &r.DemoMode, &r.DvtUninstall, &r.StackingEnabled, &r.StackRedundancy, &r.RegisteredTime, &r.RegisterInstanceID, &r.RegisterProvider, &r.RegisterLicenseType, &r.GenericTelemetryEnabled, &r.VnsInstalled, &r.VnsRebootRequired, &r.ApplyDomainRepToHttpTraffic, &r.ApplyDomainRepToTlsSni, &r.ApplyDomainRepToDnsTraffic, &r.ShortID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptDevice provide iterator to all rows of the TPT_DEVICE matching given criteria.
func RangeTptDevice(db *sql.DB, where string) iter.Seq2[*TptDeviceRow, error] {
	return func(yield func(v *TptDeviceRow, err error) bool) {
	    query := "SELECT ID,DISPLAY_NAME,BIT_ARRAY,DEVICE_MODEL,SOFTWARE_VERSION,SERIAL_NUMBER,DESTINATION_NETWORK,GATEWAY_MASK,TIME_STAMP,TIME_ZONE,DEFAULT_POSTURE,DEVICE_MODE,EMAIL_ADMIN,NETWORK_MASK,SMTP_DOMAIN,ATTACK_SYNC_PARAMS,GLOBAL_FALLBACK_STATE,GLOBAL_FALLBACK_CAUSE,GLOBAL_FALLBACK_TIME_STAMP,DROPPED_THRESHOLD,IP_ADDRESS,SNMP_PORT,COMMUNITY,WRITE_COMMUNITY,HOST_NETMASK,SYS_DESCR,SYS_OID,LOCATION,CONTACT,CONN_TABLE_TIMEOUT,CONGESTION_DETECT_MODE,SNTP_DURATION,SNTP_OFFSET,SNTP_PORT,SNTP_RETRIES,SNTP_TIMEOUT,TRHA_CONN_STATE,NMS_COMMUNITY,NMS_EVENT_METADATA,LOG_IMPORT_INTERVAL,AFC_LOG_LEVEL,TSE_LOG_THRESHOLD,TSE_LOG_PERIOD,SMTP_THRESHOLD,QUARANTINE_TIMEOUT,DNS_DOMAIN,PARENT_GROUP_ID,ZPHA_STATE,HA_FALLBACK_ACTION,HA_CONGESTION_THRESH,LB_LEARN_MODE,GATEWAY_NAMED_OBJ_ID,SMTP_SERVER_NAMED_OBJ_ID,SMTP_EMAIL_NAMED_OBJ_ID,TRHA_NAMED_OBJ_ID,PRIMARY_NTP_SERVER_NAMED_OBJ_ID,SECONDARY_NTP_SERVER_NAMED_OBJ_ID,DNS_PRIMARY_SERVER_NAMED_OBJ_ID,DNS_SECONDARY_SERVER_NAMED_OBJ_ID,IPV6_MGMT_ENABLED,IPV6_AUTO_CONFIG,IPV4_IP_ADDRESS,IPV6_IP_ADDRESS,IPV6_LINK_LOCAL_ADDRESS,IPV6_GATEWAY_NAMED_OBJ_ID,FIPS_MODE_ENABLED,FIPS_MODE_ACTIVE,HA_AUTO_RECOVER_HEARTBEAT_ENABLE,HA_AUTO_RECOVER_ILINK_ENABLE,HA_PERF_PROTECT_ENABLE,HA_PERF_PROTECT_AUTO_RESTORE_ENABLE,SNMP_VERSION,SNMP_CONFIG_VERSION,CONN_TABLE_NON_TCP_TIMEOUT,CONN_TABLE_TRUST_TIMEOUT,HW_SERIAL,ENTITLEMENT_VERSION,REMOTE_AUTH_ENABLED,REMOTE_AUTH_TIMEOUT,DEVICE_VERSION_DATA_XML,MAX_IOM_PORTS,TRHA_DEVICE_ID,TRHA_DEVICE_SERIAL,IPDB_SYNCED,DEVICE_MODEL_TYPE,HA_L2FB_PREF,GZIP_DECOMPRESSION,IDS_CONFIGURED,IDS_ACTIVE,HTTP_ENCODED_RESP,FLOW_STATUS,API_VERSION,REMOTE_RADIUS_AUTH_ENABLED,REMOTE_TACACS_AUTH_ENABLED,NXDOMAIN_ENABLED,NCR_ENCODE_ENABLED,HTTP_MODE_ENABLED,TRHA_PASSPHRASE,TRHA_ENCRYPTION_ENABLED,DEMO_MODE,DVT_UNINSTALL,STACKING_ENABLED,STACK_REDUNDANCY,REGISTERED_TIME,REGISTER_INSTANCE_ID,REGISTER_PROVIDER,REGISTER_LICENSE_TYPE,GENERIC_TELEMETRY_ENABLED,VNS_INSTALLED,VNS_REBOOT_REQUIRED,APPLY_DOMAIN_REP_TO_HTTP_TRAFFIC,APPLY_DOMAIN_REP_TO_TLS_SNI,APPLY_DOMAIN_REP_TO_DNS_TRAFFIC,SHORT_ID FROM TPT_DEVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptDeviceRow
	        err := rows.Scan(&r.ID, &r.DisplayName, &r.BitArray, &r.DeviceModel, &r.SoftwareVersion, &r.SerialNumber, &r.DestinationNetwork, &r.GatewayMask, &r.TimeStamp, &r.TimeZone, &r.DefaultPosture, &r.DeviceMode, &r.EmailAdmin, &r.NetworkMask, &r.SmtpDomain, &r.AttackSyncParams, &r.GlobalFallbackState, &r.GlobalFallbackCause, &r.GlobalFallbackTimeStamp, &r.DroppedThreshold, &r.IPAddress, &r.SnmpPort, &r.Community, &r.WriteCommunity, &r.HostNetmask, &r.SysDescr, &r.SysOid, &r.Location, &r.Contact, &r.ConnTableTimeout, &r.CongestionDetectMode, &r.SntpDuration, &r.SntpOffset, &r.SntpPort, &r.SntpRetries, &r.SntpTimeout, &r.TrhaConnState, &r.NmsCommunity, &r.NmsEventMetadata, &r.LogImportInterval, &r.AfcLogLevel, &r.TseLogThreshold, &r.TseLogPeriod, &r.SmtpThreshold, &r.QuarantineTimeout, &r.DnsDomain, &r.ParentGroupID, &r.ZphaState, &r.HaFallbackAction, &r.HaCongestionThresh, &r.LbLearnMode, &r.GatewayNamedObjID, &r.SmtpServerNamedObjID, &r.SmtpEmailNamedObjID, &r.TrhaNamedObjID, &r.PrimaryNtpServerNamedObjID, &r.SecondaryNtpServerNamedObjID, &r.DnsPrimaryServerNamedObjID, &r.DnsSecondaryServerNamedObjID, &r.Ipv6MgmtEnabled, &r.Ipv6AutoConfig, &r.Ipv4IPAddress, &r.Ipv6IPAddress, &r.Ipv6LinkLocalAddress, &r.Ipv6GatewayNamedObjID, &r.FipsModeEnabled, &r.FipsModeActive, &r.HaAutoRecoverHeartbeatEnable, &r.HaAutoRecoverIlinkEnable, &r.HaPerfProtectEnable, &r.HaPerfProtectAutoRestoreEnable, &r.SnmpVersion, &r.SnmpConfigVersion, &r.ConnTableNonTcpTimeout, &r.ConnTableTrustTimeout, &r.HwSerial, &r.EntitlementVersion, &r.RemoteAuthEnabled, &r.RemoteAuthTimeout, &r.DeviceVersionDataXml, &r.MaxIomPorts, &r.TrhaDeviceID, &r.TrhaDeviceSerial, &r.IpdbSynced, &r.DeviceModelType, &r.HaL2fbPref, &r.GzipDecompression, &r.IdsConfigured, &r.IdsActive, &r.HttpEncodedResp, &r.FlowStatus, &r.ApiVersion, &r.RemoteRadiusAuthEnabled, &r.RemoteTacacsAuthEnabled, &r.NxdomainEnabled, &r.NcrEncodeEnabled, &r.HttpModeEnabled, &r.TrhaPassphrase, &r.TrhaEncryptionEnabled, &r.DemoMode, &r.DvtUninstall, &r.StackingEnabled, &r.StackRedundancy, &r.RegisteredTime, &r.RegisterInstanceID, &r.RegisterProvider, &r.RegisterLicenseType, &r.GenericTelemetryEnabled, &r.VnsInstalled, &r.VnsRebootRequired, &r.ApplyDomainRepToHttpTraffic, &r.ApplyDomainRepToTlsSni, &r.ApplyDomainRepToDnsTraffic, &r.ShortID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptDeviceIDHistoryRow struct represents rows of the TPT_DEVICE_ID_HISTORY table.
type TptDeviceIDHistoryRow struct {
    Uuid	string
    ShortID	uint
    Touchtime	string
}

// IterateTptDeviceIDHistory provide access to all rows of the TPT_DEVICE_ID_HISTORY matching given criteria.
func IterateTptDeviceIDHistory(db *sql.DB, where string, callback func(v *TptDeviceIDHistoryRow) error) error {
    query := "SELECT UUID,SHORT_ID,TOUCHTIME FROM TPT_DEVICE_ID_HISTORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptDeviceIDHistoryRow
        err := rows.Scan(&r.Uuid, &r.ShortID, &r.Touchtime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptDeviceIDHistory provide iterator to all rows of the TPT_DEVICE_ID_HISTORY matching given criteria.
func RangeTptDeviceIDHistory(db *sql.DB, where string) iter.Seq2[*TptDeviceIDHistoryRow, error] {
	return func(yield func(v *TptDeviceIDHistoryRow, err error) bool) {
	    query := "SELECT UUID,SHORT_ID,TOUCHTIME FROM TPT_DEVICE_ID_HISTORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptDeviceIDHistoryRow
	        err := rows.Scan(&r.Uuid, &r.ShortID, &r.Touchtime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptDevicePerformanceRow struct represents rows of the TPT_DEVICE_PERFORMANCE table.
type TptDevicePerformanceRow struct {
    DeviceShortID	uint
    FilterPerformanceCorrelation	bool
}

// IterateTptDevicePerformance provide access to all rows of the TPT_DEVICE_PERFORMANCE matching given criteria.
func IterateTptDevicePerformance(db *sql.DB, where string, callback func(v *TptDevicePerformanceRow) error) error {
    query := "SELECT DEVICE_SHORT_ID,FILTER_PERFORMANCE_CORRELATION FROM TPT_DEVICE_PERFORMANCE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptDevicePerformanceRow
        err := rows.Scan(&r.DeviceShortID, &r.FilterPerformanceCorrelation)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptDevicePerformance provide iterator to all rows of the TPT_DEVICE_PERFORMANCE matching given criteria.
func RangeTptDevicePerformance(db *sql.DB, where string) iter.Seq2[*TptDevicePerformanceRow, error] {
	return func(yield func(v *TptDevicePerformanceRow, err error) bool) {
	    query := "SELECT DEVICE_SHORT_ID,FILTER_PERFORMANCE_CORRELATION FROM TPT_DEVICE_PERFORMANCE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptDevicePerformanceRow
	        err := rows.Scan(&r.DeviceShortID, &r.FilterPerformanceCorrelation)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptDeviceUserGroupsRow struct represents rows of the TPT_DEVICE_USER_GROUPS table.
type TptDeviceUserGroupsRow struct {
    UserGroupsIDFk	uint
    TptDeviceIDFk	string
}

// IterateTptDeviceUserGroups provide access to all rows of the TPT_DEVICE_USER_GROUPS matching given criteria.
func IterateTptDeviceUserGroups(db *sql.DB, where string, callback func(v *TptDeviceUserGroupsRow) error) error {
    query := "SELECT USER_GROUPS_ID_FK,TPT_DEVICE_ID_FK FROM TPT_DEVICE_USER_GROUPS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptDeviceUserGroupsRow
        err := rows.Scan(&r.UserGroupsIDFk, &r.TptDeviceIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptDeviceUserGroups provide iterator to all rows of the TPT_DEVICE_USER_GROUPS matching given criteria.
func RangeTptDeviceUserGroups(db *sql.DB, where string) iter.Seq2[*TptDeviceUserGroupsRow, error] {
	return func(yield func(v *TptDeviceUserGroupsRow, err error) bool) {
	    query := "SELECT USER_GROUPS_ID_FK,TPT_DEVICE_ID_FK FROM TPT_DEVICE_USER_GROUPS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptDeviceUserGroupsRow
	        err := rows.Scan(&r.UserGroupsIDFk, &r.TptDeviceIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptFanRow struct represents rows of the TPT_FAN table.
type TptFanRow struct {
    ID	string
    DisplayName	sql.NullString
    ParentID	string
    BitArray	sql.NullInt32
    FanSubunit	sql.NullInt64
    FanType	sql.NullInt32
    FanCfgType	sql.NullInt32
    FanRunState	sql.NullInt32
    FanQualifier1	sql.NullInt32
    FanQualifier2	sql.NullInt32
    FanQualifier3	sql.NullInt32
    FanQualifier4	sql.NullInt32
    FanStartTime	sql.NullInt64
    FanVendorID	sql.NullInt64
    FanDeviceID	sql.NullInt64
    FanProductID	sql.NullString
    FanFpgaVersion	sql.NullInt64
}

// IterateTptFan provide access to all rows of the TPT_FAN matching given criteria.
func IterateTptFan(db *sql.DB, where string, callback func(v *TptFanRow) error) error {
    query := "SELECT ID,DISPLAY_NAME,PARENT_ID,BIT_ARRAY,FAN_SUBUNIT,FAN_TYPE,FAN_CFG_TYPE,FAN_RUN_STATE,FAN_QUALIFIER_1,FAN_QUALIFIER_2,FAN_QUALIFIER_3,FAN_QUALIFIER_4,FAN_START_TIME,FAN_VENDOR_ID,FAN_DEVICE_ID,FAN_PRODUCT_ID,FAN_FPGA_VERSION FROM TPT_FAN"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptFanRow
        err := rows.Scan(&r.ID, &r.DisplayName, &r.ParentID, &r.BitArray, &r.FanSubunit, &r.FanType, &r.FanCfgType, &r.FanRunState, &r.FanQualifier1, &r.FanQualifier2, &r.FanQualifier3, &r.FanQualifier4, &r.FanStartTime, &r.FanVendorID, &r.FanDeviceID, &r.FanProductID, &r.FanFpgaVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptFan provide iterator to all rows of the TPT_FAN matching given criteria.
func RangeTptFan(db *sql.DB, where string) iter.Seq2[*TptFanRow, error] {
	return func(yield func(v *TptFanRow, err error) bool) {
	    query := "SELECT ID,DISPLAY_NAME,PARENT_ID,BIT_ARRAY,FAN_SUBUNIT,FAN_TYPE,FAN_CFG_TYPE,FAN_RUN_STATE,FAN_QUALIFIER_1,FAN_QUALIFIER_2,FAN_QUALIFIER_3,FAN_QUALIFIER_4,FAN_START_TIME,FAN_VENDOR_ID,FAN_DEVICE_ID,FAN_PRODUCT_ID,FAN_FPGA_VERSION FROM TPT_FAN"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptFanRow
	        err := rows.Scan(&r.ID, &r.DisplayName, &r.ParentID, &r.BitArray, &r.FanSubunit, &r.FanType, &r.FanCfgType, &r.FanRunState, &r.FanQualifier1, &r.FanQualifier2, &r.FanQualifier3, &r.FanQualifier4, &r.FanStartTime, &r.FanVendorID, &r.FanDeviceID, &r.FanProductID, &r.FanFpgaVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptGroupRow struct represents rows of the TPT_GROUP table.
type TptGroupRow struct {
    ID	string
    DisplayName	sql.NullString
    BitArray	sql.NullInt32
    GroupType	sql.NullInt32
    ProfileID	sql.NullString
    Description	sql.NullString
}

// IterateTptGroup provide access to all rows of the TPT_GROUP matching given criteria.
func IterateTptGroup(db *sql.DB, where string, callback func(v *TptGroupRow) error) error {
    query := "SELECT ID,DISPLAY_NAME,BIT_ARRAY,GROUP_TYPE,PROFILE_ID,DESCRIPTION FROM TPT_GROUP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptGroupRow
        err := rows.Scan(&r.ID, &r.DisplayName, &r.BitArray, &r.GroupType, &r.ProfileID, &r.Description)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptGroup provide iterator to all rows of the TPT_GROUP matching given criteria.
func RangeTptGroup(db *sql.DB, where string) iter.Seq2[*TptGroupRow, error] {
	return func(yield func(v *TptGroupRow, err error) bool) {
	    query := "SELECT ID,DISPLAY_NAME,BIT_ARRAY,GROUP_TYPE,PROFILE_ID,DESCRIPTION FROM TPT_GROUP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptGroupRow
	        err := rows.Scan(&r.ID, &r.DisplayName, &r.BitArray, &r.GroupType, &r.ProfileID, &r.Description)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptGroupUserGroupsRow struct represents rows of the TPT_GROUP_USER_GROUPS table.
type TptGroupUserGroupsRow struct {
    UserGroupsIDFk	uint
    TptGroupIDFk	string
}

// IterateTptGroupUserGroups provide access to all rows of the TPT_GROUP_USER_GROUPS matching given criteria.
func IterateTptGroupUserGroups(db *sql.DB, where string, callback func(v *TptGroupUserGroupsRow) error) error {
    query := "SELECT USER_GROUPS_ID_FK,TPT_GROUP_ID_FK FROM TPT_GROUP_USER_GROUPS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptGroupUserGroupsRow
        err := rows.Scan(&r.UserGroupsIDFk, &r.TptGroupIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptGroupUserGroups provide iterator to all rows of the TPT_GROUP_USER_GROUPS matching given criteria.
func RangeTptGroupUserGroups(db *sql.DB, where string) iter.Seq2[*TptGroupUserGroupsRow, error] {
	return func(yield func(v *TptGroupUserGroupsRow, err error) bool) {
	    query := "SELECT USER_GROUPS_ID_FK,TPT_GROUP_ID_FK FROM TPT_GROUP_USER_GROUPS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptGroupUserGroupsRow
	        err := rows.Scan(&r.UserGroupsIDFk, &r.TptGroupIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptPkgRow struct represents rows of the TPT_PKG table.
type TptPkgRow struct {
    ID	string
    Version	string
    Type	string
    SubType	sql.NullString
    Filename	string
    DownloadTime	int64
    DownloadTimestamp	string
    CreationTime	int64
    RelnotesMimeType	sql.NullString
    RelnotesModifiedTime	sql.NullString
    RelnotesContent	sql.NullString
    HighEncryptPkg	sql.NullByte
    PkgBranding	sql.NullString
    Models	sql.NullString
    PkgID	sql.NullString
}

// IterateTptPkg provide access to all rows of the TPT_PKG matching given criteria.
func IterateTptPkg(db *sql.DB, where string, callback func(v *TptPkgRow) error) error {
    query := "SELECT ID,VERSION,TYPE,SUB_TYPE,FILENAME,DOWNLOAD_TIME,DOWNLOAD_TIMESTAMP,CREATION_TIME,RELNOTES_MIME_TYPE,RELNOTES_MODIFIED_TIME,RELNOTES_CONTENT,HIGH_ENCRYPT_PKG,PKG_BRANDING,MODELS,PKG_ID FROM TPT_PKG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptPkgRow
        err := rows.Scan(&r.ID, &r.Version, &r.Type, &r.SubType, &r.Filename, &r.DownloadTime, &r.DownloadTimestamp, &r.CreationTime, &r.RelnotesMimeType, &r.RelnotesModifiedTime, &r.RelnotesContent, &r.HighEncryptPkg, &r.PkgBranding, &r.Models, &r.PkgID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptPkg provide iterator to all rows of the TPT_PKG matching given criteria.
func RangeTptPkg(db *sql.DB, where string) iter.Seq2[*TptPkgRow, error] {
	return func(yield func(v *TptPkgRow, err error) bool) {
	    query := "SELECT ID,VERSION,TYPE,SUB_TYPE,FILENAME,DOWNLOAD_TIME,DOWNLOAD_TIMESTAMP,CREATION_TIME,RELNOTES_MIME_TYPE,RELNOTES_MODIFIED_TIME,RELNOTES_CONTENT,HIGH_ENCRYPT_PKG,PKG_BRANDING,MODELS,PKG_ID FROM TPT_PKG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptPkgRow
	        err := rows.Scan(&r.ID, &r.Version, &r.Type, &r.SubType, &r.Filename, &r.DownloadTime, &r.DownloadTimestamp, &r.CreationTime, &r.RelnotesMimeType, &r.RelnotesModifiedTime, &r.RelnotesContent, &r.HighEncryptPkg, &r.PkgBranding, &r.Models, &r.PkgID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptPkgLatestRow struct represents rows of the TPT_PKG_LATEST table.
type TptPkgLatestRow struct {
    ID	string
    Version	string
    Type	string
    SubType	sql.NullString
}

// IterateTptPkgLatest provide access to all rows of the TPT_PKG_LATEST matching given criteria.
func IterateTptPkgLatest(db *sql.DB, where string, callback func(v *TptPkgLatestRow) error) error {
    query := "SELECT ID,VERSION,TYPE,SUB_TYPE FROM TPT_PKG_LATEST"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptPkgLatestRow
        err := rows.Scan(&r.ID, &r.Version, &r.Type, &r.SubType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptPkgLatest provide iterator to all rows of the TPT_PKG_LATEST matching given criteria.
func RangeTptPkgLatest(db *sql.DB, where string) iter.Seq2[*TptPkgLatestRow, error] {
	return func(yield func(v *TptPkgLatestRow, err error) bool) {
	    query := "SELECT ID,VERSION,TYPE,SUB_TYPE FROM TPT_PKG_LATEST"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptPkgLatestRow
	        err := rows.Scan(&r.ID, &r.Version, &r.Type, &r.SubType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptPkgUserGroupsRow struct represents rows of the TPT_PKG_USER_GROUPS table.
type TptPkgUserGroupsRow struct {
    UserGroupsIDFk	uint
    TptPkgIDFk	string
}

// IterateTptPkgUserGroups provide access to all rows of the TPT_PKG_USER_GROUPS matching given criteria.
func IterateTptPkgUserGroups(db *sql.DB, where string, callback func(v *TptPkgUserGroupsRow) error) error {
    query := "SELECT USER_GROUPS_ID_FK,TPT_PKG_ID_FK FROM TPT_PKG_USER_GROUPS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptPkgUserGroupsRow
        err := rows.Scan(&r.UserGroupsIDFk, &r.TptPkgIDFk)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptPkgUserGroups provide iterator to all rows of the TPT_PKG_USER_GROUPS matching given criteria.
func RangeTptPkgUserGroups(db *sql.DB, where string) iter.Seq2[*TptPkgUserGroupsRow, error] {
	return func(yield func(v *TptPkgUserGroupsRow, err error) bool) {
	    query := "SELECT USER_GROUPS_ID_FK,TPT_PKG_ID_FK FROM TPT_PKG_USER_GROUPS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptPkgUserGroupsRow
	        err := rows.Scan(&r.UserGroupsIDFk, &r.TptPkgIDFk)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptPkgUserLatestRow struct represents rows of the TPT_PKG_USER_LATEST table.
type TptPkgUserLatestRow struct {
    UpdateTime	int64
    Modified	string
    LastBuiltVersion	sql.NullString
    Type	string
}

// IterateTptPkgUserLatest provide access to all rows of the TPT_PKG_USER_LATEST matching given criteria.
func IterateTptPkgUserLatest(db *sql.DB, where string, callback func(v *TptPkgUserLatestRow) error) error {
    query := "SELECT UPDATE_TIME,MODIFIED,LAST_BUILT_VERSION,TYPE FROM TPT_PKG_USER_LATEST"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptPkgUserLatestRow
        err := rows.Scan(&r.UpdateTime, &r.Modified, &r.LastBuiltVersion, &r.Type)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptPkgUserLatest provide iterator to all rows of the TPT_PKG_USER_LATEST matching given criteria.
func RangeTptPkgUserLatest(db *sql.DB, where string) iter.Seq2[*TptPkgUserLatestRow, error] {
	return func(yield func(v *TptPkgUserLatestRow, err error) bool) {
	    query := "SELECT UPDATE_TIME,MODIFIED,LAST_BUILT_VERSION,TYPE FROM TPT_PKG_USER_LATEST"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptPkgUserLatestRow
	        err := rows.Scan(&r.UpdateTime, &r.Modified, &r.LastBuiltVersion, &r.Type)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptPortRow struct represents rows of the TPT_PORT table.
type TptPortRow struct {
    ID	string
    DisplayName	sql.NullString
    ParentID	string
    BitArray	sql.NullInt32
    ParentDeviceKey	string
    PortType	sql.NullString
    PortSegmentKey	sql.NullString
    PortAutoNegotiation	sql.NullInt32
    PortDuplex	sql.NullInt32
    PortLineSpeed	sql.NullInt32
    PortNegDuplex	sql.NullInt32
    PortNegLineSpeed	sql.NullInt32
    PortEnabled	sql.NullInt32
    PortSlotNumber	sql.NullInt64
    PortNumber	sql.NullInt64
    PortSlotType	sql.NullInt32
    PortCfgType	sql.NullInt32
    PortRunState	sql.NullInt32
    PortQualifier1	sql.NullInt32
    PortQualifier2	sql.NullInt32
    PortQualifier3	sql.NullInt32
    PortQualifier4	sql.NullInt32
    PortStartTime	sql.NullInt64
    PortDeviceID	sql.NullInt32
    PortLineType	sql.NullInt64
    IfDescr	sql.NullString
    IfIndex	sql.NullInt32
    IfSpeed	sql.NullInt32
    SysOid	sql.NullString
    PhysAddr	sql.NullString
    ParentNode	sql.NullString
    IPAddress	sql.NullString
    Community	sql.NullString
    WriteCommunity	sql.NullString
    LinkState	sql.NullInt32
    PortMphy	sql.NullInt32
    MgmtPortVLAN	sql.NullInt32
    MappedPhysicalPortUuid	sql.NullString
    BayNumber	sql.NullInt32
    SfpQualifier1	sql.NullByte
    SfpQualifier2	sql.NullByte
    TransceiverIdentifier	sql.NullString
    TransceiverConnector	sql.NullString
    TransceiverCompliance	sql.NullString
    TransceiverTechnology	sql.NullString
}

// IterateTptPort provide access to all rows of the TPT_PORT matching given criteria.
func IterateTptPort(db *sql.DB, where string, callback func(v *TptPortRow) error) error {
    query := "SELECT ID,DISPLAY_NAME,PARENT_ID,BIT_ARRAY,PARENT_DEVICE_KEY,PORT_TYPE,PORT_SEGMENT_KEY,PORT_AUTO_NEGOTIATION,PORT_DUPLEX,PORT_LINE_SPEED,PORT_NEG_DUPLEX,PORT_NEG_LINE_SPEED,PORT_ENABLED,PORT_SLOT_NUMBER,PORT_NUMBER,PORT_SLOT_TYPE,PORT_CFG_TYPE,PORT_RUN_STATE,PORT_QUALIFIER_1,PORT_QUALIFIER_2,PORT_QUALIFIER_3,PORT_QUALIFIER_4,PORT_START_TIME,PORT_DEVICE_ID,PORT_LINE_TYPE,IF_DESCR,IF_INDEX,IF_SPEED,SYS_OID,PHYS_ADDR,PARENT_NODE,IP_ADDRESS,COMMUNITY,WRITE_COMMUNITY,LINK_STATE,PORT_MPHY,MGMT_PORT_VLAN,MAPPED_PHYSICAL_PORT_UUID,BAY_NUMBER,SFP_QUALIFIER_1,SFP_QUALIFIER_2,TRANSCEIVER_IDENTIFIER,TRANSCEIVER_CONNECTOR,TRANSCEIVER_COMPLIANCE,TRANSCEIVER_TECHNOLOGY FROM TPT_PORT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptPortRow
        err := rows.Scan(&r.ID, &r.DisplayName, &r.ParentID, &r.BitArray, &r.ParentDeviceKey, &r.PortType, &r.PortSegmentKey, &r.PortAutoNegotiation, &r.PortDuplex, &r.PortLineSpeed, &r.PortNegDuplex, &r.PortNegLineSpeed, &r.PortEnabled, &r.PortSlotNumber, &r.PortNumber, &r.PortSlotType, &r.PortCfgType, &r.PortRunState, &r.PortQualifier1, &r.PortQualifier2, &r.PortQualifier3, &r.PortQualifier4, &r.PortStartTime, &r.PortDeviceID, &r.PortLineType, &r.IfDescr, &r.IfIndex, &r.IfSpeed, &r.SysOid, &r.PhysAddr, &r.ParentNode, &r.IPAddress, &r.Community, &r.WriteCommunity, &r.LinkState, &r.PortMphy, &r.MgmtPortVLAN, &r.MappedPhysicalPortUuid, &r.BayNumber, &r.SfpQualifier1, &r.SfpQualifier2, &r.TransceiverIdentifier, &r.TransceiverConnector, &r.TransceiverCompliance, &r.TransceiverTechnology)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptPort provide iterator to all rows of the TPT_PORT matching given criteria.
func RangeTptPort(db *sql.DB, where string) iter.Seq2[*TptPortRow, error] {
	return func(yield func(v *TptPortRow, err error) bool) {
	    query := "SELECT ID,DISPLAY_NAME,PARENT_ID,BIT_ARRAY,PARENT_DEVICE_KEY,PORT_TYPE,PORT_SEGMENT_KEY,PORT_AUTO_NEGOTIATION,PORT_DUPLEX,PORT_LINE_SPEED,PORT_NEG_DUPLEX,PORT_NEG_LINE_SPEED,PORT_ENABLED,PORT_SLOT_NUMBER,PORT_NUMBER,PORT_SLOT_TYPE,PORT_CFG_TYPE,PORT_RUN_STATE,PORT_QUALIFIER_1,PORT_QUALIFIER_2,PORT_QUALIFIER_3,PORT_QUALIFIER_4,PORT_START_TIME,PORT_DEVICE_ID,PORT_LINE_TYPE,IF_DESCR,IF_INDEX,IF_SPEED,SYS_OID,PHYS_ADDR,PARENT_NODE,IP_ADDRESS,COMMUNITY,WRITE_COMMUNITY,LINK_STATE,PORT_MPHY,MGMT_PORT_VLAN,MAPPED_PHYSICAL_PORT_UUID,BAY_NUMBER,SFP_QUALIFIER_1,SFP_QUALIFIER_2,TRANSCEIVER_IDENTIFIER,TRANSCEIVER_CONNECTOR,TRANSCEIVER_COMPLIANCE,TRANSCEIVER_TECHNOLOGY FROM TPT_PORT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptPortRow
	        err := rows.Scan(&r.ID, &r.DisplayName, &r.ParentID, &r.BitArray, &r.ParentDeviceKey, &r.PortType, &r.PortSegmentKey, &r.PortAutoNegotiation, &r.PortDuplex, &r.PortLineSpeed, &r.PortNegDuplex, &r.PortNegLineSpeed, &r.PortEnabled, &r.PortSlotNumber, &r.PortNumber, &r.PortSlotType, &r.PortCfgType, &r.PortRunState, &r.PortQualifier1, &r.PortQualifier2, &r.PortQualifier3, &r.PortQualifier4, &r.PortStartTime, &r.PortDeviceID, &r.PortLineType, &r.IfDescr, &r.IfIndex, &r.IfSpeed, &r.SysOid, &r.PhysAddr, &r.ParentNode, &r.IPAddress, &r.Community, &r.WriteCommunity, &r.LinkState, &r.PortMphy, &r.MgmtPortVLAN, &r.MappedPhysicalPortUuid, &r.BayNumber, &r.SfpQualifier1, &r.SfpQualifier2, &r.TransceiverIdentifier, &r.TransceiverConnector, &r.TransceiverCompliance, &r.TransceiverTechnology)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptPortConfigCapabilityRow struct represents rows of the TPT_PORT_CONFIG_CAPABILITY table.
type TptPortConfigCapabilityRow struct {
    PortInfoIDFk	string
    SupportsAutoNeg	int8
    SupportsF10m	int8
    SupportsH10m	int8
    SupportsF100m	int8
    SupportsH100m	int8
    SupportsF1g	int8
    SupportsH1g	int8
    SupportsF10g	int8
    SupportsH10g	int8
    SupportsF40g	int8
    SupportsH40g	int8
    SupportsF25g	int8
    SupportsF100g	int8
}

// IterateTptPortConfigCapability provide access to all rows of the TPT_PORT_CONFIG_CAPABILITY matching given criteria.
func IterateTptPortConfigCapability(db *sql.DB, where string, callback func(v *TptPortConfigCapabilityRow) error) error {
    query := "SELECT PORT_INFO_ID_FK,SUPPORTS_AUTO_NEG,SUPPORTS_F10M,SUPPORTS_H10M,SUPPORTS_F100M,SUPPORTS_H100M,SUPPORTS_F1G,SUPPORTS_H1G,SUPPORTS_F10G,SUPPORTS_H10G,SUPPORTS_F40G,SUPPORTS_H40G,SUPPORTS_F25G,SUPPORTS_F100G FROM TPT_PORT_CONFIG_CAPABILITY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptPortConfigCapabilityRow
        err := rows.Scan(&r.PortInfoIDFk, &r.SupportsAutoNeg, &r.SupportsF10m, &r.SupportsH10m, &r.SupportsF100m, &r.SupportsH100m, &r.SupportsF1g, &r.SupportsH1g, &r.SupportsF10g, &r.SupportsH10g, &r.SupportsF40g, &r.SupportsH40g, &r.SupportsF25g, &r.SupportsF100g)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptPortConfigCapability provide iterator to all rows of the TPT_PORT_CONFIG_CAPABILITY matching given criteria.
func RangeTptPortConfigCapability(db *sql.DB, where string) iter.Seq2[*TptPortConfigCapabilityRow, error] {
	return func(yield func(v *TptPortConfigCapabilityRow, err error) bool) {
	    query := "SELECT PORT_INFO_ID_FK,SUPPORTS_AUTO_NEG,SUPPORTS_F10M,SUPPORTS_H10M,SUPPORTS_F100M,SUPPORTS_H100M,SUPPORTS_F1G,SUPPORTS_H1G,SUPPORTS_F10G,SUPPORTS_H10G,SUPPORTS_F40G,SUPPORTS_H40G,SUPPORTS_F25G,SUPPORTS_F100G FROM TPT_PORT_CONFIG_CAPABILITY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptPortConfigCapabilityRow
	        err := rows.Scan(&r.PortInfoIDFk, &r.SupportsAutoNeg, &r.SupportsF10m, &r.SupportsH10m, &r.SupportsF100m, &r.SupportsH100m, &r.SupportsF1g, &r.SupportsH1g, &r.SupportsF10g, &r.SupportsH10g, &r.SupportsF40g, &r.SupportsH40g, &r.SupportsF25g, &r.SupportsF100g)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptPowerEntryModuleRow struct represents rows of the TPT_POWER_ENTRY_MODULE table.
type TptPowerEntryModuleRow struct {
    ID	string
    DisplayName	sql.NullString
    ParentID	string
    BitArray	sql.NullInt32
    PemNumber	sql.NullInt64
    PemType	sql.NullInt32
    PemCfgType	sql.NullInt32
    PemRunState	sql.NullInt32
    PemQualifier1	sql.NullInt32
    PemQualifier2	sql.NullInt32
    PemQualifier3	sql.NullInt32
    PemQualifier4	sql.NullInt32
    PemStartTime	sql.NullInt64
    PemVendorID	sql.NullInt64
    PemDeviceID	sql.NullInt64
    PemProductID	sql.NullString
    PemFpgaVersion	sql.NullInt64
}

// IterateTptPowerEntryModule provide access to all rows of the TPT_POWER_ENTRY_MODULE matching given criteria.
func IterateTptPowerEntryModule(db *sql.DB, where string, callback func(v *TptPowerEntryModuleRow) error) error {
    query := "SELECT ID,DISPLAY_NAME,PARENT_ID,BIT_ARRAY,PEM_NUMBER,PEM_TYPE,PEM_CFG_TYPE,PEM_RUN_STATE,PEM_QUALIFIER_1,PEM_QUALIFIER_2,PEM_QUALIFIER_3,PEM_QUALIFIER_4,PEM_START_TIME,PEM_VENDOR_ID,PEM_DEVICE_ID,PEM_PRODUCT_ID,PEM_FPGA_VERSION FROM TPT_POWER_ENTRY_MODULE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptPowerEntryModuleRow
        err := rows.Scan(&r.ID, &r.DisplayName, &r.ParentID, &r.BitArray, &r.PemNumber, &r.PemType, &r.PemCfgType, &r.PemRunState, &r.PemQualifier1, &r.PemQualifier2, &r.PemQualifier3, &r.PemQualifier4, &r.PemStartTime, &r.PemVendorID, &r.PemDeviceID, &r.PemProductID, &r.PemFpgaVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptPowerEntryModule provide iterator to all rows of the TPT_POWER_ENTRY_MODULE matching given criteria.
func RangeTptPowerEntryModule(db *sql.DB, where string) iter.Seq2[*TptPowerEntryModuleRow, error] {
	return func(yield func(v *TptPowerEntryModuleRow, err error) bool) {
	    query := "SELECT ID,DISPLAY_NAME,PARENT_ID,BIT_ARRAY,PEM_NUMBER,PEM_TYPE,PEM_CFG_TYPE,PEM_RUN_STATE,PEM_QUALIFIER_1,PEM_QUALIFIER_2,PEM_QUALIFIER_3,PEM_QUALIFIER_4,PEM_START_TIME,PEM_VENDOR_ID,PEM_DEVICE_ID,PEM_PRODUCT_ID,PEM_FPGA_VERSION FROM TPT_POWER_ENTRY_MODULE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptPowerEntryModuleRow
	        err := rows.Scan(&r.ID, &r.DisplayName, &r.ParentID, &r.BitArray, &r.PemNumber, &r.PemType, &r.PemCfgType, &r.PemRunState, &r.PemQualifier1, &r.PemQualifier2, &r.PemQualifier3, &r.PemQualifier4, &r.PemStartTime, &r.PemVendorID, &r.PemDeviceID, &r.PemProductID, &r.PemFpgaVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptPowerSupplyRow struct represents rows of the TPT_POWER_SUPPLY table.
type TptPowerSupplyRow struct {
    ID	string
    DisplayName	sql.NullString
    ParentID	string
    BitArray	sql.NullInt32
    PsSubunit	sql.NullInt64
    PsType	sql.NullInt32
    PsCfgType	sql.NullInt32
    PsRunState	sql.NullInt32
    PsQualifier1	sql.NullInt32
    PsQualifier2	sql.NullInt32
    PsQualifier3	sql.NullInt32
    PsQualifier4	sql.NullInt32
    PsStartTime	sql.NullInt64
    PsVendorID	sql.NullInt64
    PsDeviceID	sql.NullInt64
    PsProductID	sql.NullString
    PsFpgaVersion	sql.NullInt64
}

// IterateTptPowerSupply provide access to all rows of the TPT_POWER_SUPPLY matching given criteria.
func IterateTptPowerSupply(db *sql.DB, where string, callback func(v *TptPowerSupplyRow) error) error {
    query := "SELECT ID,DISPLAY_NAME,PARENT_ID,BIT_ARRAY,PS_SUBUNIT,PS_TYPE,PS_CFG_TYPE,PS_RUN_STATE,PS_QUALIFIER_1,PS_QUALIFIER_2,PS_QUALIFIER_3,PS_QUALIFIER_4,PS_START_TIME,PS_VENDOR_ID,PS_DEVICE_ID,PS_PRODUCT_ID,PS_FPGA_VERSION FROM TPT_POWER_SUPPLY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptPowerSupplyRow
        err := rows.Scan(&r.ID, &r.DisplayName, &r.ParentID, &r.BitArray, &r.PsSubunit, &r.PsType, &r.PsCfgType, &r.PsRunState, &r.PsQualifier1, &r.PsQualifier2, &r.PsQualifier3, &r.PsQualifier4, &r.PsStartTime, &r.PsVendorID, &r.PsDeviceID, &r.PsProductID, &r.PsFpgaVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptPowerSupply provide iterator to all rows of the TPT_POWER_SUPPLY matching given criteria.
func RangeTptPowerSupply(db *sql.DB, where string) iter.Seq2[*TptPowerSupplyRow, error] {
	return func(yield func(v *TptPowerSupplyRow, err error) bool) {
	    query := "SELECT ID,DISPLAY_NAME,PARENT_ID,BIT_ARRAY,PS_SUBUNIT,PS_TYPE,PS_CFG_TYPE,PS_RUN_STATE,PS_QUALIFIER_1,PS_QUALIFIER_2,PS_QUALIFIER_3,PS_QUALIFIER_4,PS_START_TIME,PS_VENDOR_ID,PS_DEVICE_ID,PS_PRODUCT_ID,PS_FPGA_VERSION FROM TPT_POWER_SUPPLY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptPowerSupplyRow
	        err := rows.Scan(&r.ID, &r.DisplayName, &r.ParentID, &r.BitArray, &r.PsSubunit, &r.PsType, &r.PsCfgType, &r.PsRunState, &r.PsQualifier1, &r.PsQualifier2, &r.PsQualifier3, &r.PsQualifier4, &r.PsStartTime, &r.PsVendorID, &r.PsDeviceID, &r.PsProductID, &r.PsFpgaVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptSegmentRow struct represents rows of the TPT_SEGMENT table.
type TptSegmentRow struct {
    ID	string
    DisplayName	sql.NullString
    DeviceShortID	sql.NullInt32
    DeviceID	string
    BitArray	sql.NullInt32
    DefaultName	sql.NullString
    IPAddress	sql.NullString
    Netmask	sql.NullString
    SegmentIndex	sql.NullInt32
    SegmentSlot	sql.NullInt32
    Dtype	sql.NullString
    PortA	sql.NullString
    PortB	sql.NullString
    FallbackMode	sql.NullInt32
    LinkdownWaittime	sql.NullInt32
    LinkdownState	sql.NullInt32
    SegmentID	sql.NullInt32
    ZoneA	sql.NullInt32
    ZoneB	sql.NullInt32
    VLANNamedObjID	sql.NullInt32
    ZphaPresence	sql.NullInt16
    InZpha	sql.NullByte
    ZphaAction	sql.NullInt16
    SegmentFailoverThreshold	sql.NullInt32
    UplinkOwnerUuid	sql.NullString
    SegmentEnabled	sql.NullByte
    HashAlgorithmNumber	sql.NullInt32
    SegmentState	sql.NullInt32
    SegmentQualifier1	sql.NullInt32
    GlobalVirtualSegmentID	sql.NullInt32
    SrcIPNamedObjID	sql.NullInt32
    DstIPNamedObjID	sql.NullInt32
    DeviceVsegPosition	sql.NullInt32
    DeviceVsegIterationID	sql.NullInt32
    ZphaMode	int8
    BayNumber	sql.NullInt32
    FlowStatus	int8
    FlowSamplingRate	sql.NullInt32
    FlowChangedBy	sql.NullString
    PortaIpaddrNamedObjID	sql.NullInt32
    PortbIpaddrNamedObjID	sql.NullInt32
    Description	sql.NullString
}

// IterateTptSegment provide access to all rows of the TPT_SEGMENT matching given criteria.
func IterateTptSegment(db *sql.DB, where string, callback func(v *TptSegmentRow) error) error {
    query := "SELECT ID,DISPLAY_NAME,DEVICE_SHORT_ID,DEVICE_ID,BIT_ARRAY,DEFAULT_NAME,IP_ADDRESS,NETMASK,SEGMENT_INDEX,SEGMENT_SLOT,DTYPE,PORT_A,PORT_B,FALLBACK_MODE,LINKDOWN_WAITTIME,LINKDOWN_STATE,SEGMENT_ID,ZONE_A,ZONE_B,VLAN_NAMED_OBJ_ID,ZPHA_PRESENCE,IN_ZPHA,ZPHA_ACTION,SEGMENT_FAILOVER_THRESHOLD,UPLINK_OWNER_UUID,SEGMENT_ENABLED,HASH_ALGORITHM_NUMBER,SEGMENT_STATE,SEGMENT_QUALIFIER_1,GLOBAL_VIRTUAL_SEGMENT_ID,SRC_IP_NAMED_OBJ_ID,DST_IP_NAMED_OBJ_ID,DEVICE_VSEG_POSITION,DEVICE_VSEG_ITERATION_ID,ZPHA_MODE,BAY_NUMBER,FLOW_STATUS,FLOW_SAMPLING_RATE,FLOW_CHANGED_BY,PORTA_IPADDR_NAMED_OBJ_ID,PORTB_IPADDR_NAMED_OBJ_ID,DESCRIPTION FROM TPT_SEGMENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptSegmentRow
        err := rows.Scan(&r.ID, &r.DisplayName, &r.DeviceShortID, &r.DeviceID, &r.BitArray, &r.DefaultName, &r.IPAddress, &r.Netmask, &r.SegmentIndex, &r.SegmentSlot, &r.Dtype, &r.PortA, &r.PortB, &r.FallbackMode, &r.LinkdownWaittime, &r.LinkdownState, &r.SegmentID, &r.ZoneA, &r.ZoneB, &r.VLANNamedObjID, &r.ZphaPresence, &r.InZpha, &r.ZphaAction, &r.SegmentFailoverThreshold, &r.UplinkOwnerUuid, &r.SegmentEnabled, &r.HashAlgorithmNumber, &r.SegmentState, &r.SegmentQualifier1, &r.GlobalVirtualSegmentID, &r.SrcIPNamedObjID, &r.DstIPNamedObjID, &r.DeviceVsegPosition, &r.DeviceVsegIterationID, &r.ZphaMode, &r.BayNumber, &r.FlowStatus, &r.FlowSamplingRate, &r.FlowChangedBy, &r.PortaIpaddrNamedObjID, &r.PortbIpaddrNamedObjID, &r.Description)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptSegment provide iterator to all rows of the TPT_SEGMENT matching given criteria.
func RangeTptSegment(db *sql.DB, where string) iter.Seq2[*TptSegmentRow, error] {
	return func(yield func(v *TptSegmentRow, err error) bool) {
	    query := "SELECT ID,DISPLAY_NAME,DEVICE_SHORT_ID,DEVICE_ID,BIT_ARRAY,DEFAULT_NAME,IP_ADDRESS,NETMASK,SEGMENT_INDEX,SEGMENT_SLOT,DTYPE,PORT_A,PORT_B,FALLBACK_MODE,LINKDOWN_WAITTIME,LINKDOWN_STATE,SEGMENT_ID,ZONE_A,ZONE_B,VLAN_NAMED_OBJ_ID,ZPHA_PRESENCE,IN_ZPHA,ZPHA_ACTION,SEGMENT_FAILOVER_THRESHOLD,UPLINK_OWNER_UUID,SEGMENT_ENABLED,HASH_ALGORITHM_NUMBER,SEGMENT_STATE,SEGMENT_QUALIFIER_1,GLOBAL_VIRTUAL_SEGMENT_ID,SRC_IP_NAMED_OBJ_ID,DST_IP_NAMED_OBJ_ID,DEVICE_VSEG_POSITION,DEVICE_VSEG_ITERATION_ID,ZPHA_MODE,BAY_NUMBER,FLOW_STATUS,FLOW_SAMPLING_RATE,FLOW_CHANGED_BY,PORTA_IPADDR_NAMED_OBJ_ID,PORTB_IPADDR_NAMED_OBJ_ID,DESCRIPTION FROM TPT_SEGMENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptSegmentRow
	        err := rows.Scan(&r.ID, &r.DisplayName, &r.DeviceShortID, &r.DeviceID, &r.BitArray, &r.DefaultName, &r.IPAddress, &r.Netmask, &r.SegmentIndex, &r.SegmentSlot, &r.Dtype, &r.PortA, &r.PortB, &r.FallbackMode, &r.LinkdownWaittime, &r.LinkdownState, &r.SegmentID, &r.ZoneA, &r.ZoneB, &r.VLANNamedObjID, &r.ZphaPresence, &r.InZpha, &r.ZphaAction, &r.SegmentFailoverThreshold, &r.UplinkOwnerUuid, &r.SegmentEnabled, &r.HashAlgorithmNumber, &r.SegmentState, &r.SegmentQualifier1, &r.GlobalVirtualSegmentID, &r.SrcIPNamedObjID, &r.DstIPNamedObjID, &r.DeviceVsegPosition, &r.DeviceVsegIterationID, &r.ZphaMode, &r.BayNumber, &r.FlowStatus, &r.FlowSamplingRate, &r.FlowChangedBy, &r.PortaIpaddrNamedObjID, &r.PortbIpaddrNamedObjID, &r.Description)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TptSlotRow struct represents rows of the TPT_SLOT table.
type TptSlotRow struct {
    ID	string
    DisplayName	sql.NullString
    ParentID	string
    BitArray	sql.NullInt32
    SlotNumber	sql.NullInt64
    SlotType	sql.NullInt32
    BayNumber	sql.NullInt32
    BayName	sql.NullString
    BayModuleDescription	sql.NullString
    BayStatusType	sql.NullByte
    BayModuleSerial	sql.NullString
    BayModuleType	sql.NullByte
    BypassEnabled	sql.NullByte
}

// IterateTptSlot provide access to all rows of the TPT_SLOT matching given criteria.
func IterateTptSlot(db *sql.DB, where string, callback func(v *TptSlotRow) error) error {
    query := "SELECT ID,DISPLAY_NAME,PARENT_ID,BIT_ARRAY,SLOT_NUMBER,SLOT_TYPE,BAY_NUMBER,BAY_NAME,BAY_MODULE_DESCRIPTION,BAY_STATUS_TYPE,BAY_MODULE_SERIAL,BAY_MODULE_TYPE,BYPASS_ENABLED FROM TPT_SLOT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TptSlotRow
        err := rows.Scan(&r.ID, &r.DisplayName, &r.ParentID, &r.BitArray, &r.SlotNumber, &r.SlotType, &r.BayNumber, &r.BayName, &r.BayModuleDescription, &r.BayStatusType, &r.BayModuleSerial, &r.BayModuleType, &r.BypassEnabled)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTptSlot provide iterator to all rows of the TPT_SLOT matching given criteria.
func RangeTptSlot(db *sql.DB, where string) iter.Seq2[*TptSlotRow, error] {
	return func(yield func(v *TptSlotRow, err error) bool) {
	    query := "SELECT ID,DISPLAY_NAME,PARENT_ID,BIT_ARRAY,SLOT_NUMBER,SLOT_TYPE,BAY_NUMBER,BAY_NAME,BAY_MODULE_DESCRIPTION,BAY_STATUS_TYPE,BAY_MODULE_SERIAL,BAY_MODULE_TYPE,BYPASS_ENABLED FROM TPT_SLOT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TptSlotRow
	        err := rows.Scan(&r.ID, &r.DisplayName, &r.ParentID, &r.BitArray, &r.SlotNumber, &r.SlotType, &r.BayNumber, &r.BayName, &r.BayModuleDescription, &r.BayStatusType, &r.BayModuleSerial, &r.BayModuleType, &r.BypassEnabled)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TransactionLogRow struct represents rows of the TRANSACTION_LOG table.
type TransactionLogRow struct {
    TransactionID	uint64
    StartTime	uint64
    EndTime	sql.NullInt64
    FacilityID	string
    SessionData	sql.NullString
    TransactionType	sql.NullInt32
}

// IterateTransactionLog provide access to all rows of the TRANSACTION_LOG matching given criteria.
func IterateTransactionLog(db *sql.DB, where string, callback func(v *TransactionLogRow) error) error {
    query := "SELECT TRANSACTION_ID,START_TIME,END_TIME,FACILITY_ID,SESSION_DATA,TRANSACTION_TYPE FROM TRANSACTION_LOG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TransactionLogRow
        err := rows.Scan(&r.TransactionID, &r.StartTime, &r.EndTime, &r.FacilityID, &r.SessionData, &r.TransactionType)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTransactionLog provide iterator to all rows of the TRANSACTION_LOG matching given criteria.
func RangeTransactionLog(db *sql.DB, where string) iter.Seq2[*TransactionLogRow, error] {
	return func(yield func(v *TransactionLogRow, err error) bool) {
	    query := "SELECT TRANSACTION_ID,START_TIME,END_TIME,FACILITY_ID,SESSION_DATA,TRANSACTION_TYPE FROM TRANSACTION_LOG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TransactionLogRow
	        err := rows.Scan(&r.TransactionID, &r.StartTime, &r.EndTime, &r.FacilityID, &r.SessionData, &r.TransactionType)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// TransactionOpRow struct represents rows of the TRANSACTION_OP table.
type TransactionOpRow struct {
    TransactionID	uint64
    OperationID	int
    OperationType	int16
    OperationIndex	int
    State	int16
    AppData	sql.NullString
}

// IterateTransactionOp provide access to all rows of the TRANSACTION_OP matching given criteria.
func IterateTransactionOp(db *sql.DB, where string, callback func(v *TransactionOpRow) error) error {
    query := "SELECT TRANSACTION_ID,OPERATION_ID,OPERATION_TYPE,OPERATION_INDEX,STATE,APP_DATA FROM TRANSACTION_OP"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r TransactionOpRow
        err := rows.Scan(&r.TransactionID, &r.OperationID, &r.OperationType, &r.OperationIndex, &r.State, &r.AppData)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeTransactionOp provide iterator to all rows of the TRANSACTION_OP matching given criteria.
func RangeTransactionOp(db *sql.DB, where string) iter.Seq2[*TransactionOpRow, error] {
	return func(yield func(v *TransactionOpRow, err error) bool) {
	    query := "SELECT TRANSACTION_ID,OPERATION_ID,OPERATION_TYPE,OPERATION_INDEX,STATE,APP_DATA FROM TRANSACTION_OP"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r TransactionOpRow
	        err := rows.Scan(&r.TransactionID, &r.OperationID, &r.OperationType, &r.OperationIndex, &r.State, &r.AppData)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UrlAnalyzerEventRow struct represents rows of the URL_ANALYZER_EVENT table.
type UrlAnalyzerEventRow struct {
    AlertsIdx	uint64
    EventTime	int64
    SrcIPAddr	string
    SignatureID	string
    SignatureName	sql.NullString
    ShortDeviceID	int
    VirtualSegmentID	int
    ResultID	uint64
}

// IterateUrlAnalyzerEvent provide access to all rows of the URL_ANALYZER_EVENT matching given criteria.
func IterateUrlAnalyzerEvent(db *sql.DB, where string, callback func(v *UrlAnalyzerEventRow) error) error {
    query := "SELECT ALERTS_IDX,EVENT_TIME,SRC_IP_ADDR,SIGNATURE_ID,SIGNATURE_NAME,SHORT_DEVICE_ID,VIRTUAL_SEGMENT_ID,RESULT_ID FROM URL_ANALYZER_EVENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UrlAnalyzerEventRow
        err := rows.Scan(&r.AlertsIdx, &r.EventTime, &r.SrcIPAddr, &r.SignatureID, &r.SignatureName, &r.ShortDeviceID, &r.VirtualSegmentID, &r.ResultID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUrlAnalyzerEvent provide iterator to all rows of the URL_ANALYZER_EVENT matching given criteria.
func RangeUrlAnalyzerEvent(db *sql.DB, where string) iter.Seq2[*UrlAnalyzerEventRow, error] {
	return func(yield func(v *UrlAnalyzerEventRow, err error) bool) {
	    query := "SELECT ALERTS_IDX,EVENT_TIME,SRC_IP_ADDR,SIGNATURE_ID,SIGNATURE_NAME,SHORT_DEVICE_ID,VIRTUAL_SEGMENT_ID,RESULT_ID FROM URL_ANALYZER_EVENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UrlAnalyzerEventRow
	        err := rows.Scan(&r.AlertsIdx, &r.EventTime, &r.SrcIPAddr, &r.SignatureID, &r.SignatureName, &r.ShortDeviceID, &r.VirtualSegmentID, &r.ResultID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UrlAnalyzerResultRow struct represents rows of the URL_ANALYZER_RESULT table.
type UrlAnalyzerResultRow struct {
    ID	uint64
    Url	string
    Status	sql.NullString
    BeginTime	int64
    EndTime	int64
    RiskLevel	sql.NullString
    BriefReportStatus	sql.NullInt32
    BriefReportRiskLevel	sql.NullInt32
    RetryQuota	sql.NullInt32
}

// IterateUrlAnalyzerResult provide access to all rows of the URL_ANALYZER_RESULT matching given criteria.
func IterateUrlAnalyzerResult(db *sql.DB, where string, callback func(v *UrlAnalyzerResultRow) error) error {
    query := "SELECT ID,URL,STATUS,BEGIN_TIME,END_TIME,RISK_LEVEL,BRIEF_REPORT_STATUS,BRIEF_REPORT_RISK_LEVEL,RETRY_QUOTA FROM URL_ANALYZER_RESULT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UrlAnalyzerResultRow
        err := rows.Scan(&r.ID, &r.Url, &r.Status, &r.BeginTime, &r.EndTime, &r.RiskLevel, &r.BriefReportStatus, &r.BriefReportRiskLevel, &r.RetryQuota)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUrlAnalyzerResult provide iterator to all rows of the URL_ANALYZER_RESULT matching given criteria.
func RangeUrlAnalyzerResult(db *sql.DB, where string) iter.Seq2[*UrlAnalyzerResultRow, error] {
	return func(yield func(v *UrlAnalyzerResultRow, err error) bool) {
	    query := "SELECT ID,URL,STATUS,BEGIN_TIME,END_TIME,RISK_LEVEL,BRIEF_REPORT_STATUS,BRIEF_REPORT_RISK_LEVEL,RETRY_QUOTA FROM URL_ANALYZER_RESULT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UrlAnalyzerResultRow
	        err := rows.Scan(&r.ID, &r.Url, &r.Status, &r.BeginTime, &r.EndTime, &r.RiskLevel, &r.BriefReportStatus, &r.BriefReportRiskLevel, &r.RetryQuota)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UrlCloudConfigRow struct represents rows of the URL_CLOUD_CONFIG table.
type UrlCloudConfigRow struct {
    ID	int
    SavedQueryID	uint
    IsEnabled	int8
    Uuid	sql.NullString
    ApiKey	sql.NullString
    ServiceUrl	sql.NullString
}

// IterateUrlCloudConfig provide access to all rows of the URL_CLOUD_CONFIG matching given criteria.
func IterateUrlCloudConfig(db *sql.DB, where string, callback func(v *UrlCloudConfigRow) error) error {
    query := "SELECT ID,SAVED_QUERY_ID,IS_ENABLED,UUID,API_KEY,SERVICE_URL FROM URL_CLOUD_CONFIG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UrlCloudConfigRow
        err := rows.Scan(&r.ID, &r.SavedQueryID, &r.IsEnabled, &r.Uuid, &r.ApiKey, &r.ServiceUrl)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUrlCloudConfig provide iterator to all rows of the URL_CLOUD_CONFIG matching given criteria.
func RangeUrlCloudConfig(db *sql.DB, where string) iter.Seq2[*UrlCloudConfigRow, error] {
	return func(yield func(v *UrlCloudConfigRow, err error) bool) {
	    query := "SELECT ID,SAVED_QUERY_ID,IS_ENABLED,UUID,API_KEY,SERVICE_URL FROM URL_CLOUD_CONFIG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UrlCloudConfigRow
	        err := rows.Scan(&r.ID, &r.SavedQueryID, &r.IsEnabled, &r.Uuid, &r.ApiKey, &r.ServiceUrl)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UrlEntryImportQueueRow struct represents rows of the URL_ENTRY_IMPORT_QUEUE table.
type UrlEntryImportQueueRow struct {
    UrlEntryImportQueueID	string
    ImportSource	string
    ImportType	string
    ImportOperation	string
    FileType	sql.NullString
    FileName	sql.NullString
    EntryUrl	sql.NullString
    TotalEntries	uint
    TotalEntriesLoaded	uint
    UserTagOverride	string
    UserTagValueData	[]byte
    RepQuerySpecData	[]byte
    SessionID	int
    CreatedTime	int64
    DeltaInputStatusData	[]byte
}

// IterateUrlEntryImportQueue provide access to all rows of the URL_ENTRY_IMPORT_QUEUE matching given criteria.
func IterateUrlEntryImportQueue(db *sql.DB, where string, callback func(v *UrlEntryImportQueueRow) error) error {
    query := "SELECT URL_ENTRY_IMPORT_QUEUE_ID,IMPORT_SOURCE,IMPORT_TYPE,IMPORT_OPERATION,FILE_TYPE,FILE_NAME,ENTRY_URL,TOTAL_ENTRIES,TOTAL_ENTRIES_LOADED,USER_TAG_OVERRIDE,USER_TAG_VALUE_DATA,REP_QUERY_SPEC_DATA,SESSION_ID,CREATED_TIME,DELTA_INPUT_STATUS_DATA FROM URL_ENTRY_IMPORT_QUEUE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UrlEntryImportQueueRow
        err := rows.Scan(&r.UrlEntryImportQueueID, &r.ImportSource, &r.ImportType, &r.ImportOperation, &r.FileType, &r.FileName, &r.EntryUrl, &r.TotalEntries, &r.TotalEntriesLoaded, &r.UserTagOverride, &r.UserTagValueData, &r.RepQuerySpecData, &r.SessionID, &r.CreatedTime, &r.DeltaInputStatusData)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUrlEntryImportQueue provide iterator to all rows of the URL_ENTRY_IMPORT_QUEUE matching given criteria.
func RangeUrlEntryImportQueue(db *sql.DB, where string) iter.Seq2[*UrlEntryImportQueueRow, error] {
	return func(yield func(v *UrlEntryImportQueueRow, err error) bool) {
	    query := "SELECT URL_ENTRY_IMPORT_QUEUE_ID,IMPORT_SOURCE,IMPORT_TYPE,IMPORT_OPERATION,FILE_TYPE,FILE_NAME,ENTRY_URL,TOTAL_ENTRIES,TOTAL_ENTRIES_LOADED,USER_TAG_OVERRIDE,USER_TAG_VALUE_DATA,REP_QUERY_SPEC_DATA,SESSION_ID,CREATED_TIME,DELTA_INPUT_STATUS_DATA FROM URL_ENTRY_IMPORT_QUEUE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UrlEntryImportQueueRow
	        err := rows.Scan(&r.UrlEntryImportQueueID, &r.ImportSource, &r.ImportType, &r.ImportOperation, &r.FileType, &r.FileName, &r.EntryUrl, &r.TotalEntries, &r.TotalEntriesLoaded, &r.UserTagOverride, &r.UserTagValueData, &r.RepQuerySpecData, &r.SessionID, &r.CreatedTime, &r.DeltaInputStatusData)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UrlEntryListDataRow struct represents rows of the URL_ENTRY_LIST_DATA table.
type UrlEntryListDataRow struct {
    UrlEntryImportQueueID	string
    RepEntryList	[]byte
}

// IterateUrlEntryListData provide access to all rows of the URL_ENTRY_LIST_DATA matching given criteria.
func IterateUrlEntryListData(db *sql.DB, where string, callback func(v *UrlEntryListDataRow) error) error {
    query := "SELECT URL_ENTRY_IMPORT_QUEUE_ID,REP_ENTRY_LIST FROM URL_ENTRY_LIST_DATA"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UrlEntryListDataRow
        err := rows.Scan(&r.UrlEntryImportQueueID, &r.RepEntryList)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUrlEntryListData provide iterator to all rows of the URL_ENTRY_LIST_DATA matching given criteria.
func RangeUrlEntryListData(db *sql.DB, where string) iter.Seq2[*UrlEntryListDataRow, error] {
	return func(yield func(v *UrlEntryListDataRow, err error) bool) {
	    query := "SELECT URL_ENTRY_IMPORT_QUEUE_ID,REP_ENTRY_LIST FROM URL_ENTRY_LIST_DATA"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UrlEntryListDataRow
	        err := rows.Scan(&r.UrlEntryImportQueueID, &r.RepEntryList)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UserAclRow struct represents rows of the USER_ACL table.
type UserAclRow struct {
    ID	string
    SmsUserID	string
    Type	sql.NullInt32
}

// IterateUserAcl provide access to all rows of the USER_ACL matching given criteria.
func IterateUserAcl(db *sql.DB, where string, callback func(v *UserAclRow) error) error {
    query := "SELECT ID,SMS_USER_ID,TYPE FROM USER_ACL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UserAclRow
        err := rows.Scan(&r.ID, &r.SmsUserID, &r.Type)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUserAcl provide iterator to all rows of the USER_ACL matching given criteria.
func RangeUserAcl(db *sql.DB, where string) iter.Seq2[*UserAclRow, error] {
	return func(yield func(v *UserAclRow, err error) bool) {
	    query := "SELECT ID,SMS_USER_ID,TYPE FROM USER_ACL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UserAclRow
	        err := rows.Scan(&r.ID, &r.SmsUserID, &r.Type)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UserFilterServiceRow struct represents rows of the USER_FILTER_SERVICE table.
type UserFilterServiceRow struct {
    ServiceID	string
    Name	string
    Protocol	string
    Description	sql.NullString
    PortType	sql.NullString
    PortValue	sql.NullString
    UserDefined	string
    Deleted	string
    IterationID	string
    Version	sql.NullString
    PkgDir	string
    UpdateTime	int64
    NgfwVersion	sql.NullString
}

// IterateUserFilterService provide access to all rows of the USER_FILTER_SERVICE matching given criteria.
func IterateUserFilterService(db *sql.DB, where string, callback func(v *UserFilterServiceRow) error) error {
    query := "SELECT SERVICE_ID,NAME,PROTOCOL,DESCRIPTION,PORT_TYPE,PORT_VALUE,USER_DEFINED,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME,NGFW_VERSION FROM USER_FILTER_SERVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UserFilterServiceRow
        err := rows.Scan(&r.ServiceID, &r.Name, &r.Protocol, &r.Description, &r.PortType, &r.PortValue, &r.UserDefined, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime, &r.NgfwVersion)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUserFilterService provide iterator to all rows of the USER_FILTER_SERVICE matching given criteria.
func RangeUserFilterService(db *sql.DB, where string) iter.Seq2[*UserFilterServiceRow, error] {
	return func(yield func(v *UserFilterServiceRow, err error) bool) {
	    query := "SELECT SERVICE_ID,NAME,PROTOCOL,DESCRIPTION,PORT_TYPE,PORT_VALUE,USER_DEFINED,DELETED,ITERATION_ID,VERSION,PKG_DIR,UPDATE_TIME,NGFW_VERSION FROM USER_FILTER_SERVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UserFilterServiceRow
	        err := rows.Scan(&r.ServiceID, &r.Name, &r.Protocol, &r.Description, &r.PortType, &r.PortValue, &r.UserDefined, &r.Deleted, &r.IterationID, &r.Version, &r.PkgDir, &r.UpdateTime, &r.NgfwVersion)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UserGroupsRow struct represents rows of the USER_GROUPS table.
type UserGroupsRow struct {
    ID	uint
    GroupName	string
    GroupDescription	sql.NullString
    ReadOnly	sql.NullByte
    SystemGroup	sql.NullByte
    AdMapNameSameName	sql.NullByte
    AdMapName	sql.NullString
    RadiusMapNameSameName	sql.NullByte
    RadiusMapName	sql.NullString
    RoleID	sql.NullInt32
    AccessAllSegments	sql.NullByte
    AccessAllProfiles	sql.NullByte
    AccessAllActions	sql.NullByte
    AccessAllReports	sql.NullByte
    AccessAllFirewallProfiles	sql.NullByte
    AccessAllDvtPackages	sql.NullByte
    AccessAllSslServers	sql.NullByte
    AccessAllSslClientProxies	sql.NullByte
    AccessAllSslClientDecryptRules	sql.NullByte
    AccessAllSslClientTrustStores	sql.NullByte
}

// IterateUserGroups provide access to all rows of the USER_GROUPS matching given criteria.
func IterateUserGroups(db *sql.DB, where string, callback func(v *UserGroupsRow) error) error {
    query := "SELECT ID,GROUP_NAME,GROUP_DESCRIPTION,READ_ONLY,SYSTEM_GROUP,AD_MAP_NAME_SAME_NAME,AD_MAP_NAME,RADIUS_MAP_NAME_SAME_NAME,RADIUS_MAP_NAME,ROLE_ID,ACCESS_ALL_SEGMENTS,ACCESS_ALL_PROFILES,ACCESS_ALL_ACTIONS,ACCESS_ALL_REPORTS,ACCESS_ALL_FIREWALL_PROFILES,ACCESS_ALL_DVT_PACKAGES,ACCESS_ALL_SSL_SERVERS,ACCESS_ALL_SSL_CLIENT_PROXIES,ACCESS_ALL_SSL_CLIENT_DECRYPT_RULES,ACCESS_ALL_SSL_CLIENT_TRUST_STORES FROM USER_GROUPS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UserGroupsRow
        err := rows.Scan(&r.ID, &r.GroupName, &r.GroupDescription, &r.ReadOnly, &r.SystemGroup, &r.AdMapNameSameName, &r.AdMapName, &r.RadiusMapNameSameName, &r.RadiusMapName, &r.RoleID, &r.AccessAllSegments, &r.AccessAllProfiles, &r.AccessAllActions, &r.AccessAllReports, &r.AccessAllFirewallProfiles, &r.AccessAllDvtPackages, &r.AccessAllSslServers, &r.AccessAllSslClientProxies, &r.AccessAllSslClientDecryptRules, &r.AccessAllSslClientTrustStores)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUserGroups provide iterator to all rows of the USER_GROUPS matching given criteria.
func RangeUserGroups(db *sql.DB, where string) iter.Seq2[*UserGroupsRow, error] {
	return func(yield func(v *UserGroupsRow, err error) bool) {
	    query := "SELECT ID,GROUP_NAME,GROUP_DESCRIPTION,READ_ONLY,SYSTEM_GROUP,AD_MAP_NAME_SAME_NAME,AD_MAP_NAME,RADIUS_MAP_NAME_SAME_NAME,RADIUS_MAP_NAME,ROLE_ID,ACCESS_ALL_SEGMENTS,ACCESS_ALL_PROFILES,ACCESS_ALL_ACTIONS,ACCESS_ALL_REPORTS,ACCESS_ALL_FIREWALL_PROFILES,ACCESS_ALL_DVT_PACKAGES,ACCESS_ALL_SSL_SERVERS,ACCESS_ALL_SSL_CLIENT_PROXIES,ACCESS_ALL_SSL_CLIENT_DECRYPT_RULES,ACCESS_ALL_SSL_CLIENT_TRUST_STORES FROM USER_GROUPS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UserGroupsRow
	        err := rows.Scan(&r.ID, &r.GroupName, &r.GroupDescription, &r.ReadOnly, &r.SystemGroup, &r.AdMapNameSameName, &r.AdMapName, &r.RadiusMapNameSameName, &r.RadiusMapName, &r.RoleID, &r.AccessAllSegments, &r.AccessAllProfiles, &r.AccessAllActions, &r.AccessAllReports, &r.AccessAllFirewallProfiles, &r.AccessAllDvtPackages, &r.AccessAllSslServers, &r.AccessAllSslClientProxies, &r.AccessAllSslClientDecryptRules, &r.AccessAllSslClientTrustStores)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UserIDIPEventRow struct represents rows of the USER_ID_IP_EVENT table.
type UserIDIPEventRow struct {
    ID	uint64
    RecordID	uint64
    UserIPAddr1	int64
    UserIPAddr2	sql.NullInt64
    UserName	sql.NullString
    EventTime	sql.NullInt64
    DomainName	sql.NullString
    MachineName	sql.NullString
    EventID	uint
    AdUserID	sql.NullInt32
    AdGrpID	uint
}

// IterateUserIDIPEvent provide access to all rows of the USER_ID_IP_EVENT matching given criteria.
func IterateUserIDIPEvent(db *sql.DB, where string, callback func(v *UserIDIPEventRow) error) error {
    query := "SELECT ID,RECORD_ID,USER_IP_ADDR_1,USER_IP_ADDR_2,USER_NAME,EVENT_TIME,DOMAIN_NAME,MACHINE_NAME,EVENT_ID,AD_USER_ID,AD_GRP_ID FROM USER_ID_IP_EVENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UserIDIPEventRow
        err := rows.Scan(&r.ID, &r.RecordID, &r.UserIPAddr1, &r.UserIPAddr2, &r.UserName, &r.EventTime, &r.DomainName, &r.MachineName, &r.EventID, &r.AdUserID, &r.AdGrpID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUserIDIPEvent provide iterator to all rows of the USER_ID_IP_EVENT matching given criteria.
func RangeUserIDIPEvent(db *sql.DB, where string) iter.Seq2[*UserIDIPEventRow, error] {
	return func(yield func(v *UserIDIPEventRow, err error) bool) {
	    query := "SELECT ID,RECORD_ID,USER_IP_ADDR_1,USER_IP_ADDR_2,USER_NAME,EVENT_TIME,DOMAIN_NAME,MACHINE_NAME,EVENT_ID,AD_USER_ID,AD_GRP_ID FROM USER_ID_IP_EVENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UserIDIPEventRow
	        err := rows.Scan(&r.ID, &r.RecordID, &r.UserIPAddr1, &r.UserIPAddr2, &r.UserName, &r.EventTime, &r.DomainName, &r.MachineName, &r.EventID, &r.AdUserID, &r.AdGrpID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UserLoginActivityRow struct represents rows of the USER_LOGIN_ACTIVITY table.
type UserLoginActivityRow struct {
    ID	int
    Userid	int
    Username	string
    LastSuccessLogin	sql.NullTime
    LastSuccessClientIP	sql.NullString
    LastFailLogin	sql.NullTime
    LastFailClientIP	sql.NullString
    LastFailedLoginCount	sql.NullInt32
    CurrentSuccessLogin	sql.NullTime
    CurrentSuccessClientIP	sql.NullString
    CurrentFailedLoginCount	sql.NullInt32
    CurrentFailLogin	sql.NullTime
    CurrentFailClientIP	sql.NullString
    LockoutThresholdReset	sql.NullByte
}

// IterateUserLoginActivity provide access to all rows of the USER_LOGIN_ACTIVITY matching given criteria.
func IterateUserLoginActivity(db *sql.DB, where string, callback func(v *UserLoginActivityRow) error) error {
    query := "SELECT ID,USERID,USERNAME,LAST_SUCCESS_LOGIN,LAST_SUCCESS_CLIENT_IP,LAST_FAIL_LOGIN,LAST_FAIL_CLIENT_IP,LAST_FAILED_LOGIN_COUNT,CURRENT_SUCCESS_LOGIN,CURRENT_SUCCESS_CLIENT_IP,CURRENT_FAILED_LOGIN_COUNT,CURRENT_FAIL_LOGIN,CURRENT_FAIL_CLIENT_IP,LOCKOUT_THRESHOLD_RESET FROM USER_LOGIN_ACTIVITY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UserLoginActivityRow
        err := rows.Scan(&r.ID, &r.Userid, &r.Username, &r.LastSuccessLogin, &r.LastSuccessClientIP, &r.LastFailLogin, &r.LastFailClientIP, &r.LastFailedLoginCount, &r.CurrentSuccessLogin, &r.CurrentSuccessClientIP, &r.CurrentFailedLoginCount, &r.CurrentFailLogin, &r.CurrentFailClientIP, &r.LockoutThresholdReset)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUserLoginActivity provide iterator to all rows of the USER_LOGIN_ACTIVITY matching given criteria.
func RangeUserLoginActivity(db *sql.DB, where string) iter.Seq2[*UserLoginActivityRow, error] {
	return func(yield func(v *UserLoginActivityRow, err error) bool) {
	    query := "SELECT ID,USERID,USERNAME,LAST_SUCCESS_LOGIN,LAST_SUCCESS_CLIENT_IP,LAST_FAIL_LOGIN,LAST_FAIL_CLIENT_IP,LAST_FAILED_LOGIN_COUNT,CURRENT_SUCCESS_LOGIN,CURRENT_SUCCESS_CLIENT_IP,CURRENT_FAILED_LOGIN_COUNT,CURRENT_FAIL_LOGIN,CURRENT_FAIL_CLIENT_IP,LOCKOUT_THRESHOLD_RESET FROM USER_LOGIN_ACTIVITY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UserLoginActivityRow
	        err := rows.Scan(&r.ID, &r.Userid, &r.Username, &r.LastSuccessLogin, &r.LastSuccessClientIP, &r.LastFailLogin, &r.LastFailClientIP, &r.LastFailedLoginCount, &r.CurrentSuccessLogin, &r.CurrentSuccessClientIP, &r.CurrentFailedLoginCount, &r.CurrentFailLogin, &r.CurrentFailClientIP, &r.LockoutThresholdReset)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UserLoginActivityGroupRoleRow struct represents rows of the USER_LOGIN_ACTIVITY_GROUP_ROLE table.
type UserLoginActivityGroupRoleRow struct {
    ID	int
    Userid	int
    Username	string
    GroupID	uint
    GroupName	string
    RoleID	uint
    RoleName	string
    CurrentOrLast	sql.NullByte
}

// IterateUserLoginActivityGroupRole provide access to all rows of the USER_LOGIN_ACTIVITY_GROUP_ROLE matching given criteria.
func IterateUserLoginActivityGroupRole(db *sql.DB, where string, callback func(v *UserLoginActivityGroupRoleRow) error) error {
    query := "SELECT ID,USERID,USERNAME,GROUP_ID,GROUP_NAME,ROLE_ID,ROLE_NAME,CURRENT_OR_LAST FROM USER_LOGIN_ACTIVITY_GROUP_ROLE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UserLoginActivityGroupRoleRow
        err := rows.Scan(&r.ID, &r.Userid, &r.Username, &r.GroupID, &r.GroupName, &r.RoleID, &r.RoleName, &r.CurrentOrLast)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUserLoginActivityGroupRole provide iterator to all rows of the USER_LOGIN_ACTIVITY_GROUP_ROLE matching given criteria.
func RangeUserLoginActivityGroupRole(db *sql.DB, where string) iter.Seq2[*UserLoginActivityGroupRoleRow, error] {
	return func(yield func(v *UserLoginActivityGroupRoleRow, err error) bool) {
	    query := "SELECT ID,USERID,USERNAME,GROUP_ID,GROUP_NAME,ROLE_ID,ROLE_NAME,CURRENT_OR_LAST FROM USER_LOGIN_ACTIVITY_GROUP_ROLE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UserLoginActivityGroupRoleRow
	        err := rows.Scan(&r.ID, &r.Userid, &r.Username, &r.GroupID, &r.GroupName, &r.RoleID, &r.RoleName, &r.CurrentOrLast)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UserPrefsRow struct represents rows of the USER_PREFS table.
type UserPrefsRow struct {
    SmsUserID	string
    PrefKey	string
    Value	[]byte
}

// IterateUserPrefs provide access to all rows of the USER_PREFS matching given criteria.
func IterateUserPrefs(db *sql.DB, where string, callback func(v *UserPrefsRow) error) error {
    query := "SELECT SMS_USER_ID,PREF_KEY,VALUE FROM USER_PREFS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UserPrefsRow
        err := rows.Scan(&r.SmsUserID, &r.PrefKey, &r.Value)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUserPrefs provide iterator to all rows of the USER_PREFS matching given criteria.
func RangeUserPrefs(db *sql.DB, where string) iter.Seq2[*UserPrefsRow, error] {
	return func(yield func(v *UserPrefsRow, err error) bool) {
	    query := "SELECT SMS_USER_ID,PREF_KEY,VALUE FROM USER_PREFS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UserPrefsRow
	        err := rows.Scan(&r.SmsUserID, &r.PrefKey, &r.Value)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UserRolesRow struct represents rows of the USER_ROLES table.
type UserRolesRow struct {
    ID	uint
    RoleName	string
    RoleDescription	sql.NullString
    UpgradeAs	sql.NullByte
    ReadOnly	sql.NullByte
    SystemRole	sql.NullByte
}

// IterateUserRoles provide access to all rows of the USER_ROLES matching given criteria.
func IterateUserRoles(db *sql.DB, where string, callback func(v *UserRolesRow) error) error {
    query := "SELECT ID,ROLE_NAME,ROLE_DESCRIPTION,UPGRADE_AS,READ_ONLY,SYSTEM_ROLE FROM USER_ROLES"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UserRolesRow
        err := rows.Scan(&r.ID, &r.RoleName, &r.RoleDescription, &r.UpgradeAs, &r.ReadOnly, &r.SystemRole)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUserRoles provide iterator to all rows of the USER_ROLES matching given criteria.
func RangeUserRoles(db *sql.DB, where string) iter.Seq2[*UserRolesRow, error] {
	return func(yield func(v *UserRolesRow, err error) bool) {
	    query := "SELECT ID,ROLE_NAME,ROLE_DESCRIPTION,UPGRADE_AS,READ_ONLY,SYSTEM_ROLE FROM USER_ROLES"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UserRolesRow
	        err := rows.Scan(&r.ID, &r.RoleName, &r.RoleDescription, &r.UpgradeAs, &r.ReadOnly, &r.SystemRole)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UserRoleCapabilitiesRow struct represents rows of the USER_ROLE_CAPABILITIES table.
type UserRoleCapabilitiesRow struct {
    ID	uint
    RoleID	uint
    CapabilityName	sql.NullString
    CapabilityRollupName	sql.NullString
}

// IterateUserRoleCapabilities provide access to all rows of the USER_ROLE_CAPABILITIES matching given criteria.
func IterateUserRoleCapabilities(db *sql.DB, where string, callback func(v *UserRoleCapabilitiesRow) error) error {
    query := "SELECT ID,ROLE_ID,CAPABILITY_NAME,CAPABILITY_ROLLUP_NAME FROM USER_ROLE_CAPABILITIES"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UserRoleCapabilitiesRow
        err := rows.Scan(&r.ID, &r.RoleID, &r.CapabilityName, &r.CapabilityRollupName)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUserRoleCapabilities provide iterator to all rows of the USER_ROLE_CAPABILITIES matching given criteria.
func RangeUserRoleCapabilities(db *sql.DB, where string) iter.Seq2[*UserRoleCapabilitiesRow, error] {
	return func(yield func(v *UserRoleCapabilitiesRow, err error) bool) {
	    query := "SELECT ID,ROLE_ID,CAPABILITY_NAME,CAPABILITY_ROLLUP_NAME FROM USER_ROLE_CAPABILITIES"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UserRoleCapabilitiesRow
	        err := rows.Scan(&r.ID, &r.RoleID, &r.CapabilityName, &r.CapabilityRollupName)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// UserSuccessLoginsRow struct represents rows of the USER_SUCCESS_LOGINS table.
type UserSuccessLoginsRow struct {
    ID	int
    Userid	int
    Username	string
    LoginDate	string
}

// IterateUserSuccessLogins provide access to all rows of the USER_SUCCESS_LOGINS matching given criteria.
func IterateUserSuccessLogins(db *sql.DB, where string, callback func(v *UserSuccessLoginsRow) error) error {
    query := "SELECT ID,USERID,USERNAME,LOGIN_DATE FROM USER_SUCCESS_LOGINS"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r UserSuccessLoginsRow
        err := rows.Scan(&r.ID, &r.Userid, &r.Username, &r.LoginDate)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeUserSuccessLogins provide iterator to all rows of the USER_SUCCESS_LOGINS matching given criteria.
func RangeUserSuccessLogins(db *sql.DB, where string) iter.Seq2[*UserSuccessLoginsRow, error] {
	return func(yield func(v *UserSuccessLoginsRow, err error) bool) {
	    query := "SELECT ID,USERID,USERNAME,LOGIN_DATE FROM USER_SUCCESS_LOGINS"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r UserSuccessLoginsRow
	        err := rows.Scan(&r.ID, &r.Userid, &r.Username, &r.LoginDate)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VirtualInterfaceRow struct represents rows of the VIRTUAL_INTERFACE table.
type VirtualInterfaceRow struct {
    ID	uint
    VirtualInterfaceID	sql.NullInt32
    DeviceShortID	sql.NullInt32
    PptpL2tpUseDhcp	sql.NullByte
    IPAddress	sql.NullInt32
    MacAddress	sql.NullInt64
    HaIPAddress	sql.NullInt32
    NetworkMask	sql.NullInt32
    GatewayAddress	sql.NullInt32
    Type	sql.NullByte
    AllocMode	sql.NullByte
    NatEnabled	sql.NullByte
    UseExternalNat	sql.NullByte
    ManualNatIP	sql.NullInt32
    DnsOverride	sql.NullByte
    Dns1IP	sql.NullInt32
    Dns2IP	sql.NullInt32
    Dns3IP	sql.NullInt32
    SearchDomain1	sql.NullString
    SearchDomain2	sql.NullString
    SearchDomain3	sql.NullString
    LoginServerIP	sql.NullInt32
    UserName	sql.NullString
    Password	sql.NullString
    Timeout	sql.NullInt32
    Rip	sql.NullByte
    Igmp	sql.NullByte
    PimDm	sql.NullByte
    IgmpQueryInterval	sql.NullInt32
    IgmpQueryTimeout	sql.NullInt32
    IgmpMaxQueryTime	sql.NullInt32
    RipSplitHorizion	sql.NullByte
    RipPoisonReverse	sql.NullByte
    RipAdvertiseDisabled	sql.NullByte
    RipSendMode	sql.NullByte
    RipRecvMode	sql.NullByte
    RipAuthMode	sql.NullByte
    RipAuthKey	sql.NullString
    BridgeModeEnabled	sql.NullByte
}

// IterateVirtualInterface provide access to all rows of the VIRTUAL_INTERFACE matching given criteria.
func IterateVirtualInterface(db *sql.DB, where string, callback func(v *VirtualInterfaceRow) error) error {
    query := "SELECT ID,VIRTUAL_INTERFACE_ID,DEVICE_SHORT_ID,PPTP_L2TP_USE_DHCP,IP_ADDRESS,MAC_ADDRESS,HA_IP_ADDRESS,NETWORK_MASK,GATEWAY_ADDRESS,TYPE,ALLOC_MODE,NAT_ENABLED,USE_EXTERNAL_NAT,MANUAL_NAT_IP,DNS_OVERRIDE,DNS1_IP,DNS2_IP,DNS3_IP,SEARCH_DOMAIN1,SEARCH_DOMAIN2,SEARCH_DOMAIN3,LOGIN_SERVER_IP,USER_NAME,PASSWORD,TIMEOUT,RIP,IGMP,PIM_DM,IGMP_QUERY_INTERVAL,IGMP_QUERY_TIMEOUT,IGMP_MAX_QUERY_TIME,RIP_SPLIT_HORIZION,RIP_POISON_REVERSE,RIP_ADVERTISE_DISABLED,RIP_SEND_MODE,RIP_RECV_MODE,RIP_AUTH_MODE,RIP_AUTH_KEY,BRIDGE_MODE_ENABLED FROM VIRTUAL_INTERFACE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VirtualInterfaceRow
        err := rows.Scan(&r.ID, &r.VirtualInterfaceID, &r.DeviceShortID, &r.PptpL2tpUseDhcp, &r.IPAddress, &r.MacAddress, &r.HaIPAddress, &r.NetworkMask, &r.GatewayAddress, &r.Type, &r.AllocMode, &r.NatEnabled, &r.UseExternalNat, &r.ManualNatIP, &r.DnsOverride, &r.Dns1IP, &r.Dns2IP, &r.Dns3IP, &r.SearchDomain1, &r.SearchDomain2, &r.SearchDomain3, &r.LoginServerIP, &r.UserName, &r.Password, &r.Timeout, &r.Rip, &r.Igmp, &r.PimDm, &r.IgmpQueryInterval, &r.IgmpQueryTimeout, &r.IgmpMaxQueryTime, &r.RipSplitHorizion, &r.RipPoisonReverse, &r.RipAdvertiseDisabled, &r.RipSendMode, &r.RipRecvMode, &r.RipAuthMode, &r.RipAuthKey, &r.BridgeModeEnabled)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVirtualInterface provide iterator to all rows of the VIRTUAL_INTERFACE matching given criteria.
func RangeVirtualInterface(db *sql.DB, where string) iter.Seq2[*VirtualInterfaceRow, error] {
	return func(yield func(v *VirtualInterfaceRow, err error) bool) {
	    query := "SELECT ID,VIRTUAL_INTERFACE_ID,DEVICE_SHORT_ID,PPTP_L2TP_USE_DHCP,IP_ADDRESS,MAC_ADDRESS,HA_IP_ADDRESS,NETWORK_MASK,GATEWAY_ADDRESS,TYPE,ALLOC_MODE,NAT_ENABLED,USE_EXTERNAL_NAT,MANUAL_NAT_IP,DNS_OVERRIDE,DNS1_IP,DNS2_IP,DNS3_IP,SEARCH_DOMAIN1,SEARCH_DOMAIN2,SEARCH_DOMAIN3,LOGIN_SERVER_IP,USER_NAME,PASSWORD,TIMEOUT,RIP,IGMP,PIM_DM,IGMP_QUERY_INTERVAL,IGMP_QUERY_TIMEOUT,IGMP_MAX_QUERY_TIME,RIP_SPLIT_HORIZION,RIP_POISON_REVERSE,RIP_ADVERTISE_DISABLED,RIP_SEND_MODE,RIP_RECV_MODE,RIP_AUTH_MODE,RIP_AUTH_KEY,BRIDGE_MODE_ENABLED FROM VIRTUAL_INTERFACE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VirtualInterfaceRow
	        err := rows.Scan(&r.ID, &r.VirtualInterfaceID, &r.DeviceShortID, &r.PptpL2tpUseDhcp, &r.IPAddress, &r.MacAddress, &r.HaIPAddress, &r.NetworkMask, &r.GatewayAddress, &r.Type, &r.AllocMode, &r.NatEnabled, &r.UseExternalNat, &r.ManualNatIP, &r.DnsOverride, &r.Dns1IP, &r.Dns2IP, &r.Dns3IP, &r.SearchDomain1, &r.SearchDomain2, &r.SearchDomain3, &r.LoginServerIP, &r.UserName, &r.Password, &r.Timeout, &r.Rip, &r.Igmp, &r.PimDm, &r.IgmpQueryInterval, &r.IgmpQueryTimeout, &r.IgmpMaxQueryTime, &r.RipSplitHorizion, &r.RipPoisonReverse, &r.RipAdvertiseDisabled, &r.RipSendMode, &r.RipRecvMode, &r.RipAuthMode, &r.RipAuthKey, &r.BridgeModeEnabled)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VirtualInterfaceSecurityZoneRow struct represents rows of the VIRTUAL_INTERFACE_SECURITY_ZONE table.
type VirtualInterfaceSecurityZoneRow struct {
    VirtualInterfaceID	uint
    SecurityZoneID	uint
}

// IterateVirtualInterfaceSecurityZone provide access to all rows of the VIRTUAL_INTERFACE_SECURITY_ZONE matching given criteria.
func IterateVirtualInterfaceSecurityZone(db *sql.DB, where string, callback func(v *VirtualInterfaceSecurityZoneRow) error) error {
    query := "SELECT VIRTUAL_INTERFACE_ID,SECURITY_ZONE_ID FROM VIRTUAL_INTERFACE_SECURITY_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VirtualInterfaceSecurityZoneRow
        err := rows.Scan(&r.VirtualInterfaceID, &r.SecurityZoneID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVirtualInterfaceSecurityZone provide iterator to all rows of the VIRTUAL_INTERFACE_SECURITY_ZONE matching given criteria.
func RangeVirtualInterfaceSecurityZone(db *sql.DB, where string) iter.Seq2[*VirtualInterfaceSecurityZoneRow, error] {
	return func(yield func(v *VirtualInterfaceSecurityZoneRow, err error) bool) {
	    query := "SELECT VIRTUAL_INTERFACE_ID,SECURITY_ZONE_ID FROM VIRTUAL_INTERFACE_SECURITY_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VirtualInterfaceSecurityZoneRow
	        err := rows.Scan(&r.VirtualInterfaceID, &r.SecurityZoneID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VirtualSegmentRow struct represents rows of the VIRTUAL_SEGMENT table.
type VirtualSegmentRow struct {
    ID	uint
    Name	sql.NullString
    ASideName	sql.NullString
    BSideName	sql.NullString
    TptSegmentUuid	sql.NullString
    DeviceShortID	sql.NullInt32
    Direction	sql.NullByte
    SecurityZonePairUuid	sql.NullString
    SecurityZoneSrcUuid	sql.NullString
    SecurityZoneDstUuid	sql.NullString
    TptGroupUuid	sql.NullString
    Description	sql.NullString
    GlobalVirtualSegmentID	sql.NullInt32
    DeviceVsegPosition	sql.NullInt32
    BayNumber	sql.NullInt32
    DeletedSegment	sql.NullByte
}

// IterateVirtualSegment provide access to all rows of the VIRTUAL_SEGMENT matching given criteria.
func IterateVirtualSegment(db *sql.DB, where string, callback func(v *VirtualSegmentRow) error) error {
    query := "SELECT ID,NAME,A_SIDE_NAME,B_SIDE_NAME,TPT_SEGMENT_UUID,DEVICE_SHORT_ID,DIRECTION,SECURITY_ZONE_PAIR_UUID,SECURITY_ZONE_SRC_UUID,SECURITY_ZONE_DST_UUID,TPT_GROUP_UUID,DESCRIPTION,GLOBAL_VIRTUAL_SEGMENT_ID,DEVICE_VSEG_POSITION,BAY_NUMBER,DELETED_SEGMENT FROM VIRTUAL_SEGMENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VirtualSegmentRow
        err := rows.Scan(&r.ID, &r.Name, &r.ASideName, &r.BSideName, &r.TptSegmentUuid, &r.DeviceShortID, &r.Direction, &r.SecurityZonePairUuid, &r.SecurityZoneSrcUuid, &r.SecurityZoneDstUuid, &r.TptGroupUuid, &r.Description, &r.GlobalVirtualSegmentID, &r.DeviceVsegPosition, &r.BayNumber, &r.DeletedSegment)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVirtualSegment provide iterator to all rows of the VIRTUAL_SEGMENT matching given criteria.
func RangeVirtualSegment(db *sql.DB, where string) iter.Seq2[*VirtualSegmentRow, error] {
	return func(yield func(v *VirtualSegmentRow, err error) bool) {
	    query := "SELECT ID,NAME,A_SIDE_NAME,B_SIDE_NAME,TPT_SEGMENT_UUID,DEVICE_SHORT_ID,DIRECTION,SECURITY_ZONE_PAIR_UUID,SECURITY_ZONE_SRC_UUID,SECURITY_ZONE_DST_UUID,TPT_GROUP_UUID,DESCRIPTION,GLOBAL_VIRTUAL_SEGMENT_ID,DEVICE_VSEG_POSITION,BAY_NUMBER,DELETED_SEGMENT FROM VIRTUAL_SEGMENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VirtualSegmentRow
	        err := rows.Scan(&r.ID, &r.Name, &r.ASideName, &r.BSideName, &r.TptSegmentUuid, &r.DeviceShortID, &r.Direction, &r.SecurityZonePairUuid, &r.SecurityZoneSrcUuid, &r.SecurityZoneDstUuid, &r.TptGroupUuid, &r.Description, &r.GlobalVirtualSegmentID, &r.DeviceVsegPosition, &r.BayNumber, &r.DeletedSegment)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VirtualSegmentIDHistoryRow struct represents rows of the VIRTUAL_SEGMENT_ID_HISTORY table.
type VirtualSegmentIDHistoryRow struct {
    Uuid	string
    Direction	int8
    ID	uint
    Touchtime	string
}

// IterateVirtualSegmentIDHistory provide access to all rows of the VIRTUAL_SEGMENT_ID_HISTORY matching given criteria.
func IterateVirtualSegmentIDHistory(db *sql.DB, where string, callback func(v *VirtualSegmentIDHistoryRow) error) error {
    query := "SELECT UUID,DIRECTION,ID,TOUCHTIME FROM VIRTUAL_SEGMENT_ID_HISTORY"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VirtualSegmentIDHistoryRow
        err := rows.Scan(&r.Uuid, &r.Direction, &r.ID, &r.Touchtime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVirtualSegmentIDHistory provide iterator to all rows of the VIRTUAL_SEGMENT_ID_HISTORY matching given criteria.
func RangeVirtualSegmentIDHistory(db *sql.DB, where string) iter.Seq2[*VirtualSegmentIDHistoryRow, error] {
	return func(yield func(v *VirtualSegmentIDHistoryRow, err error) bool) {
	    query := "SELECT UUID,DIRECTION,ID,TOUCHTIME FROM VIRTUAL_SEGMENT_ID_HISTORY"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VirtualSegmentIDHistoryRow
	        err := rows.Scan(&r.Uuid, &r.Direction, &r.ID, &r.Touchtime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VirtualSegmentPortPairMappingRow struct represents rows of the VIRTUAL_SEGMENT_PORT_PAIR_MAPPING table.
type VirtualSegmentPortPairMappingRow struct {
    ID	uint
    SecurityZonePairID	sql.NullInt32
    InPort	int
    OutPort	int
    DeviceShortID	uint
}

// IterateVirtualSegmentPortPairMapping provide access to all rows of the VIRTUAL_SEGMENT_PORT_PAIR_MAPPING matching given criteria.
func IterateVirtualSegmentPortPairMapping(db *sql.DB, where string, callback func(v *VirtualSegmentPortPairMappingRow) error) error {
    query := "SELECT ID,SECURITY_ZONE_PAIR_ID,IN_PORT,OUT_PORT,DEVICE_SHORT_ID FROM VIRTUAL_SEGMENT_PORT_PAIR_MAPPING"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VirtualSegmentPortPairMappingRow
        err := rows.Scan(&r.ID, &r.SecurityZonePairID, &r.InPort, &r.OutPort, &r.DeviceShortID)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVirtualSegmentPortPairMapping provide iterator to all rows of the VIRTUAL_SEGMENT_PORT_PAIR_MAPPING matching given criteria.
func RangeVirtualSegmentPortPairMapping(db *sql.DB, where string) iter.Seq2[*VirtualSegmentPortPairMappingRow, error] {
	return func(yield func(v *VirtualSegmentPortPairMappingRow, err error) bool) {
	    query := "SELECT ID,SECURITY_ZONE_PAIR_ID,IN_PORT,OUT_PORT,DEVICE_SHORT_ID FROM VIRTUAL_SEGMENT_PORT_PAIR_MAPPING"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VirtualSegmentPortPairMappingRow
	        err := rows.Scan(&r.ID, &r.SecurityZonePairID, &r.InPort, &r.OutPort, &r.DeviceShortID)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VirtualServerRow struct represents rows of the VIRTUAL_SERVER table.
type VirtualServerRow struct {
    ID	uint
    DeviceShortID	sql.NullInt32
    AllServices	sql.NullByte
    UseExternalIfAddr	sql.NullByte
    PatEnabled	sql.NullByte
    PublicIPAddress	sql.NullInt32
    LocalIPAddress	sql.NullInt32
    LocalPort	sql.NullInt32
    ServiceName	sql.NullString
}

// IterateVirtualServer provide access to all rows of the VIRTUAL_SERVER matching given criteria.
func IterateVirtualServer(db *sql.DB, where string, callback func(v *VirtualServerRow) error) error {
    query := "SELECT ID,DEVICE_SHORT_ID,ALL_SERVICES,USE_EXTERNAL_IF_ADDR,PAT_ENABLED,PUBLIC_IP_ADDRESS,LOCAL_IP_ADDRESS,LOCAL_PORT,SERVICE_NAME FROM VIRTUAL_SERVER"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VirtualServerRow
        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.AllServices, &r.UseExternalIfAddr, &r.PatEnabled, &r.PublicIPAddress, &r.LocalIPAddress, &r.LocalPort, &r.ServiceName)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVirtualServer provide iterator to all rows of the VIRTUAL_SERVER matching given criteria.
func RangeVirtualServer(db *sql.DB, where string) iter.Seq2[*VirtualServerRow, error] {
	return func(yield func(v *VirtualServerRow, err error) bool) {
	    query := "SELECT ID,DEVICE_SHORT_ID,ALL_SERVICES,USE_EXTERNAL_IF_ADDR,PAT_ENABLED,PUBLIC_IP_ADDRESS,LOCAL_IP_ADDRESS,LOCAL_PORT,SERVICE_NAME FROM VIRTUAL_SERVER"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VirtualServerRow
	        err := rows.Scan(&r.ID, &r.DeviceShortID, &r.AllServices, &r.UseExternalIfAddr, &r.PatEnabled, &r.PublicIPAddress, &r.LocalIPAddress, &r.LocalPort, &r.ServiceName)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VpnDeviceRow struct represents rows of the VPN_DEVICE table.
type VpnDeviceRow struct {
    ID	uint
    VpnProfileID	sql.NullInt32
    DeviceID	sql.NullInt32
    Hub	sql.NullByte
    Distributed	sql.NullByte
    DistributedTime	sql.NullInt64
}

// IterateVpnDevice provide access to all rows of the VPN_DEVICE matching given criteria.
func IterateVpnDevice(db *sql.DB, where string, callback func(v *VpnDeviceRow) error) error {
    query := "SELECT ID,VPN_PROFILE_ID,DEVICE_ID,HUB,DISTRIBUTED,DISTRIBUTED_TIME FROM VPN_DEVICE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VpnDeviceRow
        err := rows.Scan(&r.ID, &r.VpnProfileID, &r.DeviceID, &r.Hub, &r.Distributed, &r.DistributedTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVpnDevice provide iterator to all rows of the VPN_DEVICE matching given criteria.
func RangeVpnDevice(db *sql.DB, where string) iter.Seq2[*VpnDeviceRow, error] {
	return func(yield func(v *VpnDeviceRow, err error) bool) {
	    query := "SELECT ID,VPN_PROFILE_ID,DEVICE_ID,HUB,DISTRIBUTED,DISTRIBUTED_TIME FROM VPN_DEVICE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VpnDeviceRow
	        err := rows.Scan(&r.ID, &r.VpnProfileID, &r.DeviceID, &r.Hub, &r.Distributed, &r.DistributedTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VpnGreVirtualInterfaceRow struct represents rows of the VPN_GRE_VIRTUAL_INTERFACE table.
type VpnGreVirtualInterfaceRow struct {
    ID	uint
    VpnProfileID	sql.NullInt32
    DeviceShortID	sql.NullInt32
    IPAddress	sql.NullInt32
    SecurityAssociationID	sql.NullInt32
    SecurityZoneID	sql.NullInt32
    RemoteTunnelEndpoint	sql.NullInt32
    PeerIP	sql.NullInt32
    Rip	sql.NullByte
    Igmp	sql.NullByte
    PimDm	sql.NullByte
    IgmpQueryInterval	sql.NullInt32
    IgmpQueryTimeout	sql.NullInt32
    IgmpMaxQueryTime	sql.NullInt32
    RipSplitHorizion	sql.NullByte
    RipPoisonReverse	sql.NullByte
    RipAdvertiseDisabled	sql.NullByte
    RipSendMode	sql.NullByte
    RipRecvMode	sql.NullByte
    RipAuthMode	sql.NullByte
    RipAuthKey	sql.NullString
}

// IterateVpnGreVirtualInterface provide access to all rows of the VPN_GRE_VIRTUAL_INTERFACE matching given criteria.
func IterateVpnGreVirtualInterface(db *sql.DB, where string, callback func(v *VpnGreVirtualInterfaceRow) error) error {
    query := "SELECT ID,VPN_PROFILE_ID,DEVICE_SHORT_ID,IP_ADDRESS,SECURITY_ASSOCIATION_ID,SECURITY_ZONE_ID,REMOTE_TUNNEL_ENDPOINT,PEER_IP,RIP,IGMP,PIM_DM,IGMP_QUERY_INTERVAL,IGMP_QUERY_TIMEOUT,IGMP_MAX_QUERY_TIME,RIP_SPLIT_HORIZION,RIP_POISON_REVERSE,RIP_ADVERTISE_DISABLED,RIP_SEND_MODE,RIP_RECV_MODE,RIP_AUTH_MODE,RIP_AUTH_KEY FROM VPN_GRE_VIRTUAL_INTERFACE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VpnGreVirtualInterfaceRow
        err := rows.Scan(&r.ID, &r.VpnProfileID, &r.DeviceShortID, &r.IPAddress, &r.SecurityAssociationID, &r.SecurityZoneID, &r.RemoteTunnelEndpoint, &r.PeerIP, &r.Rip, &r.Igmp, &r.PimDm, &r.IgmpQueryInterval, &r.IgmpQueryTimeout, &r.IgmpMaxQueryTime, &r.RipSplitHorizion, &r.RipPoisonReverse, &r.RipAdvertiseDisabled, &r.RipSendMode, &r.RipRecvMode, &r.RipAuthMode, &r.RipAuthKey)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVpnGreVirtualInterface provide iterator to all rows of the VPN_GRE_VIRTUAL_INTERFACE matching given criteria.
func RangeVpnGreVirtualInterface(db *sql.DB, where string) iter.Seq2[*VpnGreVirtualInterfaceRow, error] {
	return func(yield func(v *VpnGreVirtualInterfaceRow, err error) bool) {
	    query := "SELECT ID,VPN_PROFILE_ID,DEVICE_SHORT_ID,IP_ADDRESS,SECURITY_ASSOCIATION_ID,SECURITY_ZONE_ID,REMOTE_TUNNEL_ENDPOINT,PEER_IP,RIP,IGMP,PIM_DM,IGMP_QUERY_INTERVAL,IGMP_QUERY_TIMEOUT,IGMP_MAX_QUERY_TIME,RIP_SPLIT_HORIZION,RIP_POISON_REVERSE,RIP_ADVERTISE_DISABLED,RIP_SEND_MODE,RIP_RECV_MODE,RIP_AUTH_MODE,RIP_AUTH_KEY FROM VPN_GRE_VIRTUAL_INTERFACE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VpnGreVirtualInterfaceRow
	        err := rows.Scan(&r.ID, &r.VpnProfileID, &r.DeviceShortID, &r.IPAddress, &r.SecurityAssociationID, &r.SecurityZoneID, &r.RemoteTunnelEndpoint, &r.PeerIP, &r.Rip, &r.Igmp, &r.PimDm, &r.IgmpQueryInterval, &r.IgmpQueryTimeout, &r.IgmpMaxQueryTime, &r.RipSplitHorizion, &r.RipPoisonReverse, &r.RipAdvertiseDisabled, &r.RipSendMode, &r.RipRecvMode, &r.RipAuthMode, &r.RipAuthKey)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VpnIkeProposalRow struct represents rows of the VPN_IKE_PROPOSAL table.
type VpnIkeProposalRow struct {
    ID	uint
    Name	sql.NullString
    Phase1Encryption	sql.NullByte
    Phase1Integrity	sql.NullByte
    Phase1DiffieHelman	sql.NullByte
    Phase1AuthenticationType	sql.NullByte
    Phase1LocalIDType	sql.NullByte
    Phase1PeerIDType	sql.NullByte
    Phase1SignedCert	sql.NullByte
    Phase1AggressiveMode	sql.NullByte
    Phase1Lifetime	sql.NullInt32
    Phase1LocalCertName	sql.NullString
    Phase1CaCertName	sql.NullString
    Phase1NatTraversal	sql.NullByte
    Phase1DeadPeerDetection	sql.NullByte
    Phase1AutoConnectOnStartup	sql.NullByte
    Phase1TightPhase2Control	sql.NullByte
    Phase2Encryption	sql.NullByte
    Phase2Integrity	sql.NullByte
    Phase2DiffieHelman	sql.NullByte
    Phase2Lifetime	sql.NullInt32
    Phase2PerfectForwardSecrecy	sql.NullByte
    Phase2AllowZeroID	sql.NullByte
    Phase2StrictIDCheck	sql.NullByte
    Phase2AutoConnect	sql.NullByte
}

// IterateVpnIkeProposal provide access to all rows of the VPN_IKE_PROPOSAL matching given criteria.
func IterateVpnIkeProposal(db *sql.DB, where string, callback func(v *VpnIkeProposalRow) error) error {
    query := "SELECT ID,NAME,PHASE1_ENCRYPTION,PHASE1_INTEGRITY,PHASE1_DIFFIE_HELMAN,PHASE1_AUTHENTICATION_TYPE,PHASE1_LOCAL_ID_TYPE,PHASE1_PEER_ID_TYPE,PHASE1_SIGNED_CERT,PHASE1_AGGRESSIVE_MODE,PHASE1_LIFETIME,PHASE1_LOCAL_CERT_NAME,PHASE1_CA_CERT_NAME,PHASE1_NAT_TRAVERSAL,PHASE1_DEAD_PEER_DETECTION,PHASE1_AUTO_CONNECT_ON_STARTUP,PHASE1_TIGHT_PHASE2_CONTROL,PHASE2_ENCRYPTION,PHASE2_INTEGRITY,PHASE2_DIFFIE_HELMAN,PHASE2_LIFETIME,PHASE2_PERFECT_FORWARD_SECRECY,PHASE2_ALLOW_ZERO_ID,PHASE2_STRICT_ID_CHECK,PHASE2_AUTO_CONNECT FROM VPN_IKE_PROPOSAL"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VpnIkeProposalRow
        err := rows.Scan(&r.ID, &r.Name, &r.Phase1Encryption, &r.Phase1Integrity, &r.Phase1DiffieHelman, &r.Phase1AuthenticationType, &r.Phase1LocalIDType, &r.Phase1PeerIDType, &r.Phase1SignedCert, &r.Phase1AggressiveMode, &r.Phase1Lifetime, &r.Phase1LocalCertName, &r.Phase1CaCertName, &r.Phase1NatTraversal, &r.Phase1DeadPeerDetection, &r.Phase1AutoConnectOnStartup, &r.Phase1TightPhase2Control, &r.Phase2Encryption, &r.Phase2Integrity, &r.Phase2DiffieHelman, &r.Phase2Lifetime, &r.Phase2PerfectForwardSecrecy, &r.Phase2AllowZeroID, &r.Phase2StrictIDCheck, &r.Phase2AutoConnect)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVpnIkeProposal provide iterator to all rows of the VPN_IKE_PROPOSAL matching given criteria.
func RangeVpnIkeProposal(db *sql.DB, where string) iter.Seq2[*VpnIkeProposalRow, error] {
	return func(yield func(v *VpnIkeProposalRow, err error) bool) {
	    query := "SELECT ID,NAME,PHASE1_ENCRYPTION,PHASE1_INTEGRITY,PHASE1_DIFFIE_HELMAN,PHASE1_AUTHENTICATION_TYPE,PHASE1_LOCAL_ID_TYPE,PHASE1_PEER_ID_TYPE,PHASE1_SIGNED_CERT,PHASE1_AGGRESSIVE_MODE,PHASE1_LIFETIME,PHASE1_LOCAL_CERT_NAME,PHASE1_CA_CERT_NAME,PHASE1_NAT_TRAVERSAL,PHASE1_DEAD_PEER_DETECTION,PHASE1_AUTO_CONNECT_ON_STARTUP,PHASE1_TIGHT_PHASE2_CONTROL,PHASE2_ENCRYPTION,PHASE2_INTEGRITY,PHASE2_DIFFIE_HELMAN,PHASE2_LIFETIME,PHASE2_PERFECT_FORWARD_SECRECY,PHASE2_ALLOW_ZERO_ID,PHASE2_STRICT_ID_CHECK,PHASE2_AUTO_CONNECT FROM VPN_IKE_PROPOSAL"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VpnIkeProposalRow
	        err := rows.Scan(&r.ID, &r.Name, &r.Phase1Encryption, &r.Phase1Integrity, &r.Phase1DiffieHelman, &r.Phase1AuthenticationType, &r.Phase1LocalIDType, &r.Phase1PeerIDType, &r.Phase1SignedCert, &r.Phase1AggressiveMode, &r.Phase1Lifetime, &r.Phase1LocalCertName, &r.Phase1CaCertName, &r.Phase1NatTraversal, &r.Phase1DeadPeerDetection, &r.Phase1AutoConnectOnStartup, &r.Phase1TightPhase2Control, &r.Phase2Encryption, &r.Phase2Integrity, &r.Phase2DiffieHelman, &r.Phase2Lifetime, &r.Phase2PerfectForwardSecrecy, &r.Phase2AllowZeroID, &r.Phase2StrictIDCheck, &r.Phase2AutoConnect)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VpnLogRow struct represents rows of the VPN_LOG table.
type VpnLogRow struct {
    TptDeviceShortID	uint
    SequenceNum	uint64
    TimeEnd	uint64
    SrcIPAddr	uint
    SrcPort	uint16
    DstIPAddr	uint
    DstPort	uint16
    Message	sql.NullString
    EventType	sql.NullString
    Idx	uint64
}

// IterateVpnLog provide access to all rows of the VPN_LOG matching given criteria.
func IterateVpnLog(db *sql.DB, where string, callback func(v *VpnLogRow) error) error {
    query := "SELECT TPT_DEVICE_SHORT_ID,SEQUENCE_NUM,TIME_END,SRC_IP_ADDR,SRC_PORT,DST_IP_ADDR,DST_PORT,MESSAGE,EVENT_TYPE,IDX FROM VPN_LOG"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VpnLogRow
        err := rows.Scan(&r.TptDeviceShortID, &r.SequenceNum, &r.TimeEnd, &r.SrcIPAddr, &r.SrcPort, &r.DstIPAddr, &r.DstPort, &r.Message, &r.EventType, &r.Idx)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVpnLog provide iterator to all rows of the VPN_LOG matching given criteria.
func RangeVpnLog(db *sql.DB, where string) iter.Seq2[*VpnLogRow, error] {
	return func(yield func(v *VpnLogRow, err error) bool) {
	    query := "SELECT TPT_DEVICE_SHORT_ID,SEQUENCE_NUM,TIME_END,SRC_IP_ADDR,SRC_PORT,DST_IP_ADDR,DST_PORT,MESSAGE,EVENT_TYPE,IDX FROM VPN_LOG"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VpnLogRow
	        err := rows.Scan(&r.TptDeviceShortID, &r.SequenceNum, &r.TimeEnd, &r.SrcIPAddr, &r.SrcPort, &r.DstIPAddr, &r.DstPort, &r.Message, &r.EventType, &r.Idx)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VpnProfileRow struct represents rows of the VPN_PROFILE table.
type VpnProfileRow struct {
    ID	uint
    Name	sql.NullString
    GenerateSecret	sql.NullByte
    SharedSecret	sql.NullString
    TopologyType	sql.NullByte
    TunnelType	sql.NullByte
    DefaultSecurityZoneID	sql.NullInt32
    VpnIkeProposalID	sql.NullInt32
    DefaultRoute	sql.NullByte
    RipEnabled	sql.NullByte
    IgmpEnabled	sql.NullByte
    PimDmEnabled	sql.NullByte
    HubDefaultSecurityZoneID	sql.NullInt32
    HubDefaultRoute	sql.NullByte
    SpokeToSpoke	sql.NullByte
    DynamicSpoke	sql.NullByte
    UseSupernet	sql.NullByte
    SupernetIPAddr	sql.NullInt32
    SupernetNetmask	sql.NullInt32
    GreIPFromAddr	sql.NullInt32
    GreIPToAddr	sql.NullInt32
    LastModified	sql.NullInt64
    Built	sql.NullByte
    LastBuilt	sql.NullInt64
    Valid	sql.NullByte
    Distributed	sql.NullByte
    LastDistributed	sql.NullInt64
}

// IterateVpnProfile provide access to all rows of the VPN_PROFILE matching given criteria.
func IterateVpnProfile(db *sql.DB, where string, callback func(v *VpnProfileRow) error) error {
    query := "SELECT ID,NAME,GENERATE_SECRET,SHARED_SECRET,TOPOLOGY_TYPE,TUNNEL_TYPE,DEFAULT_SECURITY_ZONE_ID,VPN_IKE_PROPOSAL_ID,DEFAULT_ROUTE,RIP_ENABLED,IGMP_ENABLED,PIM_DM_ENABLED,HUB_DEFAULT_SECURITY_ZONE_ID,HUB_DEFAULT_ROUTE,SPOKE_TO_SPOKE,DYNAMIC_SPOKE,USE_SUPERNET,SUPERNET_IP_ADDR,SUPERNET_NETMASK,GRE_IP_FROM_ADDR,GRE_IP_TO_ADDR,LAST_MODIFIED,BUILT,LAST_BUILT,VALID,DISTRIBUTED,LAST_DISTRIBUTED FROM VPN_PROFILE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VpnProfileRow
        err := rows.Scan(&r.ID, &r.Name, &r.GenerateSecret, &r.SharedSecret, &r.TopologyType, &r.TunnelType, &r.DefaultSecurityZoneID, &r.VpnIkeProposalID, &r.DefaultRoute, &r.RipEnabled, &r.IgmpEnabled, &r.PimDmEnabled, &r.HubDefaultSecurityZoneID, &r.HubDefaultRoute, &r.SpokeToSpoke, &r.DynamicSpoke, &r.UseSupernet, &r.SupernetIPAddr, &r.SupernetNetmask, &r.GreIPFromAddr, &r.GreIPToAddr, &r.LastModified, &r.Built, &r.LastBuilt, &r.Valid, &r.Distributed, &r.LastDistributed)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVpnProfile provide iterator to all rows of the VPN_PROFILE matching given criteria.
func RangeVpnProfile(db *sql.DB, where string) iter.Seq2[*VpnProfileRow, error] {
	return func(yield func(v *VpnProfileRow, err error) bool) {
	    query := "SELECT ID,NAME,GENERATE_SECRET,SHARED_SECRET,TOPOLOGY_TYPE,TUNNEL_TYPE,DEFAULT_SECURITY_ZONE_ID,VPN_IKE_PROPOSAL_ID,DEFAULT_ROUTE,RIP_ENABLED,IGMP_ENABLED,PIM_DM_ENABLED,HUB_DEFAULT_SECURITY_ZONE_ID,HUB_DEFAULT_ROUTE,SPOKE_TO_SPOKE,DYNAMIC_SPOKE,USE_SUPERNET,SUPERNET_IP_ADDR,SUPERNET_NETMASK,GRE_IP_FROM_ADDR,GRE_IP_TO_ADDR,LAST_MODIFIED,BUILT,LAST_BUILT,VALID,DISTRIBUTED,LAST_DISTRIBUTED FROM VPN_PROFILE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VpnProfileRow
	        err := rows.Scan(&r.ID, &r.Name, &r.GenerateSecret, &r.SharedSecret, &r.TopologyType, &r.TunnelType, &r.DefaultSecurityZoneID, &r.VpnIkeProposalID, &r.DefaultRoute, &r.RipEnabled, &r.IgmpEnabled, &r.PimDmEnabled, &r.HubDefaultSecurityZoneID, &r.HubDefaultRoute, &r.SpokeToSpoke, &r.DynamicSpoke, &r.UseSupernet, &r.SupernetIPAddr, &r.SupernetNetmask, &r.GreIPFromAddr, &r.GreIPToAddr, &r.LastModified, &r.Built, &r.LastBuilt, &r.Valid, &r.Distributed, &r.LastDistributed)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VpnRoutingTableRow struct represents rows of the VPN_ROUTING_TABLE table.
type VpnRoutingTableRow struct {
    ID	uint
    VpnProfileID	sql.NullInt32
    DeviceShortID	sql.NullInt32
    DestAddr	sql.NullInt32
    DestSubnetMask	sql.NullInt32
    NextHop	sql.NullInt32
    Metric	sql.NullInt16
    Age	sql.NullInt32
}

// IterateVpnRoutingTable provide access to all rows of the VPN_ROUTING_TABLE matching given criteria.
func IterateVpnRoutingTable(db *sql.DB, where string, callback func(v *VpnRoutingTableRow) error) error {
    query := "SELECT ID,VPN_PROFILE_ID,DEVICE_SHORT_ID,DEST_ADDR,DEST_SUBNET_MASK,NEXT_HOP,METRIC,AGE FROM VPN_ROUTING_TABLE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VpnRoutingTableRow
        err := rows.Scan(&r.ID, &r.VpnProfileID, &r.DeviceShortID, &r.DestAddr, &r.DestSubnetMask, &r.NextHop, &r.Metric, &r.Age)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVpnRoutingTable provide iterator to all rows of the VPN_ROUTING_TABLE matching given criteria.
func RangeVpnRoutingTable(db *sql.DB, where string) iter.Seq2[*VpnRoutingTableRow, error] {
	return func(yield func(v *VpnRoutingTableRow, err error) bool) {
	    query := "SELECT ID,VPN_PROFILE_ID,DEVICE_SHORT_ID,DEST_ADDR,DEST_SUBNET_MASK,NEXT_HOP,METRIC,AGE FROM VPN_ROUTING_TABLE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VpnRoutingTableRow
	        err := rows.Scan(&r.ID, &r.VpnProfileID, &r.DeviceShortID, &r.DestAddr, &r.DestSubnetMask, &r.NextHop, &r.Metric, &r.Age)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VpnSecurityAssociationRow struct represents rows of the VPN_SECURITY_ASSOCIATION table.
type VpnSecurityAssociationRow struct {
    ID	uint
    VpnProfileID	sql.NullInt32
    DeviceShortID	sql.NullInt32
    Name	sql.NullString
    Enable	sql.NullByte
    GreIpsecTransport	sql.NullByte
    IpsecGateway	sql.NullInt32
    TerminatedSecurityZoneID	sql.NullInt32
    KeyingMode	sql.NullByte
    IkeModeProposalID	sql.NullInt32
    IkeModeSharedSecret	sql.NullString
    IkeModePeerID	sql.NullString
    ManualModeIncomingSpi	sql.NullInt32
    ManualModeOutgoingSpi	sql.NullInt32
    ManualModeEncryptionType	sql.NullByte
    ManualModeEncryptionKey	sql.NullString
    ManualModeAuthType	sql.NullByte
    ManualModeAuthKey	sql.NullString
    IpsecTunnel	sql.NullByte
    IpsecTunnelDestNetworkType	sql.NullByte
    IpsecTunnelDestNetworkAddr1	sql.NullInt32
    IpsecTunnelDestNetworkAddr2	sql.NullInt32
    IpsecTunnelDestNetworkNamedIPAddrGroupID	sql.NullInt32
    IpsecTunnelLocalNetworkType	sql.NullByte
    IpsecTunnelLocalNetworkAddr1	sql.NullInt32
    IpsecTunnelLocalNetworkAddr2	sql.NullInt32
    IpsecTunnelLocalNetworkNamedIPAddrGroupID	sql.NullInt32
    VpnNatEnabled	sql.NullByte
    VpnNatIPAddr	sql.NullInt32
}

// IterateVpnSecurityAssociation provide access to all rows of the VPN_SECURITY_ASSOCIATION matching given criteria.
func IterateVpnSecurityAssociation(db *sql.DB, where string, callback func(v *VpnSecurityAssociationRow) error) error {
    query := "SELECT ID,VPN_PROFILE_ID,DEVICE_SHORT_ID,NAME,ENABLE,GRE_IPSEC_TRANSPORT,IPSEC_GATEWAY,TERMINATED_SECURITY_ZONE_ID,KEYING_MODE,IKE_MODE_PROPOSAL_ID,IKE_MODE_SHARED_SECRET,IKE_MODE_PEER_ID,MANUAL_MODE_INCOMING_SPI,MANUAL_MODE_OUTGOING_SPI,MANUAL_MODE_ENCRYPTION_TYPE,MANUAL_MODE_ENCRYPTION_KEY,MANUAL_MODE_AUTH_TYPE,MANUAL_MODE_AUTH_KEY,IPSEC_TUNNEL,IPSEC_TUNNEL_DEST_NETWORK_TYPE,IPSEC_TUNNEL_DEST_NETWORK_ADDR1,IPSEC_TUNNEL_DEST_NETWORK_ADDR2,IPSEC_TUNNEL_DEST_NETWORK_NAMED_IP_ADDR_GROUP_ID,IPSEC_TUNNEL_LOCAL_NETWORK_TYPE,IPSEC_TUNNEL_LOCAL_NETWORK_ADDR1,IPSEC_TUNNEL_LOCAL_NETWORK_ADDR2,IPSEC_TUNNEL_LOCAL_NETWORK_NAMED_IP_ADDR_GROUP_ID,VPN_NAT_ENABLED,VPN_NAT_IP_ADDR FROM VPN_SECURITY_ASSOCIATION"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VpnSecurityAssociationRow
        err := rows.Scan(&r.ID, &r.VpnProfileID, &r.DeviceShortID, &r.Name, &r.Enable, &r.GreIpsecTransport, &r.IpsecGateway, &r.TerminatedSecurityZoneID, &r.KeyingMode, &r.IkeModeProposalID, &r.IkeModeSharedSecret, &r.IkeModePeerID, &r.ManualModeIncomingSpi, &r.ManualModeOutgoingSpi, &r.ManualModeEncryptionType, &r.ManualModeEncryptionKey, &r.ManualModeAuthType, &r.ManualModeAuthKey, &r.IpsecTunnel, &r.IpsecTunnelDestNetworkType, &r.IpsecTunnelDestNetworkAddr1, &r.IpsecTunnelDestNetworkAddr2, &r.IpsecTunnelDestNetworkNamedIPAddrGroupID, &r.IpsecTunnelLocalNetworkType, &r.IpsecTunnelLocalNetworkAddr1, &r.IpsecTunnelLocalNetworkAddr2, &r.IpsecTunnelLocalNetworkNamedIPAddrGroupID, &r.VpnNatEnabled, &r.VpnNatIPAddr)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVpnSecurityAssociation provide iterator to all rows of the VPN_SECURITY_ASSOCIATION matching given criteria.
func RangeVpnSecurityAssociation(db *sql.DB, where string) iter.Seq2[*VpnSecurityAssociationRow, error] {
	return func(yield func(v *VpnSecurityAssociationRow, err error) bool) {
	    query := "SELECT ID,VPN_PROFILE_ID,DEVICE_SHORT_ID,NAME,ENABLE,GRE_IPSEC_TRANSPORT,IPSEC_GATEWAY,TERMINATED_SECURITY_ZONE_ID,KEYING_MODE,IKE_MODE_PROPOSAL_ID,IKE_MODE_SHARED_SECRET,IKE_MODE_PEER_ID,MANUAL_MODE_INCOMING_SPI,MANUAL_MODE_OUTGOING_SPI,MANUAL_MODE_ENCRYPTION_TYPE,MANUAL_MODE_ENCRYPTION_KEY,MANUAL_MODE_AUTH_TYPE,MANUAL_MODE_AUTH_KEY,IPSEC_TUNNEL,IPSEC_TUNNEL_DEST_NETWORK_TYPE,IPSEC_TUNNEL_DEST_NETWORK_ADDR1,IPSEC_TUNNEL_DEST_NETWORK_ADDR2,IPSEC_TUNNEL_DEST_NETWORK_NAMED_IP_ADDR_GROUP_ID,IPSEC_TUNNEL_LOCAL_NETWORK_TYPE,IPSEC_TUNNEL_LOCAL_NETWORK_ADDR1,IPSEC_TUNNEL_LOCAL_NETWORK_ADDR2,IPSEC_TUNNEL_LOCAL_NETWORK_NAMED_IP_ADDR_GROUP_ID,VPN_NAT_ENABLED,VPN_NAT_IP_ADDR FROM VPN_SECURITY_ASSOCIATION"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VpnSecurityAssociationRow
	        err := rows.Scan(&r.ID, &r.VpnProfileID, &r.DeviceShortID, &r.Name, &r.Enable, &r.GreIpsecTransport, &r.IpsecGateway, &r.TerminatedSecurityZoneID, &r.KeyingMode, &r.IkeModeProposalID, &r.IkeModeSharedSecret, &r.IkeModePeerID, &r.ManualModeIncomingSpi, &r.ManualModeOutgoingSpi, &r.ManualModeEncryptionType, &r.ManualModeEncryptionKey, &r.ManualModeAuthType, &r.ManualModeAuthKey, &r.IpsecTunnel, &r.IpsecTunnelDestNetworkType, &r.IpsecTunnelDestNetworkAddr1, &r.IpsecTunnelDestNetworkAddr2, &r.IpsecTunnelDestNetworkNamedIPAddrGroupID, &r.IpsecTunnelLocalNetworkType, &r.IpsecTunnelLocalNetworkAddr1, &r.IpsecTunnelLocalNetworkAddr2, &r.IpsecTunnelLocalNetworkNamedIPAddrGroupID, &r.VpnNatEnabled, &r.VpnNatIPAddr)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VpnSecurityZoneRow struct represents rows of the VPN_SECURITY_ZONE table.
type VpnSecurityZoneRow struct {
    ID	uint
    Name	sql.NullString
}

// IterateVpnSecurityZone provide access to all rows of the VPN_SECURITY_ZONE matching given criteria.
func IterateVpnSecurityZone(db *sql.DB, where string, callback func(v *VpnSecurityZoneRow) error) error {
    query := "SELECT ID,NAME FROM VPN_SECURITY_ZONE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VpnSecurityZoneRow
        err := rows.Scan(&r.ID, &r.Name)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVpnSecurityZone provide iterator to all rows of the VPN_SECURITY_ZONE matching given criteria.
func RangeVpnSecurityZone(db *sql.DB, where string) iter.Seq2[*VpnSecurityZoneRow, error] {
	return func(yield func(v *VpnSecurityZoneRow, err error) bool) {
	    query := "SELECT ID,NAME FROM VPN_SECURITY_ZONE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VpnSecurityZoneRow
	        err := rows.Scan(&r.ID, &r.Name)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VulnScanRow struct represents rows of the VULN_SCAN table.
type VulnScanRow struct {
    ID	uint
    FileName	string
    ImportTime	int64
    ImportSource	string
    ProcessTime	sql.NullInt64
    ScanStartTime	sql.NullInt64
    ScanEndTime	sql.NullInt64
    TotalEvents	uint
    Vendor	sql.NullString
    Product	sql.NullString
    DeviceVersion	sql.NullString
    Comment	sql.NullString
}

// IterateVulnScan provide access to all rows of the VULN_SCAN matching given criteria.
func IterateVulnScan(db *sql.DB, where string, callback func(v *VulnScanRow) error) error {
    query := "SELECT ID,FILE_NAME,IMPORT_TIME,IMPORT_SOURCE,PROCESS_TIME,SCAN_START_TIME,SCAN_END_TIME,TOTAL_EVENTS,VENDOR,PRODUCT,DEVICE_VERSION,COMMENT FROM VULN_SCAN"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VulnScanRow
        err := rows.Scan(&r.ID, &r.FileName, &r.ImportTime, &r.ImportSource, &r.ProcessTime, &r.ScanStartTime, &r.ScanEndTime, &r.TotalEvents, &r.Vendor, &r.Product, &r.DeviceVersion, &r.Comment)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVulnScan provide iterator to all rows of the VULN_SCAN matching given criteria.
func RangeVulnScan(db *sql.DB, where string) iter.Seq2[*VulnScanRow, error] {
	return func(yield func(v *VulnScanRow, err error) bool) {
	    query := "SELECT ID,FILE_NAME,IMPORT_TIME,IMPORT_SOURCE,PROCESS_TIME,SCAN_START_TIME,SCAN_END_TIME,TOTAL_EVENTS,VENDOR,PRODUCT,DEVICE_VERSION,COMMENT FROM VULN_SCAN"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VulnScanRow
	        err := rows.Scan(&r.ID, &r.FileName, &r.ImportTime, &r.ImportSource, &r.ProcessTime, &r.ScanStartTime, &r.ScanEndTime, &r.TotalEvents, &r.Vendor, &r.Product, &r.DeviceVersion, &r.Comment)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VulnScanEventRow struct represents rows of the VULN_SCAN_EVENT table.
type VulnScanEventRow struct {
    ID	uint
    VulnScanID	uint
    AssetCategory	sql.NullString
    EventType	sql.NullString
    IPAddress	sql.NullString
    ClientIPAddr	[]byte
    HostName	sql.NullString
    MacAddress	sql.NullString
    Service	sql.NullString
    Port	sql.NullString
    CveID	string
    ConnectorSeverity	sql.NullString
    DeviceSeverity	sql.NullString
    EventClassID	sql.NullString
    EventName	sql.NullString
    Description	sql.NullString
    Solution	sql.NullString
    StartDt	sql.NullTime
    EndDt	sql.NullTime
}

// IterateVulnScanEvent provide access to all rows of the VULN_SCAN_EVENT matching given criteria.
func IterateVulnScanEvent(db *sql.DB, where string, callback func(v *VulnScanEventRow) error) error {
    query := "SELECT ID,VULN_SCAN_ID,ASSET_CATEGORY,EVENT_TYPE,IP_ADDRESS,CLIENT_IP_ADDR,HOST_NAME,MAC_ADDRESS,SERVICE,PORT,CVE_ID,CONNECTOR_SEVERITY,DEVICE_SEVERITY,EVENT_CLASS_ID,EVENT_NAME,DESCRIPTION,SOLUTION,START_DT,END_DT FROM VULN_SCAN_EVENT"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VulnScanEventRow
        err := rows.Scan(&r.ID, &r.VulnScanID, &r.AssetCategory, &r.EventType, &r.IPAddress, &r.ClientIPAddr, &r.HostName, &r.MacAddress, &r.Service, &r.Port, &r.CveID, &r.ConnectorSeverity, &r.DeviceSeverity, &r.EventClassID, &r.EventName, &r.Description, &r.Solution, &r.StartDt, &r.EndDt)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVulnScanEvent provide iterator to all rows of the VULN_SCAN_EVENT matching given criteria.
func RangeVulnScanEvent(db *sql.DB, where string) iter.Seq2[*VulnScanEventRow, error] {
	return func(yield func(v *VulnScanEventRow, err error) bool) {
	    query := "SELECT ID,VULN_SCAN_ID,ASSET_CATEGORY,EVENT_TYPE,IP_ADDRESS,CLIENT_IP_ADDR,HOST_NAME,MAC_ADDRESS,SERVICE,PORT,CVE_ID,CONNECTOR_SEVERITY,DEVICE_SEVERITY,EVENT_CLASS_ID,EVENT_NAME,DESCRIPTION,SOLUTION,START_DT,END_DT FROM VULN_SCAN_EVENT"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VulnScanEventRow
	        err := rows.Scan(&r.ID, &r.VulnScanID, &r.AssetCategory, &r.EventType, &r.IPAddress, &r.ClientIPAddr, &r.HostName, &r.MacAddress, &r.Service, &r.Port, &r.CveID, &r.ConnectorSeverity, &r.DeviceSeverity, &r.EventClassID, &r.EventName, &r.Description, &r.Solution, &r.StartDt, &r.EndDt)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// VulnScanImportQueueRow struct represents rows of the VULN_SCAN_IMPORT_QUEUE table.
type VulnScanImportQueueRow struct {
    VulnScanImportQueueID	string
    VendorFileName	string
    FileNamePath	string
    CreatedTime	int64
    FileSource	string
    SessionID	int
    ExternalConversionVendor	sql.NullString
    Vendor	sql.NullString
    Product	sql.NullString
    Version	sql.NullString
    ScanStartTime	sql.NullInt64
    ScanEndTime	sql.NullInt64
}

// IterateVulnScanImportQueue provide access to all rows of the VULN_SCAN_IMPORT_QUEUE matching given criteria.
func IterateVulnScanImportQueue(db *sql.DB, where string, callback func(v *VulnScanImportQueueRow) error) error {
    query := "SELECT VULN_SCAN_IMPORT_QUEUE_ID,VENDOR_FILE_NAME,FILE_NAME_PATH,CREATED_TIME,FILE_SOURCE,SESSION_ID,EXTERNAL_CONVERSION_VENDOR,VENDOR,PRODUCT,VERSION,SCAN_START_TIME,SCAN_END_TIME FROM VULN_SCAN_IMPORT_QUEUE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r VulnScanImportQueueRow
        err := rows.Scan(&r.VulnScanImportQueueID, &r.VendorFileName, &r.FileNamePath, &r.CreatedTime, &r.FileSource, &r.SessionID, &r.ExternalConversionVendor, &r.Vendor, &r.Product, &r.Version, &r.ScanStartTime, &r.ScanEndTime)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeVulnScanImportQueue provide iterator to all rows of the VULN_SCAN_IMPORT_QUEUE matching given criteria.
func RangeVulnScanImportQueue(db *sql.DB, where string) iter.Seq2[*VulnScanImportQueueRow, error] {
	return func(yield func(v *VulnScanImportQueueRow, err error) bool) {
	    query := "SELECT VULN_SCAN_IMPORT_QUEUE_ID,VENDOR_FILE_NAME,FILE_NAME_PATH,CREATED_TIME,FILE_SOURCE,SESSION_ID,EXTERNAL_CONVERSION_VENDOR,VENDOR,PRODUCT,VERSION,SCAN_START_TIME,SCAN_END_TIME FROM VULN_SCAN_IMPORT_QUEUE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r VulnScanImportQueueRow
	        err := rows.Scan(&r.VulnScanImportQueueID, &r.VendorFileName, &r.FileNamePath, &r.CreatedTime, &r.FileSource, &r.SessionID, &r.ExternalConversionVendor, &r.Vendor, &r.Product, &r.Version, &r.ScanStartTime, &r.ScanEndTime)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// X509CertificateRow struct represents rows of the X509_CERTIFICATE table.
type X509CertificateRow struct {
    ID	uint
    Name	sql.NullString
    CertificateType	sql.NullInt32
    DeviceShortID	sql.NullInt32
    CaName	sql.NullString
    SubjectName	sql.NullString
    SerialNumber	sql.NullString
    NotBeforeTime	sql.NullString
    NotAfterTime	sql.NullString
    Status	sql.NullString
    CaCrlExpiry	sql.NullString
}

// IterateX509Certificate provide access to all rows of the X509_CERTIFICATE matching given criteria.
func IterateX509Certificate(db *sql.DB, where string, callback func(v *X509CertificateRow) error) error {
    query := "SELECT ID,NAME,CERTIFICATE_TYPE,DEVICE_SHORT_ID,CA_NAME,SUBJECT_NAME,SERIAL_NUMBER,NOT_BEFORE_TIME,NOT_AFTER_TIME,STATUS,CA_CRL_EXPIRY FROM X509_CERTIFICATE"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r X509CertificateRow
        err := rows.Scan(&r.ID, &r.Name, &r.CertificateType, &r.DeviceShortID, &r.CaName, &r.SubjectName, &r.SerialNumber, &r.NotBeforeTime, &r.NotAfterTime, &r.Status, &r.CaCrlExpiry)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeX509Certificate provide iterator to all rows of the X509_CERTIFICATE matching given criteria.
func RangeX509Certificate(db *sql.DB, where string) iter.Seq2[*X509CertificateRow, error] {
	return func(yield func(v *X509CertificateRow, err error) bool) {
	    query := "SELECT ID,NAME,CERTIFICATE_TYPE,DEVICE_SHORT_ID,CA_NAME,SUBJECT_NAME,SERIAL_NUMBER,NOT_BEFORE_TIME,NOT_AFTER_TIME,STATUS,CA_CRL_EXPIRY FROM X509_CERTIFICATE"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r X509CertificateRow
	        err := rows.Scan(&r.ID, &r.Name, &r.CertificateType, &r.DeviceShortID, &r.CaName, &r.SubjectName, &r.SerialNumber, &r.NotBeforeTime, &r.NotAfterTime, &r.Status, &r.CaCrlExpiry)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

// ZdiRow struct represents rows of the ZDI table.
type ZdiRow struct {
    ZdiID	string
    ZdiIsDisclosed	int8
    ZdiDisclosedDate	sql.NullInt64
}

// IterateZdi provide access to all rows of the ZDI matching given criteria.
func IterateZdi(db *sql.DB, where string, callback func(v *ZdiRow) error) error {
    query := "SELECT ZDI_ID,ZDI_IS_DISCLOSED,ZDI_DISCLOSED_DATE FROM ZDI"
	if where != "" {
		query += " WHERE " + where
	}
    rows, err := db.Query(query)
    if err != nil {
        return err
    }
    defer rows.Close()
    if rows.Err() != nil {
        return rows.Err()
    }
    for rows.Next() {
        var r ZdiRow
        err := rows.Scan(&r.ZdiID, &r.ZdiIsDisclosed, &r.ZdiDisclosedDate)
        if err != nil {
            return err
        }
        if err := callback(&r); err != nil {
            return err
        }
    }
    return nil
}

// RangeZdi provide iterator to all rows of the ZDI matching given criteria.
func RangeZdi(db *sql.DB, where string) iter.Seq2[*ZdiRow, error] {
	return func(yield func(v *ZdiRow, err error) bool) {
	    query := "SELECT ZDI_ID,ZDI_IS_DISCLOSED,ZDI_DISCLOSED_DATE FROM ZDI"
		if where != "" {
			query += " WHERE " + where
		}
    	rows, err := db.Query(query)
		if err != nil {
			yield(nil, err)
			return
		}
		defer rows.Close()
		for rows.Next() {
	        var r ZdiRow
	        err := rows.Scan(&r.ZdiID, &r.ZdiIsDisclosed, &r.ZdiDisclosedDate)
			if err != nil {
				yield(nil, err)
				return
			}
			if !yield(&r, nil) {
				return
			}
		}
    	if err := rows.Err(); err != nil {
			yield(nil, err)
		}
    }
}

